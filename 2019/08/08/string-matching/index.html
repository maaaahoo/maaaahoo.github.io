<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mah93.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="BF算法BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。">
<meta property="og:type" content="article">
<meta property="og:title" content="字符串匹配算法">
<meta property="og:url" content="https://mah93.github.io/2019/08/08/string-matching/index.html">
<meta property="og:site_name" content="mah93">
<meta property="og:description" content="BF算法BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。">
<meta property="og:locale">
<meta property="og:image" content="https://mah93.github.io/2019/08/08/string-matching/string-logo.png">
<meta property="og:image" content="https://mah93.github.io/2019/08/08/string-matching/BF.jpg">
<meta property="og:image" content="https://mah93.github.io/2019/08/08/string-matching/PMT.jpg">
<meta property="og:image" content="https://mah93.github.io/2019/08/08/string-matching/next.jpg">
<meta property="article:published_time" content="2019-08-08T04:59:26.000Z">
<meta property="article:modified_time" content="2019-08-08T05:19:32.000Z">
<meta property="article:author" content="mah93">
<meta property="article:tag" content="算法与数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mah93.github.io/2019/08/08/string-matching/string-logo.png">

<link rel="canonical" href="https://mah93.github.io/2019/08/08/string-matching/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>字符串匹配算法 | mah93</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?75a2cab18b47c5fd77ed255924ca3c7a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="mah93" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">mah93</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mah93.github.io/2019/08/08/string-matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/16695567?s=400&u=c052fb19a7414fb9dca664d1b35f9894eb7f9df4&v=4">
      <meta itemprop="name" content="mah93">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mah93">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          字符串匹配算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-08-08 12:59:26 / Modified: 13:19:32" itemprop="dateCreated datePublished" datetime="2019-08-08T12:59:26+08:00">2019-08-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/2019/08/08/string-matching/string-logo.png" class="">

<h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。</p>
<a id="more"></a> 

<img src="/2019/08/08/string-matching/BF.jpg" class="">


<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BF</span>(<span class="params">haystack, needle</span>) </span>&#123;       </span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                re = i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == needle.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(j !== <span class="number">0</span>)&#123;</span><br><span class="line">                i=i-j;</span><br><span class="line">            &#125;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>
<h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>RK算法在BF基础上，引入哈希算法。通过字符串的哈希值的比较替换掉字符串之间的比较，从而降低算法的时间复杂度。RK算法整体的时间复杂度为O(n)。其中 n 为原字符串长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成hash值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">        hash += <span class="number">26</span> * hash + string[i].charCodeAt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个字符串是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span> (<span class="params">str, dest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length !== dest.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] !== dest[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RK</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> needleHash = hash(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=(haystack.length - needle.length); i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> subStr = haystack.substr(i, needle.length);</span><br><span class="line">        <span class="keyword">if</span> (hash(subStr) === needleHash &amp;&amp; isMatch(subStr, needle)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>
<h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>BM算法的核心思想是通过将模式串沿着主串大踏步的向后滑动，从而大大减少比较次数，降低时间复杂度。而算法的关键在于如何兼顾步子迈得足够大与无遗漏，同时要尽量提高执行效率。这就需要模式串在向后滑动时，遵守坏字符规则与好后缀规则，同时采用一些技巧。</p>
<h3 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h3><p>坏字符规则：从后往前逐位比较模式串与主串的字符，当找到不匹配的坏字符时，记录模式串的下标值si，并找到坏字符在模式串中，位于下标si前的最近位置xi（若无则记为-1），si-xi即为向后滑动距离。（PS：我觉得加上xi必须在si前面，也就是比si小的条件，就不用担心计算出的距离为负了）。但是坏字符规则向后滑动的步幅还不够大，于是需要好后缀规则。</p>
<h3 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h3><p>好后缀规则：从后往前逐位比较模式串与主串的字符，当出现坏字符时停止。若存在已匹配成功的子串｛u｝，那么在模式串的｛u｝前面找到最近的｛u｝，记作｛u’｝。再将模式串后移，使得模式串的｛u’｝与主串的｛u｝重叠。若不存在｛u’｝，则直接把模式串移到主串的｛u｝后面。为了没有遗漏，需要找到最长的、能够跟模式串的前缀子串匹配的，好后缀的后缀子串（同时也是模式串的后缀子串）。然后把模式串向右移到其左边界，与这个好后缀的后缀子串在主串中的左边界对齐。</p>
<p>何时使用坏字符规则和好后缀规则呢？首先在每次匹配过程中，一旦发现坏字符，先执行坏字符规则，如果发现存在好后缀，还要执行好后缀规则，并从两者中选择后移距离最大的方案执行。</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>1.通过散列表实现，坏字符在模式串中下标位置的快速查询。<br>2.每次执行好后缀原则时，都会计算多次能够与模式串前缀子串相匹配的好后缀的最长后缀子串。为了提高效率，可以预先计算模式串的所有后缀子串，在模式串中与之匹配的另一个子串的位置。同时预计算模式串中（同长度的）后缀子串与前缀子串是否匹配并记录。在具体操作中直接使用，大大提高效率。<br>3.如何快速记录模式串后缀子串匹配的另一个子串位置，以及模式串（相同长度）前缀与后缀子串石否匹配呢？先用一个suffix数组，下标值k为后缀子串的长度，从模式串下标为i（0~m-2）的字符为最后一个字符，查找这个子串是否与后缀子串匹配，若匹配则将子串起始位置的下标值j赋给suffix[k]。若j为0，说明这个匹配子串的起始位置为模式串的起始位置，则用一个数组prefix，将prefix[k]设为true，否则设为false。k从0到m（模式串的长度）于是就得到了模式串所有前缀与后缀子串的匹配情况。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>仅有坏字符规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例只实现从&#x27;a&#x27;-&#x27;z&#x27;的字符串匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">      hash[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</span><br><span class="line">      hash[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = haystack.length;</span><br><span class="line">  <span class="keyword">let</span> m = needle.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hash = hashMap(needle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</span><br><span class="line">      <span class="keyword">let</span> bad = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</span><br><span class="line">              bad = j;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span>(bad === -<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</span><br><span class="line">      i = i + (bad - hash[ascii]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>坏字符规则在某些场景下会使si-xi为负值，导致无限循环。如在“aaaaaaa”中匹配”baaaa”。</p>
<p>下面讲好后缀原则加入，完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">suffixAndPrefix</span>(<span class="params">needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = needle.length;</span><br><span class="line">  <span class="keyword">let</span> suffix = [];</span><br><span class="line">  <span class="keyword">let</span> prefix = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i;</span><br><span class="line">    <span class="keyword">let</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; needle[j] === needle[m-<span class="number">1</span>-k]) &#123;</span><br><span class="line">      j--;</span><br><span class="line">      k++;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j===-<span class="number">1</span>)&#123;</span><br><span class="line">      prefix[k]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [suffix, prefix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveByGoodFix</span>(<span class="params">j, m, suffix, prefix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k = m - <span class="number">1</span> - j;</span><br><span class="line">  <span class="keyword">if</span>(suffix[k] !== -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] + <span class="number">1</span>; <span class="comment">// 如果存在匹配的好后缀子集，滑动到坏字符的下一位</span></span><br><span class="line">  <span class="comment">// TODO 为什么要寻找？</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=j+<span class="number">2</span>; i&lt;=m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prefix[m-i] === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">      hash[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</span><br><span class="line">      hash[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = haystack.length;</span><br><span class="line">  <span class="keyword">let</span> m = needle.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [ suffix, prefix ] = suffixAndPrefix(needle);</span><br><span class="line">  <span class="keyword">let</span> hash = hashMap(needle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</span><br><span class="line">      <span class="keyword">let</span> bad = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</span><br><span class="line">              bad = j;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span>(bad === -<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</span><br><span class="line">      <span class="keyword">let</span> badChar = bad - hash[ascii];</span><br><span class="line">      <span class="keyword">let</span> goodFix = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 判断是否有好后缀</span></span><br><span class="line">      <span class="keyword">if</span>(bad&lt;m-<span class="number">1</span>)&#123;</span><br><span class="line">        goodFix = moveByGoodFix(bad, m, suffix, prefix);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      i = i + <span class="built_in">Math</span>.max(badChar, goodFix);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="PMT数组"><a href="#PMT数组" class="headerlink" title="PMT数组"></a>PMT数组</h3><p>KMP算法的核心，是一个被称为部分匹配表(Partial Match Table)的数组。</p>
<img src="/2019/08/08/string-matching/PMT.jpg" class="">

<p><strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。</p>
<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。</p>
<img src="/2019/08/08/string-matching/next.jpg" class="">

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> k = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; needle[i] != needle[k+<span class="number">1</span>]) &#123;</span><br><span class="line">          k = res[k]; <span class="comment">// 当不匹配的时候，回溯寻找次长串</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needle[i] === needle[k+<span class="number">1</span>]) &#123;</span><br><span class="line">          k++;</span><br><span class="line">      &#125;</span><br><span class="line">      res[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = haystack.length;</span><br><span class="line">  <span class="keyword">let</span> m = needle.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextArray = next(needle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] !== needle[j])&#123;</span><br><span class="line">      j = nextArray[j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(haystack[i] == needle[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == m)&#123;</span><br><span class="line">      <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">空间复杂度</th>
<th align="center">最好时间复杂度</th>
<th align="center">最差时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BF算法</td>
<td align="center">T(1)</td>
<td align="center">O(nm)</td>
<td align="center">O(nm)</td>
</tr>
<tr>
<td align="center">RK算法</td>
<td align="center">T(1)</td>
<td align="center">O(n+m)</td>
<td align="center">O(nm)</td>
</tr>
<tr>
<td align="center">BM算法</td>
<td align="center">T(2m)</td>
<td align="center">O(n)</td>
<td align="center">O(nm)</td>
</tr>
<tr>
<td align="center">KMP算法</td>
<td align="center">T(m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(nm)</td>
</tr>
</tbody></table>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>BF算法是最容易想到的算法，只需要逐个字符去比较，遇到不匹配的字符只需要将主串字符向后移动一位，重复比较即可。</p>
<p>RK算法在BF的基础上，引入了hash值。核心理念是：hash值不相同的两个字符串一定不想等，hash相等的字符串才有可能相等。通过hash值的运算大大降低了字符比较的次数。</p>
<p>BM算法提出坏字符和好后缀的规则，从字符串的尾部开始比较。遇到坏字符则大幅度向后滑动，好后缀规则是记录模式串中前后是否有相同的部分。两个规则中移动距离比较远的，则成为下一次循环比较的开始。</p>
<p>KMP算法在BM算法的基础上，直接先计算模式串的“重复度”即模式串的前后字符是否有相同的部分，匹配到不等的字符就可以把之前比较相等的部分跳过。</p>
<p>BM和KMP都是处理模式串本身，与主串无关。都是为了在下一次比较的时候能够大幅度的向后移动，以提高字符串匹配的速度。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71187">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d38fcfcf265da1bcb4f6fce">JavaScript 字符串匹配算法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 算法与数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/19/js-linked/" rel="prev" title="js单链表实现">
      <i class="fa fa-chevron-left"></i> js单链表实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/12/binary-search/" rel="next" title="二分查找">
      二分查找 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BF%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">BF算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RK%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">RK算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">BM算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%8F%E5%AD%97%E7%AC%A6"><span class="nav-number">3.1.</span> <span class="nav-text">坏字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%BD%E5%90%8E%E7%BC%80"><span class="nav-number">3.2.</span> <span class="nav-text">好后缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7"><span class="nav-number">3.3.</span> <span class="nav-text">技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">KMP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PMT%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.</span> <span class="nav-text">PMT数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next%E6%95%B0%E7%BB%84"><span class="nav-number">4.2.</span> <span class="nav-text">next数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="nav-number">5.</span> <span class="nav-text">算法比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97"><span class="nav-number">6.</span> <span class="nav-text">学习心得</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mah93"
      src="https://avatars2.githubusercontent.com/u/16695567?s=400&u=c052fb19a7414fb9dca664d1b35f9894eb7f9df4&v=4">
  <p class="site-author-name" itemprop="name">mah93</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mah93" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mah93" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mahao9393@163.com" title="E-Mail → mahao9393@163.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mah93</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '',
      clientSecret: '',
      repo        : 'mah93.github.io',
      owner       : '',
      admin       : [''],
      id          : '10cba2e439ec65b01fd3a269236046f4',
        language: '',
      distractionFreeMode: 
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
