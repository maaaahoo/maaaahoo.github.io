<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mah93</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mah93.github.io/"/>
  <updated>2020-12-22T03:30:53.201Z</updated>
  <id>https://mah93.github.io/</id>
  
  <author>
    <name>mah93</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript的数据结构汇总-02</title>
    <link href="https://mah93.github.io/2020/12/22/js-data-structure-02/"/>
    <id>https://mah93.github.io/2020/12/22/js-data-structure-02/</id>
    <published>2020-12-22T03:28:31.000Z</published>
    <updated>2020-12-22T03:30:53.201Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/12/22/js-data-structure-02/js-data-struct.png" alt="js-data-struct.png" title=""><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。</p><p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址，单向链表只可向一个方向遍历。</p><a id="more"></a> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单项链表节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(val) &#123;</div><div class="line">    <span class="keyword">this</span>.val = val;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 单向链表</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedListNode(<span class="string">"head"</span>);</div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 向链表尾添加一个元素</span></div><div class="line">  append = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> newItem = <span class="keyword">new</span> LinkedListNode(val);</div><div class="line">    <span class="keyword">let</span> lastNode = <span class="keyword">this</span>.findByIndex(<span class="keyword">this</span>.size);</div><div class="line">    <span class="keyword">if</span> (lastNode !== <span class="literal">null</span>) &#123;</div><div class="line">      lastNode.next = newItem;</div><div class="line">      <span class="keyword">this</span>.size ++;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`&lt;<span class="subst">$&#123;val&#125;</span>&gt;添加失败`</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 删除一个指定节点</span></div><div class="line">  remove = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123; </div><div class="line">    <span class="keyword">let</span> preNode = <span class="keyword">this</span>.findPreNode(val);</div><div class="line">    <span class="keyword">if</span> (preNode !== <span class="literal">null</span> &amp;&amp; preNode.next !== <span class="literal">null</span>) &#123;</div><div class="line">      preNode.next = preNode.next.next;</div><div class="line">      <span class="keyword">this</span>.size --;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`&lt;<span class="subst">$&#123;val&#125;</span>&gt;删除失败`</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 删除一个指定位置的节点</span></div><div class="line">  removeByIndex = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> indexNode = <span class="keyword">this</span>.findByIndex(index - <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span>(indexNode != <span class="literal">null</span> &amp;&amp; indexNode.next != <span class="literal">null</span>) &#123;</div><div class="line">      indexNode.next = indexNode.next.next;</div><div class="line">      <span class="keyword">this</span>.size --;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`删除位于<span class="subst">$&#123;index&#125;</span>处节点失败`</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 在指定节点后插入一个元素</span></div><div class="line">  insert = <span class="function">(<span class="params">val, newVal</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.find(val);</div><div class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> LinkedListNode(newVal);</div><div class="line">    <span class="keyword">if</span>(node.next == <span class="literal">null</span>) &#123;</div><div class="line">      node.next = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">let</span> temp = node.next;</div><div class="line">      node.next = newNode;</div><div class="line">      newNode.next = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.size++;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 在指定位置后一个位置插入一个元素</span></div><div class="line">  insertByIndex = <span class="function">(<span class="params">index, newVal</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.findByIndex(index);</div><div class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> LinkedListNode(newVal);</div><div class="line">    <span class="keyword">if</span>(node.next == <span class="literal">null</span>) &#123;</div><div class="line">      node.next = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">let</span> temp = node.next;</div><div class="line">      node.next = newNode;</div><div class="line">      newNode.next = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.size++;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查找等于某值的节点</span></div><div class="line">  find = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">null</span> &amp;&amp; currentNode.val != val) &#123;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currentNode;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查找位于某位置的节点</span></div><div class="line">  findByIndex = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.size) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currentNode;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查找等于某值的前驱节点  </span></div><div class="line">  findPreNode = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">null</span> &amp;&amp; currentNode.next !== <span class="literal">null</span> &amp;&amp; currentNode.next.val != val) &#123;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currentNode;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 清空链表</span></div><div class="line">  clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.head.next = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 链表大小</span></div><div class="line">  size = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 打印</span></div><div class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> printString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">null</span>) &#123;</div><div class="line">      printString = printString + <span class="string">'--&gt;'</span> + currentNode.val;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(printString);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testLinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> myLinkedList = <span class="keyword">new</span> LinkedList();</div><div class="line">  myLinkedList.append(<span class="string">"节点1"</span>);</div><div class="line">  myLinkedList.append(<span class="string">"节点2"</span>);</div><div class="line">  myLinkedList.append(<span class="string">"节点3"</span>);</div><div class="line">  myLinkedList.append(<span class="string">"节点4"</span>);</div><div class="line">  myLinkedList.append(<span class="string">"节点5"</span>);</div><div class="line">  myLinkedList.append(<span class="string">"节点6"</span>);</div><div class="line"></div><div class="line">  myLinkedList.remove(<span class="string">"节点5"</span>);</div><div class="line">  myLinkedList.remove(<span class="string">"节点6"</span>);</div><div class="line">  myLinkedList.remove(<span class="string">"节点6"</span>);</div><div class="line"></div><div class="line">  myLinkedList.removeByIndex(<span class="number">2</span>);</div><div class="line"></div><div class="line">  myLinkedList.insert(<span class="string">"节点1"</span>, <span class="string">"新节点2"</span>);</div><div class="line">  myLinkedList.insert(<span class="string">"节点4"</span>, <span class="string">"新节点4"</span>);</div><div class="line"></div><div class="line">  myLinkedList.insertByIndex(<span class="number">3</span>, <span class="string">"新节点3"</span>);</div><div class="line"></div><div class="line">  myLinkedList.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span>--&gt;节点<span class="number">5</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span>--&gt;节点<span class="number">5</span>--&gt;节点<span class="number">6</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span>--&gt;节点<span class="number">6</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span></div><div class="line">&lt;节点<span class="number">6</span>&gt;删除失败</div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;新节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;新节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;节点<span class="number">4</span>--&gt;新节点<span class="number">4</span></div><div class="line">--&gt;head--&gt;节点<span class="number">1</span>--&gt;新节点<span class="number">2</span>--&gt;节点<span class="number">3</span>--&gt;新节点<span class="number">3</span>--&gt;节点<span class="number">4</span>--&gt;新节点<span class="number">4</span></div><div class="line">--&gt;head</div></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针。所以在双向链表中的结点都有两个指针域：<strong>一个指向直接后继，一个指向直接前驱</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双向链表节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedListNode</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(val) &#123;</div><div class="line">    <span class="keyword">this</span>.val = val;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.pre = <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 双向链表</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> DoublyLinkedListNode(<span class="string">"head"</span>);</div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  append = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> lastNode = <span class="keyword">this</span>.findByIndex(<span class="keyword">this</span>.size);</div><div class="line">    <span class="keyword">if</span>(lastNode != <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">let</span> newNode = <span class="keyword">new</span> DoublyLinkedListNode(val);</div><div class="line">      lastNode.next = newNode;</div><div class="line">      newNode.pre = lastNode;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.size++;</div><div class="line">      <span class="keyword">this</span>.print();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`&lt;<span class="subst">$&#123;val&#125;</span>&gt;添加失败`</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  insert = <span class="function">(<span class="params">val, newVal</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> valNode = <span class="keyword">this</span>.findByVal(val);</div><div class="line">    <span class="keyword">if</span> (valNode != <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">let</span> newNode = <span class="keyword">new</span> DoublyLinkedListNode(newVal);</div><div class="line">      <span class="keyword">let</span> tempNode = valNode.next;</div><div class="line">      <span class="keyword">if</span>(tempNode != <span class="literal">null</span>) &#123;</div><div class="line">        tempNode.pre= newNode;</div><div class="line">      &#125; </div><div class="line"></div><div class="line">      valNode.next = newNode;</div><div class="line">      newNode.pre = valNode;</div><div class="line">      newNode.next = tempNode;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.size++;</div><div class="line">      <span class="keyword">this</span>.print();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`该链表不存在&lt;<span class="subst">$&#123;val&#125;</span>&gt;节点`</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  remove = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.findByVal(val);</div><div class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(node.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">let</span> preNode = node.pre;</div><div class="line">        <span class="keyword">let</span> nextNode = node.next;</div><div class="line">        preNode.next = nextNode;</div><div class="line">        nextNode.pre = preNode;</div><div class="line"></div><div class="line">        node.pre = <span class="literal">null</span>;</div><div class="line">        node.next = <span class="literal">null</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> preNode = node.pre;</div><div class="line">        preNode.next = <span class="literal">null</span>;</div><div class="line">        node.pre = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.size--;</div><div class="line">      <span class="keyword">this</span>.print();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">`该链表不存在&lt;<span class="subst">$&#123;val&#125;</span>&gt;节点`</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  findByVal = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currentNode.val != val) &#123;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currentNode;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 查找位于某位置的节点</span></div><div class="line">  findByIndex = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.size) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currentNode;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> printString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">null</span>) &#123;</div><div class="line">      printString = printString + <span class="string">'--&gt;'</span> + currentNode.val;</div><div class="line">      currentNode = currentNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(printString);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试双向链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> myDoubyLinkedList = <span class="keyword">new</span> DoublyLinkedList();</div><div class="line">  myDoubyLinkedList.append(<span class="string">"双向节点1"</span>);</div><div class="line">  myDoubyLinkedList.append(<span class="string">"双向节点2"</span>);</div><div class="line">  myDoubyLinkedList.append(<span class="string">"双向节点3"</span>);</div><div class="line"></div><div class="line">  myDoubyLinkedList.insert(<span class="string">"双向节点1"</span>, <span class="string">"插入节点1"</span>);</div><div class="line">  myDoubyLinkedList.insert(<span class="string">"双向节点3"</span>, <span class="string">"插入节点3"</span>);</div><div class="line"></div><div class="line">  myDoubyLinkedList.remove(<span class="string">"双向节点2"</span>);</div><div class="line">  myDoubyLinkedList.remove(<span class="string">"插入节点3"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;双向节点<span class="number">2</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;双向节点<span class="number">2</span>--&gt;双向节点<span class="number">3</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;插入节点<span class="number">1</span>--&gt;双向节点<span class="number">2</span>--&gt;双向节点<span class="number">3</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;插入节点<span class="number">1</span>--&gt;双向节点<span class="number">2</span>--&gt;双向节点<span class="number">3</span>--&gt;插入节点<span class="number">3</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;插入节点<span class="number">1</span>--&gt;双向节点<span class="number">3</span>--&gt;插入节点<span class="number">3</span></div><div class="line">--&gt;head--&gt;双向节点<span class="number">1</span>--&gt;插入节点<span class="number">1</span>--&gt;双向节点<span class="number">3</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/12/22/js-data-structure-02/js-data-struct.png&quot; alt=&quot;js-data-struct.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h2&gt;&lt;p&gt;单向链表是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。&lt;/p&gt;
&lt;p&gt;一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址，单向链表只可向一个方向遍历。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的数据结构汇总-01</title>
    <link href="https://mah93.github.io/2020/12/22/js-data-structure-01/"/>
    <id>https://mah93.github.io/2020/12/22/js-data-structure-01/</id>
    <published>2020-12-22T03:05:14.000Z</published>
    <updated>2020-12-22T03:30:50.450Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/12/22/js-data-structure-01/js-data-struct.png" alt="js-data-struct.png" title=""><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是一种先进先出的、操作受限的线性表。必须从队尾插入新元素，队列中的元素只能从队首取出。下面是用数组实现的简单队列。</p><a id="more"></a> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 队列</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.queue.length;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 向队列中添加一个元素</span></div><div class="line">  enqueue = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.queue.push(item)</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 从队列中取出一个元素</span></div><div class="line">  dequeue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.queue.shift();</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 获取队列的大小</span></div><div class="line">  size = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 清空队列</span></div><div class="line">  clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.queue = [];</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 显示队列</span></div><div class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`当前队列：<span class="subst">$&#123;<span class="keyword">this</span>.queue&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testQueue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> myQueue = <span class="keyword">new</span> Queue();</div><div class="line">  myQueue.enqueue(<span class="string">"队列1"</span>);</div><div class="line">  myQueue.enqueue(<span class="string">"队列2"</span>);</div><div class="line">  myQueue.enqueue(<span class="string">"队列3"</span>);</div><div class="line">  myQueue.dequeue();</div><div class="line">  myQueue.dequeue();</div><div class="line">  myQueue.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">当前队列：队列<span class="number">1</span></div><div class="line">当前队列：队列<span class="number">1</span>,队列<span class="number">2</span></div><div class="line">当前队列：队列<span class="number">1</span>,队列<span class="number">2</span>,队列<span class="number">3</span></div><div class="line">当前队列：队列<span class="number">2</span>,队列<span class="number">3</span></div><div class="line">当前队列：队列<span class="number">3</span></div><div class="line">当前队列：</div></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是只允许在同一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。下面是使用数组实现的简单栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.stack.length;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 入栈</span></div><div class="line">  push = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.stack.unshift(item);</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 出栈</span></div><div class="line">  pop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.stack.shift();</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 查看栈元素个数</span></div><div class="line">  size = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 清空栈</span></div><div class="line">  clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.stack = [];</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`当前栈：<span class="subst">$&#123;<span class="keyword">this</span>.stack&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试栈</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testStack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> myStack = <span class="keyword">new</span> Stack();</div><div class="line">  myStack.push(<span class="string">"栈1"</span>);</div><div class="line">  myStack.push(<span class="string">"栈2"</span>);</div><div class="line">  myStack.push(<span class="string">"栈3"</span>);</div><div class="line">  myStack.pop();</div><div class="line">  myStack.pop();</div><div class="line">  myStack.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">当前栈：栈<span class="number">1</span></div><div class="line">当前栈：栈<span class="number">2</span>,栈<span class="number">1</span></div><div class="line">当前栈：栈<span class="number">3</span>,栈<span class="number">2</span>,栈<span class="number">1</span></div><div class="line">当前栈：栈<span class="number">2</span>,栈<span class="number">1</span></div><div class="line">当前栈：栈<span class="number">1</span></div><div class="line">当前栈：</div></pre></td></tr></table></figure><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>散列函数在整个过程中起着非常关键的作用，它将数据一一映射到散列表中。散列表的设计需要遵循一下规则：</p><ol><li>得到的散列值是一个非负整数</li><li>两个相同的键，通过散列函数计算出的散列值也相同</li><li>两个不同的键，计算出的散列值不同</li></ol><p>虽然我们在设计的时候要求满足以上三条要求，但是对于第三条来说，想要找到不同的 key 对应的散列值都不一样的散列函数是不可能的。即使现在非常著名的 <strong>MD5</strong>、<strong>SHA</strong>、<strong>CRC</strong> 哈希算法，也没办法避免这用<strong>哈希冲突</strong>。而且因为数组的存储空间有限，也会加大这种<strong>哈希冲突</strong>。</p><p>解决<strong>哈希冲突</strong>一般有两种方式，开放寻址法和链表法。</p><p>开放寻址法，当遇到哈希冲突的时候，在散列表中向下寻找一个空闲位置放入</p><p>链表法，在散列表每个位置存放一个链表，当出现哈希冲突的时候只需要在链表中添加一个元素即可。</p><p>下面是使用链表法实现的散列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.hashTable = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">13</span>);</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 哈希函数</span></div><div class="line">  hashCode = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</div><div class="line">        hash += key.charCodeAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hash % <span class="number">13</span>;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 链表解决哈希冲突</span></div><div class="line">  push = <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="keyword">this</span>.hashCode(key);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hashTable[hash] == <span class="literal">undefined</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.hashTable[hash] = <span class="keyword">new</span> LinkedList();</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">this</span>.hashTable[hash].append(&#123;</div><div class="line">      key: key,</div><div class="line">      value: value</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 获取hash表内数据</span></div><div class="line">  get = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="keyword">this</span>.hashCode(key);</div><div class="line">    <span class="keyword">let</span> link = <span class="keyword">this</span>.hashTable[hash];</div><div class="line">    <span class="keyword">if</span>(link != <span class="literal">undefined</span>) &#123;</div><div class="line">      <span class="keyword">let</span> currentNode = link.head;</div><div class="line">      <span class="keyword">while</span>(currentNode.val.key != key) &#123;</div><div class="line">        currentNode = currentNode.next;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> currentNode?.val.value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 删除hash表内数据</span></div><div class="line">  remove = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="keyword">this</span>.hashCode(key);</div><div class="line">    <span class="keyword">let</span> link = <span class="keyword">this</span>.hashTable[hash];</div><div class="line">    <span class="keyword">if</span>(link != <span class="literal">undefined</span>) &#123;</div><div class="line">      <span class="keyword">let</span> currentNode = link.head;</div><div class="line">      <span class="keyword">while</span>(currentNode.next != <span class="literal">null</span> &amp;&amp; currentNode.next.val.key != key) &#123;</div><div class="line">        currentNode = currentNode.next;</div><div class="line">      &#125;</div><div class="line">      currentNode.next = currentNode.next.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  print = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> printString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.hashTable.length; i++) &#123;</div><div class="line">      <span class="keyword">let</span> link = <span class="keyword">this</span>.hashTable[i];</div><div class="line">      <span class="keyword">if</span> (link == <span class="literal">undefined</span>)&#123;</div><div class="line">        printString = printString + <span class="string">''</span> + <span class="string">','</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> currentNode = link.head.next;</div><div class="line">        <span class="keyword">let</span> tempString = <span class="string">''</span>;</div><div class="line">        <span class="keyword">while</span>(currentNode != <span class="literal">null</span>) &#123;</div><div class="line">          tempString = tempString + <span class="string">'--&gt;'</span> + currentNode.val.key + <span class="string">'-'</span> + currentNode.val.value;</div><div class="line">          currentNode = currentNode.next;</div><div class="line">        &#125;</div><div class="line">        printString = printString + tempString + <span class="string">','</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(printString);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testHashTable</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> myHashTable = <span class="keyword">new</span> HashTable();</div><div class="line">  myHashTable.push(<span class="string">'a7'</span>, <span class="string">'哈希1'</span>);</div><div class="line">  myHashTable.push(<span class="string">'b6'</span>, <span class="string">'哈希2'</span>);</div><div class="line">  myHashTable.push(<span class="string">'k3i'</span>, <span class="string">'哈希3'</span>);</div><div class="line">  myHashTable.push(<span class="string">'k21'</span>, <span class="string">'哈希4'</span>);</div><div class="line">  myHashTable.push(<span class="string">'oop1'</span>, <span class="string">'哈希5'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(myHashTable.get(<span class="string">'aki'</span>));</div><div class="line">  <span class="built_in">console</span>.log(myHashTable.get(<span class="string">'oop1'</span>));</div><div class="line"></div><div class="line">  myHashTable.remove(<span class="string">'k21'</span>);</div><div class="line">  myHashTable.remove(<span class="string">'a7'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">--&gt;head--&gt;[object <span class="built_in">Object</span>]</div><div class="line">,,,,,,,,,--&gt;a7-哈希<span class="number">1</span>,,,,</div><div class="line">--&gt;head--&gt;[object <span class="built_in">Object</span>]--&gt;[object <span class="built_in">Object</span>]</div><div class="line">,,,,,,,,,--&gt;a7-哈希<span class="number">1</span>--&gt;b6-哈希<span class="number">2</span>,,,,</div><div class="line">--&gt;head--&gt;[object <span class="built_in">Object</span>]</div><div class="line">,,,--&gt;k3i-哈希<span class="number">3</span>,,,,,,--&gt;a7-哈希<span class="number">1</span>--&gt;b6-哈希<span class="number">2</span>,,,,</div><div class="line">--&gt;head--&gt;[object <span class="built_in">Object</span>]</div><div class="line">,,,--&gt;k3i-哈希<span class="number">3</span>,,,,,,--&gt;a7-哈希<span class="number">1</span>--&gt;b6-哈希<span class="number">2</span>,,--&gt;k21-哈希<span class="number">4</span>,,</div><div class="line">--&gt;head--&gt;[object <span class="built_in">Object</span>]</div><div class="line">,,,--&gt;k3i-哈希<span class="number">3</span>,,,--&gt;oop1-哈希<span class="number">5</span>,,,--&gt;a7-哈希<span class="number">1</span>--&gt;b6-哈希<span class="number">2</span>,,--&gt;k21-哈希<span class="number">4</span>,,</div><div class="line"><span class="literal">undefined</span></div><div class="line">哈希<span class="number">5</span></div><div class="line">,,,--&gt;k3i-哈希<span class="number">3</span>,,,--&gt;oop1-哈希<span class="number">5</span>,,,--&gt;a7-哈希<span class="number">1</span>--&gt;b6-哈希<span class="number">2</span>,,,,</div><div class="line">,,,--&gt;k3i-哈希<span class="number">3</span>,,,--&gt;oop1-哈希<span class="number">5</span>,,,--&gt;b6-哈希<span class="number">2</span>,,,,</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/12/22/js-data-structure-01/js-data-struct.png&quot; alt=&quot;js-data-struct.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;队列（queue）是一种先进先出的、操作受限的线性表。必须从队尾插入新元素，队列中的元素只能从队首取出。下面是用数组实现的简单队列。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>苹果商务上架</title>
    <link href="https://mah93.github.io/2020/12/08/apple-business/"/>
    <id>https://mah93.github.io/2020/12/08/apple-business/</id>
    <published>2020-12-08T08:25:35.000Z</published>
    <updated>2020-12-08T08:33:56.243Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/12/08/apple-business/abm-logo.jpeg" alt="abm-logo.jpeg" title=""><p>近期需要上架一款企业内部员工使用的app，通过正常的上架流程会得到Apple审核团队的拒绝，并推荐我使用Apple Business Manager方式上架改应用。之前从来没听过这个上架方式，现在记录一下使用Apple Business Manager上架的全流程</p><a id="more"></a> <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apple Business Manager是苹果公司新推出的一种应用分发模式，主要是为了两种类型的应用服务：</p><ol><li>企业内部使用，不面向普通用户</li><li>公司为其他企业定制的特殊的应用，比如中国移动内部使用的微信</li></ol><p>由于企业证书的申请困难，企业应用又无法在App Store中上架，所以Apple Business Manager这种分发模式将会越来越主流。</p><p>更多详细的内容，请移步<a href="https://developer.apple.com/business/distribute/" target="_blank" rel="external">苹果商务官网</a></p><h2 id="分发模式比较"><a href="#分发模式比较" class="headerlink" title="分发模式比较"></a>分发模式比较</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">App Store</th><th style="text-align:center">In-house</th><th style="text-align:center">App Business Manager</th><th style="text-align:center">蒲公英</th><th style="text-align:center">TestFlight</th></tr></thead><tbody><tr><td style="text-align:center">分发方式</td><td style="text-align:center">在App Store中直接下载</td><td style="text-align:center">由开发者自行分发</td><td style="text-align:center">通过链接在iTunes Store中下载</td><td style="text-align:center">访问蒲公英的下载链接</td><td style="text-align:center">邮件邀请在TestFlight中下载</td></tr><tr><td style="text-align:center">可用性</td><td style="text-align:center">公开发布</td><td style="text-align:center">分发给指定用户</td><td style="text-align:center">私密发布，拥有兑换码即可下载</td><td style="text-align:center">ad证书中注册过uuid的用户</td><td style="text-align:center">邮件邀请用户或者公测用户</td></tr><tr><td style="text-align:center">App Store Connect</td><td style="text-align:center">可用</td><td style="text-align:center">不可用</td><td style="text-align:center">可用</td><td style="text-align:center">不可用</td><td style="text-align:center">可用</td></tr><tr><td style="text-align:center">是否需要审核</td><td style="text-align:center">需要</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">账号以及费用</td><td style="text-align:center">$99/年</td><td style="text-align:center">$299/年</td><td style="text-align:center">免费</td><td style="text-align:center">免费</td><td style="text-align:center">$99/年</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">正常上架的应用</td><td style="text-align:center">企业内部应用</td><td style="text-align:center">企业内部应用</td><td style="text-align:center">初期测试版本</td><td style="text-align:center">上架前测试或者公测</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">审核严格每次审核时间在2-3天</td><td style="text-align:center">企业证书申请困难</td><td style="text-align:center">兑换码下载方式每次只能兑换25000个并且用完一次链接就失效</td><td style="text-align:center">必须提前注册uuid只能给小于100个机器安装</td><td style="text-align:center">需要在TestFlight中下载，应用有效期三个月</td></tr></tbody></table><h2 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h2><p>提前准备材料</p><ol><li>邓白氏码</li><li>以及公司资料需要与Apple ID中的资料一致</li></ol><p>登录<a href="https://business.apple.com/" target="_blank" rel="external">苹果商务</a>点击下方注册按钮</p><img src="/2020/12/08/apple-business/abm-re.png" alt="abm-re.png" title=""><p>输入邓白氏码之后，公司组织的相信息会自动填写，剩下的内容只需要如实填写即可</p><img src="/2020/12/08/apple-business/abm-re2.png" alt="abm-re2.png" title=""><p>这里验证联系人的信息一定要填写正确，提交申请之后Apple公司会联系这个人来核实信息。</p><p>一般来说是填写leader的联系方式，不过这里写自己应该也是可以的。</p><p>提交所有信息资料之后等待即可</p><img src="/2020/12/08/apple-business/abm-re3.png" alt="abm-re3.png" title=""><blockquote><p>我上午提交的申请，大概下午就得到了回复速度还是很快的</p></blockquote><p>电话沟通之后，如果Apple审核通过则会收到下一封邮件</p><img src="/2020/12/08/apple-business/abm-re4.png" alt="abm-re4.png" title=""><p>点击开始使用跳转到<a href="https://business.apple.com/" target="_blank" rel="external">苹果商务</a>中继续填写内容</p><p>这里需要注册一个新的Apple ID作为Apple Business Manager的登录账号，注意不可以使用已有的账号，必须注册一个新的账号，并且账号的后缀和公司相关，不可以使用qq邮箱或者其他的邮箱地址。最好使用你的公司邮箱作为账号。注册完之后即可正常登录Apple Business Manager的使用页面。</p><p>首先在设置中启用自定App</p><img src="/2020/12/08/apple-business/abm-setting.png" alt="abm-setting.png" title=""><h2 id="上架"><a href="#上架" class="headerlink" title="上架"></a>上架</h2><p>App Business上架流程依旧和普通的App流程相同，在App Store Connect中填写app的信息以及安装包，唯一的区别就是在<strong>价格与销售范围</strong>中，将分发模式修改为私密分发</p><img src="/2020/12/08/apple-business/abm-way.png" alt="abm-way.png" title=""><p>所有的内容填写完毕之后，即可提交审核。</p><h2 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h2><p>审核通过之后，应用并不会出现在App Store中。需要再次登录苹果商务的网站中进行发布。</p><img src="/2020/12/08/apple-business/abm-d.png" alt="abm-d.png" title=""><p>审核通过之后的app会出现在自定App中，选中要发布的App，许可类型选择<strong>兑换码</strong>，数量输入1-25000份点击获取，成功之后即可下载一份excel标哥，里面记录了App下载的链接。把链接直接发送给指定的用户即可完成下载。</p><blockquote><p>如果许可类型选择了<strong>管理式</strong>，请提前了解MDM(Mobile Device Manage)。</p><p>如果需要更多的兑换码，可以给苹果商务账号多增加一些子账号，每个子账号每周都可以买25000个兑换码。</p><p>如果获取之后，没有看到下载按钮，等待一段时间并刷新页面即可</p><p>Excel中的下载链接，使用一次成功下载之后，这个链接就失效了</p><p>通过App Business Manager方式分发的App将通过<strong>iTunes Store</strong>中下载</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/c8361a83a338" target="_blank" rel="external">iOS应用发布方式盘点+苹果商务详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/12/08/apple-business/abm-logo.jpeg&quot; alt=&quot;abm-logo.jpeg&quot; title=&quot;&quot;&gt;
&lt;p&gt;近期需要上架一款企业内部员工使用的app，通过正常的上架流程会得到Apple审核团队的拒绝，并推荐我使用Apple Business Manager方式上架改应用。之前从来没听过这个上架方式，现在记录一下使用Apple Business Manager上架的全流程&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://mah93.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CodePush</title>
    <link href="https://mah93.github.io/2020/08/05/code-push/"/>
    <id>https://mah93.github.io/2020/08/05/code-push/</id>
    <published>2020-08-05T03:05:25.000Z</published>
    <updated>2020-08-05T03:14:31.448Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/08/05/code-push/code-push-logo.png" alt="code-push-logo.png" title=""><p>App的热更新即，不通过应用商店的审核，直接下载远程的代码更新用户手机中的app。由于iOS应用审核周期长，审核规则复杂所以热更新对于iOS平台来说显得更为迫切，但在原生的iOS代码中实现起来比较复杂，有被拒绝的风险。而React Native由于其加载jsbundle的特点，实现热更新并不复杂。而采用Js热更新的React Native并没有受到WaxPatch、JSPatch等热修复框架被禁止的影响。</p><p>React Native的热更新方案有很多种，比如微软的CodePush、或者如携程的jsbundle拆分方案等，但是基本原理都是一致的，就是远程加载jsbundle，下面记录实现热更新的几种方案</p><p>CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。<br>CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p><a id="more"></a> <h2 id="安装以及配置"><a href="#安装以及配置" class="headerlink" title="安装以及配置"></a>安装以及配置</h2><h3 id="安装code-push-cli"><a href="#安装code-push-cli" class="headerlink" title="安装code-push cli"></a>安装code-push cli</h3><p>在控制台输入</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g code-<span class="keyword">push</span>-<span class="keyword">cli</span></div></pre></td></tr></table></figure><p>即可安装，完成之后输入<code>code-push -v</code>查看版本即代表安装成功</p><h3 id="创建CodePush账号"><a href="#创建CodePush账号" class="headerlink" title="创建CodePush账号"></a>创建CodePush账号</h3><p>在终端输入<code>code-push register</code>会打开注册的网页</p><img src="/2020/08/05/code-push/re-codepush.png" alt="re-codepush.png" title=""><p>注册成功之后会返回你一个token，复制粘贴到终端就完成了。</p><p>然后终端输入<code>code-push login</code>进行登录，登录成功后，你的session文件将会写在 /Users/你的用户名/.code-push.config</p><blockquote><p>相关命令</p><ul><li><code>code-push login</code> 登陆</li><li><code>code-push loout</code> 注销</li><li><code>code-push access-key ls</code> 列出登陆的token</li><li><code>code-push access-key rm &lt;accessKye&gt;</code> 删除某个 access-key</li></ul></blockquote><h3 id="注册App"><a href="#注册App" class="headerlink" title="注册App"></a>注册App</h3><p>我们需要向CodePush注册我们的app，使用<code>code-push app add &lt;appname&gt; &lt;os&gt; &lt;platform&gt;</code>注册成功之后，会返回一套deployment key</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="meta">code</span>-<span class="keyword">push </span>app <span class="keyword">add </span>myapp-ios ios react-native</div><div class="line">$ <span class="meta">code</span>-<span class="keyword">push </span>app <span class="keyword">add </span>myapp-<span class="keyword">android </span><span class="keyword">android </span>react-native</div></pre></td></tr></table></figure><blockquote><p> ios应用和安卓应用建议分开创建</p><p>相关命令</p><ul><li><code>add</code> 在账号里面添加一个新的app</li><li><code>remove</code> 或者 <code>rm</code> 在账号里移除一个app</li><li><code>rename</code> 重命名一个存在app</li><li><code>list</code> 或则 <code>ls</code> 列出账号下面的所有app</li><li><code>transfer</code> 把app的所有权转移到另外一个账号</li></ul></blockquote><h3 id="在项目中引用CodePush"><a href="#在项目中引用CodePush" class="headerlink" title="在项目中引用CodePush"></a>在项目中引用CodePush</h3><p>在项目中添加CodePush插件</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --<span class="keyword">save</span> react-native-<span class="built_in">code</span>-<span class="keyword">push</span></div></pre></td></tr></table></figure><blockquote><p>react-native版本在0.60以前需要执行</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; $ react-<span class="keyword">native</span> link react-<span class="keyword">native</span>-code-<span class="keyword">push</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>react-native版本在0.60以后需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> $ <span class="built_in">cd</span> ios &amp; pod install</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="iOS配置"><a href="#iOS配置" class="headerlink" title="iOS配置"></a>iOS配置</h3><ul><li><p>info.plist</p><p>修改info.plist 添加CodePushDeploymentKey键值对中的Staging的值，Deployment Key可以通过命令code-push deployment ls appName –displayKeys进行获取.也可以使用$(CODEPUSH_KEY)来自动适配Production或Staging环境, 如果填的是Production的key, 则打的包就是Production的包, 如果填的是Staging的key, 则打的包就是Staging的包.</p></li></ul><img src="/2020/08/05/code-push/codepush-xcode.png" alt="codepush-xcode.png" title=""><ul><li><p>修改版本号</p><p>将版本号修改为三位，如1.0.0</p><blockquote><p>如果你有很多的环境，那么多Scheme打包更加适合</p><p>第一步，添加一个Scheme</p><img src="/2020/08/05/code-push/code-push-ios-scheme-1.png" alt="code-push-ios-scheme-1.png" title=""><p>点击图中的➕号，选择<code>Duplicate &quot;Release&quot; Configurations</code> 即复制一个<code>Release</code>的配置，并修改成自己需要的名字，如<code>Staging</code></p><p>第二步，添加deployment key</p><img src="/2020/08/05/code-push/code-push-ios-sheme-2.png" alt="code-push-ios-sheme-2.png" title=""><p>点击图中的➕号，选择<code>Add User-Defined Setting</code> 命名为<code>CODEPUSH_KEY</code>并将plist文件中的deployment key修改为<code>$(CODEPUSH_KEY)</code></p><p>第三步，如果需要在手机上部署多个环境的app，修改app显示的名字、以及app图标，则分别需要修改. <code>Product Name</code>、<code>Asset Catalog Compiler</code> </p><p>第四步，打包的时候，需要首先选中目标Scheme之后再执行打包命令</p><img src="/2020/08/05/code-push/code-push-ios-scheme-3.png" alt="code-push-ios-scheme-3.png" title=""></blockquote></li></ul><h3 id="Android配置"><a href="#Android配置" class="headerlink" title="Android配置"></a>Android配置</h3><ul><li><p>添加deployment Key</p><p>可以直接在MainApplication.java中直接设置key，也可以写在build.gradle文件中</p><p>在app/build.gradle文件中的buildTypes中添加一个新的打包环境</p><p>并在strings.xml文件中添加一个<code>CodePushDeploymentKey</code>作为打包时候的code-push的key</p></li><li><p>修改版本号</p><p>将版本号修改为三位，如1.0.0</p></li></ul><h2 id="在Js代码中集成更新代码"><a href="#在Js代码中集成更新代码" class="headerlink" title="在Js代码中集成更新代码"></a>在Js代码中集成更新代码</h2><p>一般来说更新的代码会放在App的入口文件里，每当用户进入App的时候就会检查是否存在更新。code-push提供了多种参数，可以控制热更新的更新时机、是否弹出框提示等。这里仅展示最简单的热更新参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">import codePush from &apos;react-native-code-push&apos; </div><div class="line">  </div><div class="line">codePush.sync(</div><div class="line">  &#123; </div><div class="line">    updateDialog: &#123;</div><div class="line">      title: &apos;发现新版本&apos;,</div><div class="line">      mandatoryUpdateMessage: &apos;已有新版本可用&apos;,</div><div class="line">      mandatoryContinueButtonLabel: &apos;立即更新&apos;,</div><div class="line">      optionalUpdateMessage: &apos;已有新版本可用&apos;,</div><div class="line">      optionalIgnoreButtonLabel: &apos;取消&apos;,</div><div class="line">      optionalInstallButtonLabel: &apos;立即更新&apos;,</div><div class="line">      appendReleaseDescription: true,</div><div class="line">      descriptionPrefix: &apos;\n\n更新内容：\n&apos;,    </div><div class="line">    &#125;,</div><div class="line">    deploymentKey: Config.key,</div><div class="line">    installMode: codePush.InstallMode.IMMEDIATE</div><div class="line">  &#125;,</div><div class="line">  this.codePushStatusDidChange,</div><div class="line">  this.codePushDownloadDidProgress,    </div><div class="line">);</div><div class="line"></div><div class="line">codePushStatusDidChange = async (syncStatus: any) =&gt; &#123;</div><div class="line">    switch (syncStatus) &#123;</div><div class="line">      case codePush.SyncStatus.CHECKING_FOR_UPDATE:</div><div class="line">        // 0 - 正在查询CodePush服务器以进行更新。</div><div class="line">        console.info(&apos;[CodePush] Checking for update.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.AWAITING_USER_ACTION:</div><div class="line">        // 1 - 有可用的更新，并且向最终用户显示了一个确认对话框。（仅在updateDialog使用时适用）</div><div class="line">        console.info(&apos;[CodePush] Awaiting user action.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.DOWNLOADING_PACKAGE:</div><div class="line">        // 2 - 正在从CodePush服务器下载可用更新。</div><div class="line">        console.info(&apos;[CodePush] Downloading package.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.INSTALLING_UPDATE:</div><div class="line">        // 3 - 已下载一个可用的更新，并将其安装。</div><div class="line">        console.info(&apos;[CodePush] Installing update.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.UP_TO_DATE:</div><div class="line">        // 4 - 应用程序已配置的部署完全最新。</div><div class="line">        console.info(&apos;[CodePush] App is up to date.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.UPDATE_IGNORED:</div><div class="line">        // 5 该应用程序具有可选更新，最终用户选择忽略该更新。（仅在updateDialog使用时适用）</div><div class="line">        console.info(&apos;[CodePush] User cancelled the update.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.UPDATE_INSTALLED:</div><div class="line">        // 6 - 安装了一个可用的更新，它将根据 SyncOptions 中的 InstallMode指定在 syncStatusChangedCallback 函数返回后立即或在下次应用恢复/重新启动时立即运行。</div><div class="line">        console.info(&apos;[CodePush] Installed update.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.SYNC_IN_PROGRESS:</div><div class="line">        // 7 - 正在执行的 sync 操作</div><div class="line">        console.info(&apos;[CodePush] Sync already in progress.&apos;);</div><div class="line">        break;</div><div class="line">      case codePush.SyncStatus.UNKNOWN_ERROR:</div><div class="line">        // -1 - 同步操作遇到未知错误。</div><div class="line">        console.info(&apos;[CodePush] An unknown error occurred.&apos;);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">// code-push更新进度，可以配合页面添加下载进度条</div><div class="line">codePushDownloadDidProgress = (progress: any) =&gt; &#123;</div><div class="line">    const curPercent = progress.receivedBytes / progress.totalBytes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="使用CodePush进行热更新"><a href="#使用CodePush进行热更新" class="headerlink" title="使用CodePush进行热更新"></a>使用CodePush进行热更新</h2><p>首先将app打包好并安装在手机中</p><p>iOS打包首先要切换到目标Scheme后，再点击<code>Archive</code></p><p>Android则需要先打出bundle包，之后再执行相应的打包命令</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> bundle --platform android --entry-<span class="keyword">file</span> index.js --bundle-output .<span class="regexp">/android/</span>app<span class="regexp">/src/m</span>ain<span class="regexp">/assets/i</span>ndex.android.bundle --assets-dest .<span class="regexp">/android/</span>app<span class="regexp">/src/m</span>ain<span class="regexp">/res/</span> --dev <span class="keyword">false</span></div></pre></td></tr></table></figure><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>再次修改完js代码之后，执行以下命令即可将本次更新快速上传到服务器中</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ code-push release-react myapp-ios ios  <span class="params">--t</span> 1.0.0 <span class="params">--dev</span> <span class="literal">false</span> <span class="params">--d</span> Staging <span class="params">--des</span> <span class="string">"更新日志"</span> <span class="params">--m</span> <span class="literal">true</span></div><div class="line">$ code-push release-react myapp-android android  <span class="params">--t</span> 1.0.0 <span class="params">--dev</span> <span class="literal">false</span> <span class="params">--d</span> Staging <span class="params">--des</span> <span class="string">"更新日志"</span> <span class="params">--m</span> <span class="literal">true</span></div></pre></td></tr></table></figure><blockquote><p>–t代表本次热更新的app目标版本，即只有该版本下的app用户才能接收到本次热更新推送。如果一直没有更新原生代码，则不需要变动</p><p>–dev代表是否为开发模式</p><p>–d代表本次热更新的目标环境</p><p>–des代表着更新说明</p><p>–m代表是否强制更新</p></blockquote><p>上传成功之后，再次打开app即可看到热更新的推送，app将会根据预先写好的更新策略进行更新</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/jackson-zhangjiang/p/9805266.html" target="_blank" rel="external">React Native之code-push的热更新(ios android)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/08/05/code-push/code-push-logo.png&quot; alt=&quot;code-push-logo.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;App的热更新即，不通过应用商店的审核，直接下载远程的代码更新用户手机中的app。由于iOS应用审核周期长，审核规则复杂所以热更新对于iOS平台来说显得更为迫切，但在原生的iOS代码中实现起来比较复杂，有被拒绝的风险。而React Native由于其加载jsbundle的特点，实现热更新并不复杂。而采用Js热更新的React Native并没有受到WaxPatch、JSPatch等热修复框架被禁止的影响。&lt;/p&gt;
&lt;p&gt;React Native的热更新方案有很多种，比如微软的CodePush、或者如携程的jsbundle拆分方案等，但是基本原理都是一致的，就是远程加载jsbundle，下面记录实现热更新的几种方案&lt;/p&gt;
&lt;p&gt;CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。&lt;br&gt;CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Symbol、Proxy、Reflect学习摘要</title>
    <link href="https://mah93.github.io/2020/07/09/es6-summary/"/>
    <id>https://mah93.github.io/2020/07/09/es6-summary/</id>
    <published>2020-07-09T02:24:15.000Z</published>
    <updated>2020-07-09T02:29:35.535Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/07/09/es6-summary/es6-logo.jpg" alt="es6-logo.jpg" title=""><h2 id="Symbol概述"><a href="#Symbol概述" class="headerlink" title="Symbol概述"></a>Symbol概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p><code>Symbol</code>表示独一无二的值，它是 JavaScript 语言的<strong>第七种数据类型</strong></p><a id="more"></a> <blockquote><p>其他六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</p><p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，而不是对象</p></blockquote><h2 id="Symbol使用"><a href="#Symbol使用" class="headerlink" title="Symbol使用"></a>Symbol使用</h2><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line">s1 <span class="comment">// Symbol(foo)</span></div><div class="line">s2 <span class="comment">// Symbol(bar)</span></div><div class="line"></div><div class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></div><div class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></div></pre></td></tr></table></figure><p><code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没有参数的情况</span></div><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 有参数的情况</span></div><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div></pre></td></tr></table></figure><p><code>Symbol</code>类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> log = &#123;&#125;;</div><div class="line"></div><div class="line">log.levels = &#123;</div><div class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</div><div class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</div><div class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>);</div><div class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>);</div></pre></td></tr></table></figure><h3 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h3><p><code>Symbol.for()</code>它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// true</span></div></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><blockquote><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p></blockquote><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></div></pre></td></tr></table></figure><blockquote><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p></blockquote><h2 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h2><p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（<code>meta programming</code>），即对编程语言进行编程。</p><p><code>Proxy</code>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code>这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h2 id="Proxy使用"><a href="#Proxy使用" class="headerlink" title="Proxy使用"></a>Proxy使用</h2><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div></pre></td></tr></table></figure><p><code>Proxy</code> 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> handler = &#123;</div><div class="line">    get(target, propKey, receiver) &#123;</div><div class="line">      <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</div><div class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">        propKey = <span class="built_in">String</span>(target.length + index);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> target = [];</div><div class="line">  target.push(...elements);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</div><div class="line">arr[<span class="number">-1</span>] <span class="comment">// c</span></div></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pipe = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> funcStack = [];</div><div class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</div><div class="line">    get : <span class="function"><span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> fn(val);</div><div class="line">        &#125;,value);</div><div class="line">      &#125;</div><div class="line">      funcStack.push(<span class="built_in">window</span>[fnName]);</div><div class="line">      <span class="keyword">return</span> oproxy;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> oproxy;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</div><div class="line"><span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</div><div class="line"></div><div class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></div></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 新写法</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法</span></div><div class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 新写法</span></div><div class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Proxy</span>(target, &#123;</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target, name, value, receiver);</div><div class="line">    <span class="keyword">if</span> (success) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> success;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰 ECMAScript 6 入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/07/09/es6-summary/es6-logo.jpg&quot; alt=&quot;es6-logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Symbol概述&quot;&gt;&lt;a href=&quot;#Symbol概述&quot; class=&quot;headerlink&quot; title=&quot;Symbol概述&quot;&gt;&lt;/a&gt;Symbol概述&lt;/h2&gt;&lt;p&gt;ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入&lt;code&gt;Symbol&lt;/code&gt;的原因。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt;表示独一无二的值，它是 JavaScript 语言的&lt;strong&gt;第七种数据类型&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>realm使用记录</title>
    <link href="https://mah93.github.io/2020/03/03/realm-summary/"/>
    <id>https://mah93.github.io/2020/03/03/realm-summary/</id>
    <published>2020-03-03T09:06:08.000Z</published>
    <updated>2020-09-16T03:26:52.103Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/03/03/realm-summary/realm-logo.webp" alt="realm-logo.webp" title=""><h2 id="Realm简介"><a href="#Realm简介" class="headerlink" title="Realm简介"></a>Realm简介</h2><p>Realm是一个跨平台的移动数据库引擎，目前支持iOS、Android平台，同时支持Objective-C、Swift、Java、React Native、Xamarin等多种编程语言。Realm并不是对SQLite或者CoreData的简单封装, 是由核心数据引擎C++打造，是拥有独立的数据库存储引擎，可以方便、高效的完成数据库的各种操作。</p><p>官方文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Frealm.io" target="_blank" rel="external">https://realm.io</a> </p><p>GitHub：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frealm%2Frealm-cocoa" target="_blank" rel="external">https://github.com/realm/realm-cocoa</a></p><p>Realm Studio: <a href="https://realm.io/cn/products/realm-studio" target="_blank" rel="external">https://realm.io/cn/products/realm-studio</a></p><a id="more"></a> <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save realm</span></div></pre></td></tr></table></figure><p>react-native版本大于等于0.60</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ios <span class="meta">&amp; pod install</span></div></pre></td></tr></table></figure><p>react-native版本小于0.60</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> link realm</div></pre></td></tr></table></figure><blockquote><p>安卓端可能使用 <em>link</em> 无效，这时可以进行以下步骤：</p><p>在 android/setting.gradle 内添加:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">include</span> ':realm'</div><div class="line">&gt; project(':realm').projectDir = <span class="keyword">new</span> <span class="constructor">File(<span class="params">rootProject</span>.<span class="params">projectDir</span>, '..<span class="operator">/</span><span class="params">node_modules</span><span class="operator">/</span><span class="params">realm</span><span class="operator">/</span><span class="params">android</span>')</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>在android/app/build.gradle增加依赖库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> // When using Android Gradle plugin 3.0 or higher</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> dependencies &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   implementation project(<span class="string">':realm'</span>)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> // When using Android Gradle plugin lower than 3.0</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> dependencies &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   compile project(<span class="string">':realm'</span>)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>在MainApplication.java中导入并且链接package</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">import</span> io.realm.react.<span class="type">RealmReactPackage</span>; <span class="comment">// add this </span></div><div class="line">&gt; </div><div class="line">&gt; <span class="keyword">import</span> public <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="title">implements</span> <span class="title">ReactApplication</span> </span>&#123;</div><div class="line">&gt;     <span class="meta">@Override</span></div><div class="line">&gt;     <span class="keyword">protected</span> <span class="type">List</span>&lt;<span class="type">ReactPackage</span>&gt; getPackages() &#123;</div><div class="line">&gt;         <span class="keyword">return</span> <span class="type">Arrays</span>.&lt;<span class="type">ReactPackage</span>&gt;asList(</div><div class="line">&gt;             <span class="keyword">new</span> <span class="type">MainReactPackage</span>(),</div><div class="line">&gt;             <span class="keyword">new</span> <span class="type">RealmReactPackage</span>() <span class="comment">// add this line</span></div><div class="line">&gt;         );</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="建立model"><a href="#建立model" class="headerlink" title="建立model"></a>建立model</h2><p>通过schema定义的模型会在realm初始化的时候加入realm数据库中，每个schema都有一个name字段定义的名字、primaryKey为主键以及其他属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定一个car</span></div><div class="line"><span class="keyword">const</span> CarSchema = &#123;</div><div class="line">  name: <span class="string">'Car'</span>,</div><div class="line">  properties: &#123;</div><div class="line">    <span class="built_in">make</span>:  <span class="string">'string'</span>,  <span class="comment">// 字符类型</span></div><div class="line">    model: <span class="string">'string'</span>,  <span class="comment">// 字符类型</span></div><div class="line">    miles: &#123;<span class="keyword">type</span>: <span class="string">'int'</span>, <span class="keyword">default</span>: <span class="number">0</span>&#125;, <span class="comment">// 数字类型，并且初始值为0</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><p>Realm支持的基本类型有：<code>bool</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>string</code>, <code>data</code>, and <code>date</code></p><ul><li><code>bool</code> 对应JavaScript中的<code>boolean</code></li><li><code>int</code>, <code>float</code>,  <code>double</code> 对应JavaScript中的 <code>number</code> </li><li><code>string</code> 对应JavaScript中的 <code>string</code></li><li><code>data</code> 对应JavaScript中的<code>ArrayBuffer</code></li><li><code>date</code> 对应JavaScript中的 <code>Date</code></li></ul><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>通过设置一个<code>string</code>或者<code>int</code>类型的值作为model的主键</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const BookSchema = &#123;</div><div class="line">  name: <span class="string">'Book'</span>,</div><div class="line">  primaryKey: <span class="string">'id'</span>,</div><div class="line">  properties: &#123;</div><div class="line">    id:    <span class="string">'int'</span>,    // <span class="meta">primary</span> <span class="meta">key</span></div><div class="line">    <span class="meta">title</span>: <span class="string">'string'</span>,</div><div class="line">    price: <span class="string">'float'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>Realm的基本类型是非可选的，并且不可以存储<code>null</code>以及<code>undefined</code>。但是可以在属性定义中添加可选的指示符<code>?</code>来使属性成为可选属性。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const PersonSchema = &#123;</div><div class="line">  name: 'Person',</div><div class="line">  properties: &#123;</div><div class="line">    realName:    '<span class="keyword">string</span>', // required <span class="keyword">property</span><span class="title"></span></div><div class="line">    displayName: '<span class="keyword">string</span>?', // optional <span class="keyword">property</span><span class="title"></span></div><div class="line">    birthday:    &#123;<span class="keyword">type</span>: '<span class="keyword">date</span>', optional: <span class="literal">true</span>&#125;, // optional <span class="keyword">property</span><span class="title"></span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h3><p>通过<code>default</code>字段为属性添加一个默认值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const <span class="type">CarSchema</span> = &#123;</div><div class="line">  name: <span class="symbol">'Ca</span>r',</div><div class="line">  properties: &#123;</div><div class="line">    make:  &#123;<span class="class"><span class="keyword">type</span></span>: <span class="symbol">'strin</span>g'&#125;,</div><div class="line">    model: &#123;<span class="class"><span class="keyword">type</span></span>: <span class="symbol">'strin</span>g'&#125;,</div><div class="line">    drive: &#123;<span class="class"><span class="keyword">type</span></span>: <span class="symbol">'strin</span>g', <span class="keyword">default</span>: <span class="symbol">'fw</span>d'&#125;,</div><div class="line">    miles: &#123;<span class="class"><span class="keyword">type</span></span>: <span class="symbol">'in</span>t',    <span class="keyword">default</span>: <span class="number">0</span>&#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>除了存储单个值之外，还可以将属性声明为任何受支持的基本类型的列表。 这是通过在类型名称后附加<code>[]</code>来完成</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const PersonSchema = &#123;</div><div class="line">  <span class="built_in">name</span>: <span class="string">'Person'</span>,</div><div class="line">  properties: &#123;</div><div class="line">    <span class="built_in">name</span>: <span class="string">'string'</span>,</div><div class="line">    testScores: <span class="string">'double?[]'</span>  <span class="comment">// 一个存储double类型的数组</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const PersonSchema = &#123;</div><div class="line">  <span class="built_in">name</span>: <span class="string">'Person'</span>,</div><div class="line">  properties: &#123;</div><div class="line">    <span class="built_in">name</span>:     <span class="string">'string'</span>,</div><div class="line">    birthday: <span class="string">'date'</span>,</div><div class="line">    cars:     <span class="string">'Car[]'</span>  <span class="comment">// 一个存储Car对象的数组</span></div><div class="line">    picture:  <span class="string">'data?'</span>, <span class="comment">// optional property</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="初始化Realm"><a href="#初始化Realm" class="headerlink" title="初始化Realm"></a>初始化Realm</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Realm.open(&#123;schema: [Car, Person]&#125;)</div><div class="line"><span class="keyword">  .then</span>(realm =&gt; &#123;</div><div class="line">    // ...use the realm<span class="built_in"> instance </span>here</div><div class="line">  &#125;)</div><div class="line"><span class="keyword">  .catch</span>(error =&gt; &#123;</div><div class="line">    // Handle the error here<span class="built_in"> if </span>something went wrong</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>通过realm中的<code>open</code>方法以及定义好的models，即可快速的创建并打开数据库。</p><p>当然也可以通过创建realm实例打开</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const realm = <span class="keyword">new</span> <span class="constructor">Realm(&#123;<span class="params">schema</span>: [PersonSchema]&#125;)</span>;</div></pre></td></tr></table></figure><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>对域中对象的更改、创建、更新和删除，必须在<code>write</code>事务块中进行。<br>需要注意：写入事务具有不可忽略的开销，应该尽量减少代码中写入块的数量。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">try</span> &#123;</div><div class="line">  <span class="selector-tag">realm</span><span class="selector-class">.write</span>(() =&gt; &#123;</div><div class="line">    <span class="selector-tag">realm</span><span class="selector-class">.create</span>(<span class="string">"Hello"</span>, &#123;</div><div class="line">      <span class="attribute">uid</span>: <span class="string">"a371d56d7b6f77ba31f71d22"</span>,</div><div class="line">      <span class="attribute">name</span>: <span class="string">"名字1"</span>,</div><div class="line">      <span class="attribute">phone</span>: <span class="string">"137xxxxxxxx"</span></div><div class="line">    &#125;);</div><div class="line">    <span class="selector-tag">realm</span><span class="selector-class">.create</span>(<span class="string">"Hello"</span>, &#123;</div><div class="line">      <span class="attribute">uid</span>: <span class="string">"a371d56d7b6f77ba31f71d22"</span>,</div><div class="line">      <span class="attribute">name</span>: <span class="string">"名字1"</span>,</div><div class="line">      <span class="attribute">phone</span>: <span class="string">"137xxxxxxxx"</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line"><span class="selector-tag">catch</span>(e) &#123;</div><div class="line">  <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="string">"Error on creation"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>通过<code>delete</code>方法删除，必须在<code>write</code>事务块中进行。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">realm.write(() =&gt; &#123;</div><div class="line">  // <span class="keyword">Create</span> a book <span class="keyword">object</span></div><div class="line">  <span class="keyword">let</span> book = <span class="keyword">realm</span>.<span class="keyword">create</span>(<span class="string">'Book'</span>, &#123;id: <span class="number">1</span>, <span class="built_in">title</span>: <span class="string">'Recipes'</span>, price: <span class="number">35</span>&#125;);</div><div class="line"></div><div class="line">  // <span class="keyword">Delete</span> the book</div><div class="line">  <span class="keyword">realm</span>.<span class="keyword">delete</span>(book);</div><div class="line"></div><div class="line">  // <span class="keyword">Delete</span> multiple books <span class="keyword">by</span> passing <span class="keyword">in</span> a <span class="symbol">`Results`</span>, <span class="symbol">`List`</span>,</div><div class="line">  // <span class="keyword">or</span> JavaScript <span class="symbol">`Array`</span></div><div class="line">  <span class="keyword">let</span> allBooks = <span class="keyword">realm</span>.objects(<span class="string">'Book'</span>);</div><div class="line">  realm.delete(allBooks); // Deletes all books</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>在创建方法后面添加参数<code>true</code>即可</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  realm.create(<span class="string">"Hello"</span>, &#123;</div><div class="line">    uid: <span class="string">"a371d56d7b6f77ba31f71d22"</span>,</div><div class="line">    name: <span class="string">"名字1"</span>,</div><div class="line">    phone: <span class="string">"137xxxxxxxx"</span></div><div class="line">  &#125;, <span class="literal">true</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>通过model的名称查找数据</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dogs = realm.objects(<span class="string">'Dog'</span>); <span class="comment">// retrieves all Dogs from the Realm</span></div></pre></td></tr></table></figure><p>返回<code>Dog</code>中的所有数据，或者通过<code>filtered</code>查找指定数据</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const tanDogs = dogs.filtered(<span class="symbol">'color</span> = <span class="string">"tan"</span> <span class="keyword">AND</span> name BEGINSWITH <span class="string">"B"</span>');</div></pre></td></tr></table></figure><h2 id="Realm-Studio"><a href="#Realm-Studio" class="headerlink" title="Realm Studio"></a>Realm Studio</h2><p>Realm Studio是Realm数据库的可视化工具，通过<a href="https://realm.io/products/realm-studio/#download-studio" target="_blank" rel="external">Realm Studio</a>下载，支持<code>Windows</code>、<code>Linux</code>、<code>Mac OS</code>系统，下载打开之后</p><img src="/2020/03/03/realm-summary/realm-studio-logo.webp" alt="realm-studio-logo.webp" title=""><p>点击<code>Open Realm file</code> 选中需要打开的数据库即可，是以<code>realm</code>为后缀的文件</p><h3 id="找到realm文件"><a href="#找到realm文件" class="headerlink" title="找到realm文件"></a>找到realm文件</h3><p>如果是在iOS模拟器上，那么可以到以下路径查找</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Users/你的名字/Library/Developer/CoreSimulator/Devices/<span class="number">2</span>AAE2917<span class="number">-8519</span><span class="number">-4024</span>-BAE7<span class="number">-3</span>A59F124691E/data/Containers/Data/Application/<span class="number">0</span>EE00136<span class="number">-357</span>D<span class="number">-46</span>F8-B709<span class="number">-2</span>BAA1DDF8909/Documents</div></pre></td></tr></table></figure><p>如果是在iOS真机上，可以在Xcode中的<code>Devices and Simulator</code>查找</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>Realm安装不上</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">React Native <span class="number">0.31</span><span class="number">.0</span> <span class="keyword">and</span> later <span class="keyword">is</span> supported.</div><div class="line">Node version <span class="number">8.3</span><span class="number">.0</span> (<span class="keyword">and</span> later versions <span class="keyword">in</span> <span class="number">8.</span>x) <span class="keyword">and</span> <span class="number">10.</span>x are supported.</div><div class="line"></div><div class="line">仅支持React Native <span class="number">0.31</span><span class="number">.0</span>及以上</div><div class="line">仅支持node <span class="number">8.3</span><span class="number">.0</span>及以上或者<span class="number">10.</span>x</div></pre></td></tr></table></figure><ul><li>realm-sync-cocoa下载失败</li></ul><img src="/2020/03/03/realm-summary/realm-err.webp" alt="realm-err.webp" title=""><blockquote><p>首次运行时，如果出现长时间卡在编辑阶段，打开Xcode发现一直在下载realm-sync-cocoa-4.9.2.tar.gz<br>该文件大概有100M以上，翻墙效果依旧不明显</p></blockquote><ol><li>手动下载realm-sync-cocoa-4.9.2.tar.gz</li><li>打开/node_modules/realm/scripts/download-realm.js文件，并找到以下代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// return crypto.randomBytes(20).toString('hex');</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'realm'</span>;  </div><div class="line">&#125;</div><div class="line"><span class="comment">// 该方法是返回一个20位随机字符串作为下载的文件夹名，每次启动下载realm-sync-cocoa任务的时候，都会先创建一个文件夹，并将下载到该文件夹中，这里将文件夹名称改成固定名称，目的是把手动下载好的文件直接放入。</span></div></pre></td></tr></table></figure><p>修改之后重新编译一下，就会生成一个<code>realm</code>文件夹</p><ol><li>在命令行输入<code>getconf DARWIN_USER_TEMP_DIR</code>获取下载缓存路径，并把手动下载好的文件，放入realm中</li><li>清空项目并且编译即可成功</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.im/post/5c11c22f6fb9a04a03791555" target="_blank" rel="external">移动数据库 Realm 在 React-Native 的使用详解</a></li><li><a href="https://realm.io/docs/javascript/latest/#realms" target="_blank" rel="external">realm.io</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/03/03/realm-summary/realm-logo.webp&quot; alt=&quot;realm-logo.webp&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Realm简介&quot;&gt;&lt;a href=&quot;#Realm简介&quot; class=&quot;headerlink&quot; title=&quot;Realm简介&quot;&gt;&lt;/a&gt;Realm简介&lt;/h2&gt;&lt;p&gt;Realm是一个跨平台的移动数据库引擎，目前支持iOS、Android平台，同时支持Objective-C、Swift、Java、React Native、Xamarin等多种编程语言。Realm并不是对SQLite或者CoreData的简单封装, 是由核心数据引擎C++打造，是拥有独立的数据库存储引擎，可以方便、高效的完成数据库的各种操作。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Frealm.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://realm.io&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frealm%2Frealm-cocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/realm/realm-cocoa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Realm Studio: &lt;a href=&quot;https://realm.io/cn/products/realm-studio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://realm.io/cn/products/realm-studio&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>啥是docker</title>
    <link href="https://mah93.github.io/2020/01/08/what-is-docker/"/>
    <id>https://mah93.github.io/2020/01/08/what-is-docker/</id>
    <published>2020-01-08T09:28:05.000Z</published>
    <updated>2020-01-08T09:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/08/what-is-docker/docker_logo.png" alt="docker_logo.png" title=""><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><a id="more"></a> <h2 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="安装Docker-Desktop"><a href="#安装Docker-Desktop" class="headerlink" title="安装Docker Desktop"></a>安装Docker Desktop</h2><p>在docker官网上注册之后，下载desktop客户端</p><img src="/2020/01/08/what-is-docker/docker_desktop.png" alt="docker_desktop.png" title=""><p>选择平台之后双击安装即可，安装之后在命令行中输入docker得到相应输出后，即安装完成</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker search</td><td>查找所以可用软件包</td></tr><tr><td>docker pull</td><td>获取软件包</td></tr><tr><td>docker images</td><td>查看本地镜像</td></tr><tr><td>docker ps -a</td><td>查看正在运行的容器</td></tr><tr><td>docker rm</td><td>删除容器</td></tr><tr><td>docker run</td><td>运行容器</td></tr><tr><td>docker rmi</td><td>删除镜像</td></tr></tbody></table><h2 id="例子：安装redis"><a href="#例子：安装redis" class="headerlink" title="例子：安装redis"></a>例子：安装redis</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> docker search redis</div><div class="line"><span class="symbol">$</span> docker pull redis</div><div class="line"><span class="symbol">$</span> docker run -p <span class="number">6379</span>:<span class="number">6379</span> -v <span class="symbol">$</span>PWD/data:/data  -d redis:latest redis-server --appendonly <span class="keyword">yes</span></div><div class="line"><span class="symbol">$</span> docker run -it redis:latest redis-cli -h <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span></div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="[http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html](http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/08/what-is-docker/docker_logo.png&quot; alt=&quot;docker_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Docker是什么&quot;&gt;&lt;a href=&quot;#Docker是什么&quot; class=&quot;headerlink&quot; title=&quot;Docker是什么&quot;&gt;&lt;/a&gt;Docker是什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。&lt;/strong&gt;它是目前最流行的 Linux 容器解决方案。&lt;/p&gt;
&lt;p&gt;Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。&lt;/p&gt;
&lt;p&gt;总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://mah93.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://mah93.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记</title>
    <link href="https://mah93.github.io/2019/12/30/iOS-learn/"/>
    <id>https://mah93.github.io/2019/12/30/iOS-learn/</id>
    <published>2019-12-30T09:28:57.000Z</published>
    <updated>2020-07-09T02:28:29.192Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/12/30/iOS-learn/iOS-intro.png" alt="iOS-intro.png" title=""><p>以下笔记是边看视频课程边记录下来的，供以后自己查阅复习使用</p><h2 id="Runtime学习笔记1"><a href="#Runtime学习笔记1" class="headerlink" title="Runtime学习笔记1"></a>Runtime学习笔记1</h2><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>在OC中，调用方法其实是给对象发送消息</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[Person <span class="keyword">new</span>] <span class="string">sendMessage:</span>@<span class="string">"gelo"</span>];</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">objc_msgSend([Person <span class="keyword">new</span>], <span class="meta">@selector</span>(<span class="string">sendMessage:</span>), <span class="string">"gelo"</span>);</div></pre></td></tr></table></figure><p>通过对象的isa指针找到class，如果有方法的话，直接调用。没有找到的话，通过继承树查找，进入消息转发机制</p><a id="more"></a> <img src="/2019/12/30/iOS-learn/runtime-forwardflow.png" alt="runtime-forwardflow.png" title=""><p>动态方法解析，动态添加方法实现  </p><p>​    resolveInstanceMethod</p><p>快速转发，当前的类或者继承树没有该方法的实现，在更加广的范围寻找</p><p>​    forwardingTargetForSelector</p><p>慢速转发</p><p>​    methodSignatureForSelector</p><p>​    forwardInvocation</p><p>doesNotRecognizeSelector:</p><h3 id="方法交换-Method-Swizzling"><a href="#方法交换-Method-Swizzling" class="headerlink" title="方法交换 Method Swizzling"></a>方法交换 Method Swizzling</h3><p>用自己写的方法替换系统方法，通过class_getInstanceMethod方法获取，通过method_exchangeImplementations交换两个函数</p><h3 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h3><p>遍历字典获取key和value</p><p>key作为属性名，value作为属性值</p><p>通过objc_msgSend发送set方法</p><h3 id="模型转字典"><a href="#模型转字典" class="headerlink" title="模型转字典"></a>模型转字典</h3><p>字典的key通过模型的属性列表获取</p><p>字典的value通过调用get方法获取</p><h3 id="实现KVO"><a href="#实现KVO" class="headerlink" title="实现KVO"></a>实现KVO</h3><p>KVO是基于runtime的</p><p>A监听B 系统会为B创建一个子类 </p><p>B的isa指针指向B的子类</p><p>在子类中重新set方法</p><h2 id="KVO底层实现"><a href="#KVO底层实现" class="headerlink" title="KVO底层实现"></a>KVO底层实现</h2><h3 id="KVO的基础使用"><a href="#KVO的基础使用" class="headerlink" title="KVO的基础使用"></a>KVO的基础使用</h3><p>观察某一个对象的某个属性</p><p>options参数可以观察一下几个值</p><p>new  返回变化后的新值</p><p>old    返回变化前的旧值</p><p>init    注册的时候就会发一次通知，改变后的值的时候也会发送</p><p>prior  新值和旧值都会返回</p><p>KVO默认是自动模式，每次修改值都会发送通知</p><p>手动发送通知的时候，对象调用willchangeValueForKey，改变之后调用didchangeValueForKey</p><p>监听属性下面的属性值，只需要在监听path中通过点监听：”dog.age”（属性依赖）</p><p>KVO监听的是set方法。比如监听不到数组的add方法</p><p>要是需要监听容器方法，需要结合KVC</p><p>需要监听对象下多个属性，只需要监听对象本身，并实现keyPat<em>*</em>ForKey。返回需要的真正监听的内部属性的NSSet</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>属性是对成员变量和set、get方法的封装</p><p>KVO观察的是set方法（设置成员变量之后，外部通过person-&gt;name方法修改，KVO监听不到）通过runtime创建一个观察者的子类（NSKVONotifying_Person）重写set方法。修改指针到子类、在重写的方法里面调用willchangeValueForKey、superSetName、didchangeValueForKey。</p><p>在创建的子类中，没有父类的set方法！需要重写set方法</p><p>OC的方法中包含SEL（方法编号）、IMP（方法实现）一一对应。调用方法的时候发送的是SEL</p><p>OC的方法调用里面有两个默认参数：id self，SEL _cmd。由于sendMsg传递了该参数（调用者以及SEL）</p><h3 id="监听容器类（NSArray、NSDic）"><a href="#监听容器类（NSArray、NSDic）" class="headerlink" title="监听容器类（NSArray、NSDic）"></a>监听容器类（NSArray、NSDic）</h3><p>通过KVO观察容器属性的变化，利用KVC</p><p>通过KVC的mutableArray**ForKey返回一个容器对象，向该对象添加元素可以实现KVO。内部新建子类、重写add方法。</p><p>KVO返回的NSDic中，kind类型</p><p>观察set方法 返回1</p><p>观察插入方法 返回2</p><p>观察删除方法 返回3</p><p>观察替换方法 返回4</p><h3 id="数组中count"><a href="#数组中count" class="headerlink" title="数组中count"></a>数组中count</h3><p>使用KVO中监听不到数组中的count、使用KVC同样取不到[array valueForKey:@”count”]</p><p>count是集合运算符，KVC需要用@”@count”取值。</p><p>count是只读属性</p><h2 id="数组（NSMutableArray）"><a href="#数组（NSMutableArray）" class="headerlink" title="数组（NSMutableArray）"></a>数组（NSMutableArray）</h2><p>关于数组的容量，容量不够用的时候，会成倍的增加</p><p>对象本身是指针，指向该对象的结构体</p><p>x/100xb arr 打印arr 100个内存地址</p><p>找到count的内存地址，修改内存地址的值，进而可以修改count的值</p><h2 id="Runtime学习笔记2"><a href="#Runtime学习笔记2" class="headerlink" title="Runtime学习笔记2"></a>Runtime学习笔记2</h2><h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><p>OC代码会转化为C语言执行，使用runtime的时候，需要关闭代码的严格检测</p><p>调用函数的方法：</p><p>[p eat]</p><p>[p performSelector: SEL]</p><p>objc_msgSend()</p><p>使用runtime创建对象：<br>类名.class即为对象  Person.class  ==   objc_getClass(“Person”)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在目录下执行</span></div><div class="line">clang --rewrite-objc main.m</div><div class="line"><span class="comment">// 手动编译OC代码生成cpp文件</span></div></pre></td></tr></table></figure><h3 id="归档-解档"><a href="#归档-解档" class="headerlink" title="归档/解档"></a>归档/解档</h3><p>归档和解档对象，需要遵循NSCoding的协议，并且实现协议方法</p><p>KVC可以使用id类型为属性赋值</p><p>Ivar：成员变量</p><p>Method：成员方法</p><p><strong>C语言 基本数据类型的指针  函数内部是为了修改外部的值</strong></p><p>class_copyIvarList获取所有属性数量</p><p>关键字copy、new、creat代表着会在堆区域（malloc）开辟空间</p><p>方法执行完毕—&gt;方法调用栈平衡—&gt;内部变量指针出栈—&gt;但是指针指向的堆区的值还在—&gt;内存泄漏</p><p>在OC中使用C的代码，要手动释放指针，防止内存溢出</p><h3 id="OC方法定位以及替换"><a href="#OC方法定位以及替换" class="headerlink" title="OC方法定位以及替换"></a>OC方法定位以及替换</h3><p>OC的方法表：返回值类型+参数类型一样  编号就一样</p><p>​                类</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>用HOOK！钩住系统方法，在调用之前修改方法的调用</p><p>在分类中的load方法（由于预加载，比main更早执行）中交换IMP</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="comment">// 获取替换后的类方法</span></div><div class="line">    Method otherMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNameNextWith:));</div><div class="line">    <span class="comment">// 获取替换前的类方法</span></div><div class="line">    Method method = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</div><div class="line">    <span class="comment">// 然后交换类方法</span></div><div class="line">    method_exchangeImplementations(otherMethod, method);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">UIImage</span> *)imageNameNextWith:(<span class="built_in">NSString</span> *)nameString &#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</div><div class="line">    image = [<span class="built_in">UIImage</span> imageNameNextWith:[nameString stringByAppendingString:<span class="string">@"tupian.jpg"</span>]];</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于在imageNameNextWith中调用自身，并不会引起循环引用。</p><p>交换之前</p><p>SEL（系统方法：ImageNamed） —————&gt;   IMP（系统方法：ImageNamed的实现地址指针）</p><p>SEL（自己的方法：ImageNamedNextWith） —————&gt;   IMP（自己的方法：ImageNamedNextWith的实现地址指针）</p><p>交换之后</p><p>SEL（系统方法：ImageNamed） —————&gt;   IMP（自己的方法：ImageNamedNextWith的实现地址指针）</p><p>SEL（自己的方法：ImageNamedNextWith） —————&gt;   IMP（系统方法：ImageNamed的实现地址指针）</p><p>交换之后，每当再次调用imageNameNextWith方法的时候，<strong>实际上执行的是系统方法ImageNamed指向的方法实现</strong>，所以不会引起循环调用。</p><p>OC对象本质上是指针占用8个字节</p><p><strong>OC方法调用顺序：消息发送——&gt;SEL——&gt;IMP——&gt;代码——&gt;函数——&gt;汇编</strong></p><h2 id="函数响应式编程RAC"><a href="#函数响应式编程RAC" class="headerlink" title="函数响应式编程RAC"></a>函数响应式编程RAC</h2><h3 id="RAC的代理"><a href="#RAC的代理" class="headerlink" title="RAC的代理"></a>RAC的代理</h3><p>RAC里面内部实现类似于通知</p><ol><li>创建信号 提供外界订阅</li></ol><p>创建了一个容量为1的可变数组_subscribers</p><p>支持多个订阅者订阅该信号</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RACSubject *subject = [RACSubject subject]<span class="comment">;</span></div></pre></td></tr></table></figure><ol><li>订阅信号（注册通知）</li></ol><p>创建订阅者对象</p><p>将Block放到订阅者对象中</p><p>将订阅者对象放入_subscribers里面</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[subject subscribeNext:^(<span class="name"><span class="builtin-name">id</span></span>)&#123;</div><div class="line">  // 函数式编程，免除了遵循协议，引用方法的步骤</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><ol><li>发送信号（发起通知）</li></ol><p>遍历_subscribers取出中的订阅者对象</p><p>执行订阅者对象中的Block</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[subject sentNext:@"hahha]</span><span class="comment">;</span></div></pre></td></tr></table></figure><p>RAC中可以使用Selector通过方法名称创建信号，直接订阅</p><h3 id="RAC中的KVO"><a href="#RAC中的KVO" class="headerlink" title="RAC中的KVO"></a>RAC中的KVO</h3><p>RAC可以直接用Block回调，在观察多个属性的时候，可以避免在回调函数中判断。</p><p>RAC同样不能观察到数组的count</p><h3 id="RAC监听事件"><a href="#RAC监听事件" class="headerlink" title="RAC监听事件"></a>RAC监听事件</h3><p>将按钮的点击事件包装成信号，订阅</p><h3 id="RAC中的Timer"><a href="#RAC中的Timer" class="headerlink" title="RAC中的Timer"></a>RAC中的Timer</h3><p>使用NSTimer的时候，创建完之后需要添加到NSRunLoop中</p><p>在NSTread子线程中需要手动启动NSRunLoop</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] run]</div></pre></td></tr></table></figure><p>RAC中通过信号创建子线程并发Timer，底层使用GCD创建</p><h3 id="RAC中的宏定义"><a href="#RAC中的宏定义" class="headerlink" title="RAC中的宏定义"></a>RAC中的宏定义</h3><p>当输入框内容发生变化，相应更新到_label上</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="constructor">RAC(<span class="params">_label</span>, <span class="params">text</span>)</span> = <span class="module-access"><span class="module"><span class="identifier">_textField</span>.</span></span>rac_textSignal;</div></pre></td></tr></table></figure><p>只要对象的属性发生改变，就会产生信号</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">RACObserver</span>(<span class="params">self, name</span>)</span> sub....</div></pre></td></tr></table></figure><p>关于Block中的循环引用，但是在特殊情况下是允许循环应用的出现</p><p>NSURLSession中的delegate是强引用，目的是发送请求的时候只需要一个对象。是单例</p><p>使用强引用，并不会销毁，导致内存泄漏</p><h2 id="Socket探索"><a href="#Socket探索" class="headerlink" title="Socket探索"></a>Socket探索</h2><p>IP地址可以在网络上定位到一台终端设备</p><p>端口号可以访问到设备上的服务：比如80端口为Apache端口服务</p><p>网络的七层协议从上至下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p>标准帧格式数据包</p><p>socket处于传输层、IP/TCP协议在网络层</p><h3 id="TCP与UDP协议的区别"><a href="#TCP与UDP协议的区别" class="headerlink" title="TCP与UDP协议的区别"></a>TCP与UDP协议的区别</h3><p>UDP（用户数据报协议）短信</p><p>​    只管发送，不确认对方是否收到</p><p>​    将数据及源和目的封装成数据包中，不需要建立连接</p><p>​    每个数据报大小限制在64k</p><p>​    因为无需连接，因此是不可靠协议</p><p>​    不需要连接，速度快</p><p>TCP（传输控制协议）电话</p><p>​    建立连接，形成传输数据通道</p><p>​    在连接中进行大数据传输（数据大小不受限制）</p><p>​    通过三次握手连接，是可靠的协议，安全送达</p><p>​    必须建立连接，效率稍低</p><p>直播推流、游戏是UDP协议，下载的过程是TCP协议</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>类比插座，socket需要两端的IP+端口号建立连接</p><ol><li>创建socket</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> domain：  协议域 <span class="type">AF_INET</span> = <span class="type">IPV4</span>   <span class="type">IPV6</span></div><div class="line"> <span class="class"><span class="keyword">type</span>：    <span class="type">Socket</span>类型 <span class="type">SOCK_STREAM</span>(<span class="type">TCP</span>)/<span class="type">SOCK_DGRAM</span>(<span class="type">UDP</span>)</span></div><div class="line"> protocol： <span class="type">IPPROTO_TCP</span>, 传入<span class="number">0</span>， 会自动根据第二个值选择合适的协议</div><div class="line">*/</div><div class="line"><span class="title">int</span> clientSocket = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure><ol><li>连接服务器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">服务器IP地址结构体指针</span></div><div class="line"><span class="comment">结构体长度</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></div><div class="line">serverAddr.sin_family = AF_INET;<span class="comment">//IPV4</span></div><div class="line">serverAddr.sin_port = htons(<span class="number">80</span>);<span class="comment">//端口号</span></div><div class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);<span class="comment">//IP地址</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> connectResult = connect();</div><div class="line"><span class="comment">// 返回0代表连接成功</span></div></pre></td></tr></table></figure><p>netcat工具，用于监听本地端口</p><ol><li>发送数据</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">发送内容地址</span></div><div class="line"><span class="comment">发送内容长度</span></div><div class="line"><span class="comment">发送方式标志，一般为0</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">返回值</span></div><div class="line"><span class="comment">发送成功之后返回发送字节长度，失败返回error</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="selector-tag">send</span>();</div></pre></td></tr></table></figure><ol><li>读取数据</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">接受内容缓冲区域地址</span></div><div class="line"><span class="comment">接受内容缓冲区长度</span></div><div class="line"><span class="comment">接受方式标志，0表示阻塞，必须等待服务器返回数据</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">返回值</span></div><div class="line"><span class="comment">接受成功之后返回发送字节长度，失败返回error</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="built_in">uint</span>8_t buffer[<span class="number">1024</span>];</div><div class="line">recv();</div><div class="line"></div><div class="line">通过data数据读取二进制数组，解析返回字节流</div></pre></td></tr></table></figure><ol><li>关闭socket</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close()<span class="comment">;</span></div></pre></td></tr></table></figure><h2 id="HTTP访问"><a href="#HTTP访问" class="headerlink" title="HTTP访问"></a>HTTP访问</h2><p>通过向百度的IP地址，发送”GET HTTP/1.1\n  Host: www.baidu.com\n\n”可以接收到百度服务器返回的百度首页数据。</p><p>手写了一个HTTP协议</p><blockquote><p> Connection被废弃的原因</p><p> 异步下载，无法回调数据，因为Runloop默认在子线程不开启</p><p>线程管理</p><p>线程中有<strong>任务</strong>才有可能不被释放</p></blockquote><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>https本身不会对客户端进行验证</p><p>加密算法：RSA</p><p>RSA：公钥和私钥</p><p>明文+公钥 = 密文</p><p>密文+私钥 = 明文</p><p>第一次请求HTTPS服务器，客户端安装证书（下载公钥并保存），通讯时通过该公钥加密传输</p><p>登录校验时随机盐可以提高安全性</p><h2 id="加密详解"><a href="#加密详解" class="headerlink" title="加密详解"></a>加密详解</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>base64是编码方式，不属于加密算法</p><p>可以将任意的二进制数据进行编码 编码成为65中字符的文本文件</p><p>0-9，a-z，A-Z，+ / =</p><p>对称加密：</p><p>DES</p><p>3DES</p><p>AES（高级密码标准）</p><p>数学算法：</p><p>哈希函数MD5</p><h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>free()以及CFRelease()的区别</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>setup        初始化</p><p>tearDown  销毁</p><p>所有的测试用例必须以test开头</p><p>given</p><p>when</p><p>then</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="MVC解耦"><a href="#MVC解耦" class="headerlink" title="MVC解耦"></a>MVC解耦</h3><p>vc代码过于沉重</p><p>代码耦合性过高    UI与Model的通讯</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>面向协议编程—代理</p><p>@synchronized(self)多线程锁</p><p>通过代理使UI与Model通讯</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>双向绑定：数据和UI的绑定，即修改一处另一处随之修改<br>异步的一般处理：代理、通知、匿名函数（Block）</p><p>从数据   —–&gt;   UI 通过Block进行通讯<br>从UI  ——-&gt;  数据  通过KVO监听通讯</p><p>NSMutableArray是线程不安全的，在处理里面的数据的时候需要加锁</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>进程</p><p>线程</p><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- alloc init</div><div class="line">+ detacNewThread</div><div class="line">- self <span class="keyword">perform</span></div></pre></td></tr></table></figure><img src="/2019/12/30/iOS-learn/thread-status.png" alt="thread-status.png" title=""><p>线程的名称</p><p>线程的优先级</p><h3 id="多线程的共享资源"><a href="#多线程的共享资源" class="headerlink" title="多线程的共享资源"></a>多线程的共享资源</h3><p>线程不安全：获取的数据和预期可能不一样</p><p>互斥锁：线程同步，@synchronized 当一个线程在操作数据的时候，其它线程不得操作该数据</p><h3 id="原子属性-atomic"><a href="#原子属性-atomic" class="headerlink" title="原子属性 atomic"></a>原子属性 atomic</h3><p>原子属性是线程安全的，自旋锁</p><p>原子属性的成员变量，在set方法中会添加@synchronized保护线程安全</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/12/30/iOS-learn/iOS-intro.png&quot; alt=&quot;iOS-intro.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;以下笔记是边看视频课程边记录下来的，供以后自己查阅复习使用&lt;/p&gt;
&lt;h2 id=&quot;Runtime学习笔记1&quot;&gt;&lt;a href=&quot;#Runtime学习笔记1&quot; class=&quot;headerlink&quot; title=&quot;Runtime学习笔记1&quot;&gt;&lt;/a&gt;Runtime学习笔记1&lt;/h2&gt;&lt;h3 id=&quot;消息转发&quot;&gt;&lt;a href=&quot;#消息转发&quot; class=&quot;headerlink&quot; title=&quot;消息转发&quot;&gt;&lt;/a&gt;消息转发&lt;/h3&gt;&lt;p&gt;在OC中，调用方法其实是给对象发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[[Person &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;] &lt;span class=&quot;string&quot;&gt;sendMessage:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;gelo&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;objc_msgSend([Person &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;], &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;sendMessage:&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;gelo&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过对象的isa指针找到class，如果有方法的话，直接调用。没有找到的话，通过继承树查找，进入消息转发机制&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://mah93.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>敏感词过滤Aho-Corasick算法</title>
    <link href="https://mah93.github.io/2019/09/26/aho-corasick/"/>
    <id>https://mah93.github.io/2019/09/26/aho-corasick/</id>
    <published>2019-09-26T09:23:08.000Z</published>
    <updated>2019-09-26T09:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/26/aho-corasick/ac-logo.jpg" alt="ac-logo.jpg" title=""><h2 id="多模式串匹配算法简介"><a href="#多模式串匹配算法简介" class="headerlink" title="多模式串匹配算法简介"></a>多模式串匹配算法简介</h2><p>敏感词过滤最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。</p><p>字符串匹配算法有很多比如BF算法、RK算法、BM算法、KMP算法还有Trie树。前面四种算法都是单模式串匹配算法，只有Trie树是多模式串匹配算法。</p><p>我们可以针对每个敏感词，通过单模式匹配算法与用户输入的文字内容进行匹配。但是这样做的话，每个需要匹配的敏感词都需要扫描一遍用户输入的内容。如果敏感词有很多，并且用户输入的内容很长，这种处理的方法就显得比较低效。</p><p>与单模式匹配算法相比，多模式串匹配算法在敏感词过滤这个问题上处理就很高效了，它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在。</p><a id="more"></a> <h2 id="Aho-Corasick算法"><a href="#Aho-Corasick算法" class="headerlink" title="Aho-Corasick算法"></a>Aho-Corasick算法</h2><p>Aho-Corasick算法一般称作AC自动机，<strong>AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在trie树上罢了。</strong></p><p>AC自动机有三个核心函数，分别是：</p><ul><li>success状态，成功转移到下一个节点（即Trie树）</li><li>failure状态，在该节点匹配失败，则跳转到一个特定的节点，从根节点到这个特定的节点的路径恰好是失败前文本的一部分。</li><li>output状态，匹配到了敏感词</li></ul><p>根据以上AC算法的特点，改进Trie节点的属性如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key, parent, word</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];    </div><div class="line">    <span class="keyword">this</span>.parent = parent;   <span class="comment">// 该节点的父节点，用于构建failure表</span></div><div class="line">    <span class="keyword">this</span>.failure = <span class="literal">null</span>;    <span class="comment">// 失效之后指向的节点</span></div><div class="line">    <span class="keyword">this</span>.word = word        <span class="comment">// 该节点是否为某一个敏感词的尾字符 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="构建Trie树"><a href="#构建Trie树" class="headerlink" title="构建Trie树"></a>构建Trie树</h2><p>和普通的trie构建是一样的，逐个插入节点。假设敏感词以及待过滤的字符串，均是小写的英文字母。以英文字母的ASCII码作为数组下标存储节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>];</div><div class="line">      </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">let</span> isWord = data.length === <span class="number">1</span>;</div><div class="line">        <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>], node, isWord);</div><div class="line">        children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>] = insertNode;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="添加Failure失效节点"><a href="#添加Failure失效节点" class="headerlink" title="添加Failure失效节点"></a>添加Failure失效节点</h2><p>下图是以<code>[&#39;HER&#39;, &#39;HEQ&#39;, &#39;SHR&#39;]</code>构建的trie树：</p><img src="/2019/09/26/aho-corasick/ac-failure.png" alt="ac-failure.png" title=""><p>在这张图中，虚线表示failure后的指向，上面我们也说到failure状态的作用，就是在失配的时候告诉程序往哪里走，为什么要这么做，从这张表我们可以很清楚的看到，当我们匹配<code>SHER</code>时，程序会走右边的分支，当走到S &gt; H &gt; E时，会出现失配，怎么办？可能有小伙伴会想到回滚到ROOT从H开始重新匹配，但这样回溯是有成本的，我们既然走了H节点，为什么要回溯呢？</p><p>这个时候failure就发挥作用了，我们看到右分支的H有一条虚线指向了左分支的H，我们也知道这就是failure的指向，通过这个指向，我们很轻松的将当前状态移交过去。程序继续匹配E &gt; R，加上移交过来的H，我们可以轻松的匹配到HER。</p><p><strong>问：假设有一个节点为currNode，它的子节点是childNode，那么子节点childNode的failure指向怎么求？</strong></p><p><em>解：首先，我们需要找到childNode父节点currNode的failure指向，假设这个指向是Q的话，<strong>我们就要看看Q的孩子（children属性）中有没有与childNode字符相同（key相同）的节点</strong>，如果有的话，这个节点就是childNode的failure指向。如果没有，我们就需要沿着currNode -&gt; failure -&gt; failure重复上述过程，如果一直没找到，就将其指向root。</em></p><p>由此可知，一个节点的失效指针一定在该节点的上层。需要注意的是，我们在构建Trie树时，并不知道failure指向到哪里的，所以failure指向需要在Trie树构建完成后插入。</p><p>首先将trie树第二层节点的失效指针指向root，之后逐层为每一个节点添加失效指针，即采用广度优先遍历Trie树：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFailure</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> currQueue = <span class="built_in">Object</span>.values(<span class="keyword">this</span>.root.children);</div><div class="line">  </div><div class="line">  <span class="keyword">while</span> (currQueue.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">let</span> nextQueue = [];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currQueue.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> node = currQueue[i]</div><div class="line">        <span class="keyword">let</span> key = node.key</div><div class="line">        <span class="keyword">let</span> parent = node.parent</div><div class="line">        node.failure = <span class="keyword">this</span>.root</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> node.children) &#123;</div><div class="line">          nextQueue.push(node.children[k])</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parent) &#123;</div><div class="line">          <span class="keyword">let</span> failure = parent.failure</div><div class="line">          <span class="keyword">while</span> (failure) &#123;</div><div class="line">            <span class="keyword">let</span> children = failure.children[key.charCodeAt() - <span class="number">97</span>]</div><div class="line">            <span class="keyword">if</span> (children) &#123;</div><div class="line">              node.failure = children</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            failure = failure.failure</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      currQueue = nextQueue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h2><p>对于Trie树上的一些准备工作已经做完了，下面就是要对待匹配的字符串进行过滤。从头遍历当遇到output表中的节点时，就是出现了敏感词。在匹配失败的时候顺着失效节点继续匹配过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> children = <span class="keyword">this</span>.root.children;</div><div class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.root;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;word.length; i++)&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(currentNode.children[word[i].charCodeAt() - <span class="number">97</span>] == <span class="literal">null</span> &amp;&amp; currentNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      currentNode = currentNode.failure;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currentNode = currentNode.children[word[i].charCodeAt() - <span class="number">97</span>];</div><div class="line">    <span class="keyword">if</span> (currentNode == <span class="literal">null</span>) &#123;</div><div class="line">      currentNode = <span class="keyword">this</span>.root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> temNode = currentNode;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(temNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      <span class="keyword">if</span>(temNode.word === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出现了敏感词'</span>);</div><div class="line">      &#125; </div><div class="line">      temNode = temNode.failure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line"><span class="comment">// 生成trie树</span></div><div class="line">trie.insert(<span class="string">'he'</span>);</div><div class="line">trie.insert(<span class="string">'his'</span>);</div><div class="line">trie.insert(<span class="string">'she'</span>);</div><div class="line">trie.insert(<span class="string">'hers'</span>);</div><div class="line"></div><div class="line">trie.getFailure();</div><div class="line"></div><div class="line"><span class="comment">// 测试数据</span></div><div class="line">trie.filter(<span class="string">'ushers'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 该字符串出现了三个敏感词</span></div></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key, parent, word</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="keyword">this</span>.failure = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.word = word</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Trie</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>, <span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 添加根节点</span></div><div class="line">    <span class="keyword">this</span>.insert = insert; <span class="comment">// 插入</span></div><div class="line">    <span class="keyword">this</span>.insertData = insertData;</div><div class="line">  </div><div class="line">    <span class="keyword">this</span>.getFailure = getFailure;</div><div class="line">    <span class="keyword">this</span>.filter = filter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>];</div><div class="line">      </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">let</span> isWord = data.length === <span class="number">1</span>;</div><div class="line">        <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>], node, isWord);</div><div class="line">        children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>] = insertNode;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFailure</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> currQueue = <span class="built_in">Object</span>.values(<span class="keyword">this</span>.root.children);</div><div class="line">  </div><div class="line">  <span class="keyword">while</span> (currQueue.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">let</span> nextQueue = [];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currQueue.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> node = currQueue[i]</div><div class="line">        <span class="keyword">let</span> key = node.key</div><div class="line">        <span class="keyword">let</span> parent = node.parent</div><div class="line">        node.failure = <span class="keyword">this</span>.root</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> node.children) &#123;</div><div class="line">          nextQueue.push(node.children[k])</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parent) &#123;</div><div class="line">          <span class="keyword">let</span> failure = parent.failure</div><div class="line">          <span class="keyword">while</span> (failure) &#123;</div><div class="line">            <span class="keyword">let</span> children = failure.children[key.charCodeAt() - <span class="number">97</span>]</div><div class="line">            <span class="keyword">if</span> (children) &#123;</div><div class="line">              node.failure = children</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            failure = failure.failure</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      currQueue = nextQueue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> children = <span class="keyword">this</span>.root.children;</div><div class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.root;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;word.length; i++)&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(currentNode.children[word[i].charCodeAt() - <span class="number">97</span>] == <span class="literal">null</span> &amp;&amp; currentNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      currentNode = currentNode.failure;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currentNode = currentNode.children[word[i].charCodeAt() - <span class="number">97</span>];</div><div class="line">    <span class="keyword">if</span> (currentNode == <span class="literal">null</span>) &#123;</div><div class="line">      currentNode = <span class="keyword">this</span>.root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> temNode = currentNode;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(temNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      <span class="keyword">if</span>(temNode.word === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出现了敏感词'</span>);</div><div class="line">      &#125; </div><div class="line">      temNode = temNode.failure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line"><span class="comment">// 生成trie树</span></div><div class="line">trie.insert(<span class="string">'he'</span>);</div><div class="line">trie.insert(<span class="string">'his'</span>);</div><div class="line">trie.insert(<span class="string">'she'</span>);</div><div class="line">trie.insert(<span class="string">'hers'</span>);</div><div class="line"></div><div class="line">trie.getFailure();</div><div class="line"></div><div class="line"><span class="comment">// 测试数据</span></div><div class="line">trie.filter(<span class="string">'ushers'</span>)</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://juejin.im/post/5cfa6bb6f265da1b8a4f0ed8#heading-4" target="_blank" rel="external">TypeScript：Aho–Corasick算法实现敏感词过滤</a></p></li><li><p><a href="http://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html" target="_blank" rel="external">Aho-Corasick算法的Java实现与分析</a></p></li><li><p><a href="https://time.geekbang.org/column/article/72810" target="_blank" rel="external">36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/26/aho-corasick/ac-logo.jpg&quot; alt=&quot;ac-logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;多模式串匹配算法简介&quot;&gt;&lt;a href=&quot;#多模式串匹配算法简介&quot; class=&quot;headerlink&quot; title=&quot;多模式串匹配算法简介&quot;&gt;&lt;/a&gt;多模式串匹配算法简介&lt;/h2&gt;&lt;p&gt;敏感词过滤最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。&lt;/p&gt;
&lt;p&gt;字符串匹配算法有很多比如BF算法、RK算法、BM算法、KMP算法还有Trie树。前面四种算法都是单模式串匹配算法，只有Trie树是多模式串匹配算法。&lt;/p&gt;
&lt;p&gt;我们可以针对每个敏感词，通过单模式匹配算法与用户输入的文字内容进行匹配。但是这样做的话，每个需要匹配的敏感词都需要扫描一遍用户输入的内容。如果敏感词有很多，并且用户输入的内容很长，这种处理的方法就显得比较低效。&lt;/p&gt;
&lt;p&gt;与单模式匹配算法相比，多模式串匹配算法在敏感词过滤这个问题上处理就很高效了，它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="https://mah93.github.io/2019/09/07/trie/"/>
    <id>https://mah93.github.io/2019/09/07/trie/</id>
    <published>2019-09-07T08:35:18.000Z</published>
    <updated>2020-07-09T02:29:21.919Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/07/trie/Trie-logo.png" alt="Trie-logo.png" title=""><h2 id="Trie树简介"><a href="#Trie树简介" class="headerlink" title="Trie树简介"></a>Trie树简介</h2><p>Trie 树，也叫字典树或者叫前缀树。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的树状结构，用来解决在一组字符串集合中快速查找某个字符串的问题。Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><a id="more"></a> <p>下面展示了一个由“hello”、“her”、“hi”、“how”、“see”以及“so”组成的Trie树。</p><img src="/2019/09/07/trie/Trie-Tres.jpg" alt="Trie-Tres.jpg" title=""><h2 id="Trie特点"><a href="#Trie特点" class="headerlink" title="Trie特点"></a>Trie特点</h2><p>由上图中的Trie中可知</p><ul><li>Trie的每个节点存储一个字符，根节点不保存字符</li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><h2 id="实现Trie树"><a href="#实现Trie树" class="headerlink" title="实现Trie树"></a>实现Trie树</h2><h3 id="Trie树节点"><a href="#Trie树节点" class="headerlink" title="Trie树节点"></a>Trie树节点</h3><p>由于每个节点只存储一个字符，以及指向它的子节点，那么对于每个节点有如下的数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中key保存了这个节点的值，children中保存了该节点的所有子节点（对于小写英文字母而言，这个数组的长度为26）</p><h3 id="Trie树的插入"><a href="#Trie树的插入" class="headerlink" title="Trie树的插入"></a>Trie树的插入</h3><p>构建一棵Trie树就是将字符串逐个插入的过程。由于Trie的特点，插入操作的过程中。要先判断Trie是否已经存在了与待插入字符串相同的前缀，找到所有的公共前缀后，将不同的字符插入Trie中。对于插入的过程，大致的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用递归插入字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = <span class="literal">null</span>;</div><div class="line">    </div><div class="line">   <span class="comment">// 判断存储子节点的数组中，是否有与插入字符串的第一个值匹配的节点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">        <span class="keyword">if</span> (children[i].key == data[<span class="number">0</span>]) &#123;</div><div class="line">            haveData = children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="comment">// 待插入的第一个字符已经存在children数组中，则继续判断下一个字符</span></div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">// 未找到相应的子节点，分为两种情况</span></div><div class="line">      <span class="comment">// 已经是现有Trie的叶子节点</span></div><div class="line">        <span class="keyword">if</span>(children.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.push(insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">// 要在当前的children中找到合适的位置，插入字符</span></div><div class="line">            <span class="keyword">let</span> validPosition = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[j].key &lt; data[<span class="number">0</span>]) &#123;</div><div class="line">                    validPosition++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.splice(validPosition, <span class="number">0</span>, insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在插入Trie树的过程中，需要遍历所有的字符串，时间复杂度是O(n)，n表示所有字符串的长度和。</p><h3 id="Trie树的查找"><a href="#Trie树的查找" class="headerlink" title="Trie树的查找"></a>Trie树的查找</h3><p>查找的过程与插入的过程类似，需要逐层遍历，寻找与待匹配字符串相同的字符。其大概代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span> || <span class="keyword">this</span>.root.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">// 遍历children</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.searchNext(<span class="keyword">this</span>.root.children[i], data)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 递归查找</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchNext</span>(<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(data[<span class="number">0</span>] !== node.key) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">  <span class="comment">// 该节点已经是叶子节点，并且待查找字符串已查找完毕</span></div><div class="line">    <span class="keyword">if</span>(children.length === <span class="number">0</span> &amp;&amp; data.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(children.length &gt; <span class="number">0</span> &amp;&amp; data.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">            <span class="comment">// 继续判断下一个字符</span></div><div class="line">            <span class="keyword">if</span>(children[i].key === data[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> searchNext(children[i], data.substring(<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Trie树已经构建完成的情况下，查找一个字符串是否在Trie中效率是非常高的，其事件复杂度为O(K)，k表示待查找字符串的长度。</p><h3 id="Trie树的删除"><a href="#Trie树的删除" class="headerlink" title="Trie树的删除"></a>Trie树的删除</h3><p>先递归查找到字符串的叶子节点，然后从字符串的叶子节点逐级向根节点递归删除叶子节点，直到删除字符串。其大概的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNode</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search(data)) &#123; <span class="comment">// 判断是否存在该单词（字符串）</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deleteNext(<span class="keyword">this</span>.root, i, data, data)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* @param parent 父节点</span></div><div class="line"><span class="comment">* @param index 子节点在父节点children数组中的索引位置</span></div><div class="line"><span class="comment">* @param stringData 递归遍历中的字符串</span></div><div class="line"><span class="comment">* @param delStr 调用delete方法时的原始字符串</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNext</span>(<span class="params">parent, index, stringData, delStr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = parent.children[index];</div><div class="line">    <span class="comment">// 若字符与节点key不相等，则不匹配</span></div><div class="line">    <span class="keyword">if</span> (stringData[<span class="number">0</span>] != node.key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若与key相等，继续判断</span></div><div class="line">        <span class="keyword">let</span> children = node.children;</div><div class="line">        <span class="keyword">if</span> (children.length == <span class="number">0</span> &amp;&amp; stringData.length == <span class="number">1</span>) &#123; <span class="comment">// 叶子节点，最后一个字符，则完全匹配</span></div><div class="line">            <span class="comment">// 删除叶子节点，利用父节点删除子节点原理</span></div><div class="line">            parent.children.splice(index, <span class="number">1</span>);</div><div class="line">            <span class="comment">// 字符串从尾部移除一个字符后，继续遍历删除方法</span></div><div class="line">            <span class="keyword">this</span>.deleteNode(delStr.substring(<span class="number">0</span>, delStr.length - <span class="number">1</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children.length &gt; <span class="number">0</span> &amp;&amp; stringData.length &gt; <span class="number">1</span>) &#123; <span class="comment">// 既不是叶子节点，也不是最后一个字符，则继续递归查找</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[i].key == stringData[<span class="number">1</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.deleteNext(node, i, stringData.substring(<span class="number">1</span>), delStr); <span class="comment">// 记得return 递归函数，否则获取的返回值为undefined</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Trie改进"><a href="#Trie改进" class="headerlink" title="Trie改进"></a>Trie改进</h2><p>Trie树是非常消耗内存的数据结构，用的是一种空间换时间的思路。Trie树的问题就在于存储子节点的children数组中。如果字符串中只包含从a到z的26个字符，那么children的长度就为26。<strong>注意，这里说的是每一个Trie树的节点，都需要申请一个长度为26的数组，即使这个节点只有一个子节点！</strong></p><p>那么如果字符串包含了大小写，或者是数字特殊字符。Trie所需的空间就更大了。尤其是在重复的前缀不多的情况下，Trie树不但不能节省内存，而且还有可能浪费更多的内存空间。可以想到的方法就是，将children修改为其他的数据结构，比如有序数组、跳表等。</p><p>对只有一个子节点的节点，而且此节点不是一个串的结束节点可以将此节点与子节点合并，这就是<strong>缩点优化</strong>。</p><img src="/2019/09/07/trie/Trie-up.jpg" alt="Trie-up.jpg" title=""><h2 id="Trie树完整代码"><a href="#Trie树完整代码" class="headerlink" title="Trie树完整代码"></a>Trie树完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Trie</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 添加根节点</span></div><div class="line">    <span class="keyword">this</span>.insert = insert; <span class="comment">// 插入</span></div><div class="line">    <span class="keyword">this</span>.insertData = insertData;</div><div class="line">    <span class="keyword">this</span>.search = search; <span class="comment">// 查找</span></div><div class="line">    <span class="keyword">this</span>.searchNext = searchNext;</div><div class="line">    <span class="keyword">this</span>.deleteNode = deleteNode; <span class="comment">// 删除</span></div><div class="line">    <span class="keyword">this</span>.deleteNext = deleteNext;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.nodeNumber = <span class="number">0</span>; <span class="comment">// trie所有节点个数</span></div><div class="line">    <span class="keyword">this</span>.print = print; <span class="comment">// 打印Trie树</span></div><div class="line">    <span class="keyword">this</span>.printHelper = printHelper;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = <span class="literal">null</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">        <span class="keyword">if</span> (children[i].key == data[<span class="number">0</span>]) &#123;</div><div class="line">            haveData = children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(children.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.push(insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">let</span> validPosition = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[j].key &lt; data[<span class="number">0</span>]) &#123;</div><div class="line">                    validPosition++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.splice(validPosition, <span class="number">0</span>, insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span> || <span class="keyword">this</span>.root.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.searchNext(<span class="keyword">this</span>.root.children[i], data)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchNext</span>(<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(data[<span class="number">0</span>] !== node.key) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">if</span>(children.length === <span class="number">0</span> &amp;&amp; data.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(children.length &gt; <span class="number">0</span> &amp;&amp; data.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">            <span class="keyword">if</span>(children[i].key === data[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> searchNext(children[i], data.substring(<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNode</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search(data)) &#123; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deleteNext(<span class="keyword">this</span>.root, i, data, data)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNext</span>(<span class="params">parent, index, stringData, delStr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = parent.children[index];</div><div class="line">    <span class="keyword">if</span> (stringData[<span class="number">0</span>] != node.key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> children = node.children;</div><div class="line">        <span class="keyword">if</span> (children.length == <span class="number">0</span> &amp;&amp; stringData.length == <span class="number">1</span>) &#123; </div><div class="line">            parent.children.splice(index, <span class="number">1</span>);</div><div class="line">            <span class="keyword">this</span>.deleteNode(delStr.substring(<span class="number">0</span>, delStr.length - <span class="number">1</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children.length &gt; <span class="number">0</span> &amp;&amp; stringData.length &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[i].key == stringData[<span class="number">1</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.deleteNext(node, i, stringData.substring(<span class="number">1</span>), delStr);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">this</span>.nodeNumber++;</div><div class="line">        <span class="keyword">this</span>.printHelper(<span class="keyword">this</span>.root.children[i], [<span class="keyword">this</span>.root.children[i].key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHelper</span> (<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;'</span>, data.join(<span class="string">''</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> node.children) &#123;</div><div class="line">        <span class="keyword">this</span>.nodeNumber++;</div><div class="line">        data.push(node.children[i].key);</div><div class="line">        <span class="keyword">this</span>.printHelper(node.children[i], data);</div><div class="line">        data.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line">trie.insert(<span class="string">'apple'</span>);</div><div class="line">trie.insert(<span class="string">'appcd'</span>);</div><div class="line">trie.insert(<span class="string">'banana'</span>);</div><div class="line"></div><div class="line">trie.print();</div><div class="line"><span class="built_in">console</span>.log(trie.search(<span class="string">"app"</span>));</div><div class="line">trie.deleteNode(<span class="string">'appcd'</span>)</div><div class="line">trie.print();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(trie.nodeNumber);</div><div class="line"></div><div class="line"><span class="comment">// 输出结果</span></div><div class="line">&gt; appcd</div><div class="line">&gt; apple</div><div class="line">&gt; banana</div><div class="line"><span class="literal">false</span></div><div class="line">&gt; apple</div><div class="line">&gt; banana</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>第一次看Trie树的概念，完全没明白到底是什么样的数据结构。直到看了Trie树的图示例，一下就明白了，Trie树的概念非常好理解，就是把相同的前缀放到一起构成了一个数据结构。在对比字符串的时候，就像查字典一层层的比较。</p><p>对于每个节点的存储结构确实比较绕，每次遍历children数组就相当于去往下一层比较了，反正每次涉及到递归函数总是不好理解。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.jianshu.com/p/ba70ca95c33b" target="_blank" rel="external">Trie树的JS或TS实现</a></p></li><li><p><a href="https://time.geekbang.org/column/article/72414" target="_blank" rel="external">Trie树：如何实现搜索引擎的搜索关键词提示功能？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/07/trie/Trie-logo.png&quot; alt=&quot;Trie-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Trie树简介&quot;&gt;&lt;a href=&quot;#Trie树简介&quot; class=&quot;headerlink&quot; title=&quot;Trie树简介&quot;&gt;&lt;/a&gt;Trie树简介&lt;/h2&gt;&lt;p&gt;Trie 树，也叫字典树或者叫前缀树。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的树状结构，用来解决在一组字符串集合中快速查找某个字符串的问题。Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://mah93.github.io/2019/08/12/binary-search/"/>
    <id>https://mah93.github.io/2019/08/12/binary-search/</id>
    <published>2019-08-12T09:12:54.000Z</published>
    <updated>2019-08-12T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/12/binary-search/binary-logo.png" alt="binary-logo.png" title=""><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>二分查找（Binary Search）算法，也叫折半查找算法。在给顺序表结构中（也就是数组）快速查找某一个值或者某个区间。二分查找的时间复杂度是O(logn)。虽然二分查找看起来很简单，实现出来的代码不够寥寥十几行，但是就是会出错，要么漏个等号，要么少加1。也就是<strong>思路很简单，细节是魔鬼</strong></p><p>本文均抄自Leetcode精选解题，本文原作者是labuladong</p><a id="more"></a> <h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>二分查找的写法基本固定，根据不同的场景修改起始值、判断条件、中止值非常容易忽略细节</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> binary<span class="constructor">Search(<span class="params">nums</span>, <span class="params">target</span>)</span> &#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, </div><div class="line">    <span class="keyword">let</span> right = ...;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(...) &#123;</div><div class="line">        <span class="keyword">let</span> mid = parse<span class="constructor">Int((<span class="params">right</span> + <span class="params">left</span>)</span><span class="operator"> / </span><span class="number">2</span>); <span class="comment">// 向下取整</span></div><div class="line">        <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span><span class="operator"> == </span>target) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span> &lt; target) &#123;</div><div class="line">            left = ...</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span> &gt; target) &#123;</div><div class="line">            right = ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ...;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于mid的取值问题，mid=（right+left）/2是有问题的，因为当right和left比较大的时候，相加的值有可能导致溢出。改进的方法是写成mid = left + (right-left)/2。如果要进行极致的性能优化，可以将除以2的操作写成位运算，left + (right-left) &gt;&gt; 1，相比于除法，计算机计算位运算的速度更快。</p><blockquote><p>本文均写成(right + left) / 2方便阅读，给定的数组均是升序数组</p></blockquote><h2 id="查找某一固定值"><a href="#查找某一固定值" class="headerlink" title="查找某一固定值"></a>查找某一固定值</h2><p>在给定的升序数组中，查找该数组中的某一个值，返回该值在数组中所处下标位置，若不存在该值则返回-1</p><p>例：给定数组[1,3,4,6,9,11,23,55]，查找数字6</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;=right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么-while-循环的条件中是-lt-，而不是-lt-？"><a href="#为什么-while-循环的条件中是-lt-，而不是-lt-？" class="headerlink" title="为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？"></a>为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</h4><p>因为right初始化的值是nums.length-1，即数组中最后一个元素，而不是nums.length。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</p><p>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">   <span class="keyword">return</span> mid;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。</p><p>while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 33 又小于等于 22 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 22，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 22 没有被搜索，如果这时候直接返回 -1 就是错误的。</p></li><li><h4 id="为什么-left-mid-1，right-mid-1？我看有的代码是-right-mid或者-left-mid，没有这些加加减减，到底怎么回事，怎么判断？"><a href="#为什么-left-mid-1，right-mid-1？我看有的代码是-right-mid或者-left-mid，没有这些加加减减，到底怎么回事，怎么判断？" class="headerlink" title="为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？"></a>为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？</h4><p>这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？</p><p>当然是 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</p></li></ul><h2 id="查找第一个等于给定元素的值-左边界"><a href="#查找第一个等于给定元素的值-左边界" class="headerlink" title="查找第一个等于给定元素的值(左边界)"></a>查找第一个等于给定元素的值(左边界)</h2><p>类似于上一个例子，现在我们给定的数组变成了[1,6,6,6,9]，需要返回第一个等于6的元素的下标。运行上面的函数返回值为2，因为第一个值的mid就等于了6。那么如何改进二分查找，才能找到第一个等于6的元素呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么-while-left-lt-right-而不是-lt"><a href="#为什么-while-left-lt-right-而不是-lt" class="headerlink" title="为什么 while(left &lt; right) 而不是 &lt;= ?"></a>为什么 while(left &lt; right) 而不是 &lt;= ?</h4><p>用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。</p><p>while(left &lt; right)终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。</p></li><li><h4 id="为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办？"><a href="#为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办？" class="headerlink" title="为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？"></a>为什么没有返回 <code>-1</code> 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</h4><p>  对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 6 的元素有 1 个。</p><p>  比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1的元素有 0 个。</p><p>  再比如说 nums 不变，target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。</p><p>  综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我   们简单添加两行代码就能在正确的时候 return -1：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// target 比所有数都大</span></div><div class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"><span class="comment">// 类似之前算法的处理方式</span></div><div class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</div></pre></td></tr></table></figure></li><li><h4 id="为什么-left-mid-1，right-mid-？和之前的算法不一样？"><a href="#为什么-left-mid-1，right-mid-？和之前的算法不一样？" class="headerlink" title="为什么 left = mid + 1，right = mid ？和之前的算法不一样？"></a>为什么 left = mid + 1，right = mid ？和之前的算法不一样？</h4><p>这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之        后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。</p></li><li><h4 id="为什么该算法能够搜索左侧边界？"><a href="#为什么该算法能够搜索左侧边界？" class="headerlink" title="为什么该算法能够搜索左侧边界？"></a>为什么该算法能够搜索左侧边界？</h4><p>关键在于对于 nums[mid] == target 这种情况的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (nums[mid] == target)</div><div class="line">    right = mid;</div></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p></li></ul><h2 id="查找最后一个等于给定元素的值-右边界"><a href="#查找最后一个等于给定元素的值-右边界" class="headerlink" title="查找最后一个等于给定元素的值(右边界)"></a>查找最后一个等于给定元素的值(右边界)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么最后返回-left-1-而不像左侧边界的函数，返回-left？而且我觉得这里既然是搜索右侧边界，应该返回-right-才对。"><a href="#为什么最后返回-left-1-而不像左侧边界的函数，返回-left？而且我觉得这里既然是搜索右侧边界，应该返回-right-才对。" class="headerlink" title="为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。"></a>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。</h4><p>首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。</p><p>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target</p></li></ul><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>二分查找对于有序数组的查询效率非常高，但是对于边界问题处理上十分棘手，考察细节一不小心就会导致死循环，而且不易查找错误。</p><p>有效的理解是确定每次的搜索范围以及循环中止条件。对于每次修改搜索范围的原则是，关注mid有没有被搜索过。在此基础上+1或者-1。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://leetcode-cn.com/problems/two-sum/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external">leetcode精选解题</a></p></li><li><p><a href="https://time.geekbang.org/column/article/42733" target="_blank" rel="external">极客时间   二分查找</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/08/12/binary-search/binary-logo.png&quot; alt=&quot;binary-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;二分查找（Binary Search）算法，也叫折半查找算法。在给顺序表结构中（也就是数组）快速查找某一个值或者某个区间。二分查找的时间复杂度是O(logn)。虽然二分查找看起来很简单，实现出来的代码不够寥寥十几行，但是就是会出错，要么漏个等号，要么少加1。也就是&lt;strong&gt;思路很简单，细节是魔鬼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文均抄自Leetcode精选解题，本文原作者是labuladong&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="https://mah93.github.io/2019/08/08/string-matching/"/>
    <id>https://mah93.github.io/2019/08/08/string-matching/</id>
    <published>2019-08-08T04:59:26.000Z</published>
    <updated>2019-08-08T05:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/08/string-matching/string-logo.png" alt="string-logo.png" title=""><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。</p><a id="more"></a> <img src="/2019/08/08/string-matching/BF.jpg" alt="BF.jpg" title=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BF</span>(<span class="params">haystack, needle</span>) </span>&#123;       </div><div class="line">    <span class="keyword">let</span> j=<span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</div><div class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                re = i;</div><div class="line">            &#125;</div><div class="line">            j = j+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(j == needle.length) &#123;</div><div class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(j !== <span class="number">0</span>)&#123;</div><div class="line">                i=i-j;</div><div class="line">            &#125;</div><div class="line">            j=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>RK算法在BF基础上，引入哈希算法。通过字符串的哈希值的比较替换掉字符串之间的比较，从而降低算法的时间复杂度。RK算法整体的时间复杂度为O(n)。其中 n 为原字符串长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成hash值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">string</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</div><div class="line">        hash += <span class="number">26</span> * hash + string[i].charCodeAt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 比较两个字符串是否相等</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span> (<span class="params">str, dest</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str.length !== dest.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (str[i] !== dest[i]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RK</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> needleHash = hash(needle);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=(haystack.length - needle.length); i++)&#123;</div><div class="line">        <span class="keyword">let</span> subStr = haystack.substr(i, needle.length);</div><div class="line">        <span class="keyword">if</span> (hash(subStr) === needleHash &amp;&amp; isMatch(subStr, needle)) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>BM算法的核心思想是通过将模式串沿着主串大踏步的向后滑动，从而大大减少比较次数，降低时间复杂度。而算法的关键在于如何兼顾步子迈得足够大与无遗漏，同时要尽量提高执行效率。这就需要模式串在向后滑动时，遵守坏字符规则与好后缀规则，同时采用一些技巧。</p><h3 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h3><p>坏字符规则：从后往前逐位比较模式串与主串的字符，当找到不匹配的坏字符时，记录模式串的下标值si，并找到坏字符在模式串中，位于下标si前的最近位置xi（若无则记为-1），si-xi即为向后滑动距离。（PS：我觉得加上xi必须在si前面，也就是比si小的条件，就不用担心计算出的距离为负了）。但是坏字符规则向后滑动的步幅还不够大，于是需要好后缀规则。</p><h3 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h3><p>好后缀规则：从后往前逐位比较模式串与主串的字符，当出现坏字符时停止。若存在已匹配成功的子串｛u｝，那么在模式串的｛u｝前面找到最近的｛u｝，记作｛u’｝。再将模式串后移，使得模式串的｛u’｝与主串的｛u｝重叠。若不存在｛u’｝，则直接把模式串移到主串的｛u｝后面。为了没有遗漏，需要找到最长的、能够跟模式串的前缀子串匹配的，好后缀的后缀子串（同时也是模式串的后缀子串）。然后把模式串向右移到其左边界，与这个好后缀的后缀子串在主串中的左边界对齐。</p><p>何时使用坏字符规则和好后缀规则呢？首先在每次匹配过程中，一旦发现坏字符，先执行坏字符规则，如果发现存在好后缀，还要执行好后缀规则，并从两者中选择后移距离最大的方案执行。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>1.通过散列表实现，坏字符在模式串中下标位置的快速查询。<br>2.每次执行好后缀原则时，都会计算多次能够与模式串前缀子串相匹配的好后缀的最长后缀子串。为了提高效率，可以预先计算模式串的所有后缀子串，在模式串中与之匹配的另一个子串的位置。同时预计算模式串中（同长度的）后缀子串与前缀子串是否匹配并记录。在具体操作中直接使用，大大提高效率。<br>3.如何快速记录模式串后缀子串匹配的另一个子串位置，以及模式串（相同长度）前缀与后缀子串石否匹配呢？先用一个suffix数组，下标值k为后缀子串的长度，从模式串下标为i（0~m-2）的字符为最后一个字符，查找这个子串是否与后缀子串匹配，若匹配则将子串起始位置的下标值j赋给suffix[k]。若j为0，说明这个匹配子串的起始位置为模式串的起始位置，则用一个数组prefix，将prefix[k]设为true，否则设为false。k从0到m（模式串的长度）于是就得到了模式串所有前缀与后缀子串的匹配情况。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>仅有坏字符规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 本例只实现从'a'-'z'的字符串匹配</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> hash = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</div><div class="line">      hash[i] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</div><div class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      hash[ascii] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> hash = hashMap(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</div><div class="line">      <span class="keyword">let</span> bad = <span class="number">-1</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</div><div class="line">              bad = j;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(bad === <span class="number">-1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      i = i + (bad - hash[ascii]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>坏字符规则在某些场景下会使si-xi为负值，导致无限循环。如在“aaaaaaa”中匹配”baaaa”。</p><p>下面讲好后缀原则加入，完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">suffixAndPrefix</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line">  <span class="keyword">let</span> suffix = [];</div><div class="line">  <span class="keyword">let</span> prefix = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</div><div class="line">    suffix[i] = <span class="number">-1</span>;</div><div class="line">    prefix[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++)&#123;</div><div class="line">    <span class="keyword">let</span> j=i;</div><div class="line">    <span class="keyword">let</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; needle[j] === needle[m<span class="number">-1</span>-k]) &#123;</div><div class="line">      j--;</div><div class="line">      k++;</div><div class="line">      suffix[k] = j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j===<span class="number">-1</span>)&#123;</div><div class="line">      prefix[k]=<span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> [suffix, prefix];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveByGoodFix</span>(<span class="params">j, m, suffix, prefix</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> k = m - <span class="number">1</span> - j;</div><div class="line">  <span class="keyword">if</span>(suffix[k] !== <span class="number">-1</span>) <span class="keyword">return</span> j - suffix[k] + <span class="number">1</span>; <span class="comment">// 如果存在匹配的好后缀子集，滑动到坏字符的下一位</span></div><div class="line">  <span class="comment">// TODO 为什么要寻找？</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=j+<span class="number">2</span>; i&lt;=m<span class="number">-1</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(prefix[m-i] === <span class="literal">true</span>) &#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> hash = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</div><div class="line">      hash[i] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</div><div class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      hash[ascii] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> [ suffix, prefix ] = suffixAndPrefix(needle);</div><div class="line">  <span class="keyword">let</span> hash = hashMap(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</div><div class="line">      <span class="keyword">let</span> bad = <span class="number">-1</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</div><div class="line">              bad = j;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(bad === <span class="number">-1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      <span class="keyword">let</span> badChar = bad - hash[ascii];</div><div class="line">      <span class="keyword">let</span> goodFix = <span class="number">0</span>;</div><div class="line">      <span class="comment">// 判断是否有好后缀</span></div><div class="line">      <span class="keyword">if</span>(bad&lt;m<span class="number">-1</span>)&#123;</div><div class="line">        goodFix = moveByGoodFix(bad, m, suffix, prefix);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      i = i + <span class="built_in">Math</span>.max(badChar, goodFix);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="PMT数组"><a href="#PMT数组" class="headerlink" title="PMT数组"></a>PMT数组</h3><p>KMP算法的核心，是一个被称为部分匹配表(Partial Match Table)的数组。</p><img src="/2019/08/08/string-matching/PMT.jpg" alt="PMT.jpg" title=""><p><strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。</p><h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。</p><img src="/2019/08/08/string-matching/next.jpg" alt="next.jpg" title=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> res = [];</div><div class="line">  res[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> k = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.length; i++) &#123;</div><div class="line">      <span class="keyword">while</span> (k != <span class="number">-1</span> &amp;&amp; needle[i] != needle[k+<span class="number">1</span>]) &#123;</div><div class="line">          k = res[k]; <span class="comment">// 当不匹配的时候，回溯寻找次长串</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (needle[i] === needle[k+<span class="number">1</span>]) &#123;</div><div class="line">          k++;</div><div class="line">      &#125;</div><div class="line">      res[i] = k;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> nextArray = next(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] !== needle[j])&#123;</div><div class="line">      j = nextArray[j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(haystack[i] == needle[j]) &#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j == m)&#123;</div><div class="line">      <span class="keyword">return</span> i-m+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">最差时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">BF算法</td><td style="text-align:center">T(1)</td><td style="text-align:center">O(nm)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">RK算法</td><td style="text-align:center">T(1)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">BM算法</td><td style="text-align:center">T(2m)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">KMP算法</td><td style="text-align:center">T(m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(nm)</td></tr></tbody></table><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>BF算法是最容易想到的算法，只需要逐个字符去比较，遇到不匹配的字符只需要将主串字符向后移动一位，重复比较即可。</p><p>RK算法在BF的基础上，引入了hash值。核心理念是：hash值不相同的两个字符串一定不想等，hash相等的字符串才有可能相等。通过hash值的运算大大降低了字符比较的次数。</p><p>BM算法提出坏字符和好后缀的规则，从字符串的尾部开始比较。遇到坏字符则大幅度向后滑动，好后缀规则是记录模式串中前后是否有相同的部分。两个规则中移动距离比较远的，则成为下一次循环比较的开始。</p><p>KMP算法在BM算法的基础上，直接先计算模式串的“重复度”即模式串的前后字符是否有相同的部分，匹配到不等的字符就可以把之前比较相等的部分跳过。</p><p>BM和KMP都是处理模式串本身，与主串无关。都是为了在下一次比较的时候能够大幅度的向后移动，以提高字符串匹配的速度。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/article/71187" target="_blank" rel="external">数据结构与算法之美</a></li><li><a href="https://juejin.im/post/5d38fcfcf265da1bcb4f6fce" target="_blank" rel="external">JavaScript 字符串匹配算法</a></li><li><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/08/08/string-matching/string-logo.png&quot; alt=&quot;string-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>js单链表实现</title>
    <link href="https://mah93.github.io/2019/07/19/js-linked/"/>
    <id>https://mah93.github.io/2019/07/19/js-linked/</id>
    <published>2019-07-19T09:17:28.000Z</published>
    <updated>2019-08-08T05:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/19/js-linked/js_linked_logo.jpg" alt="js_linked_logo.jpg" title=""><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><h2 id="与数组的区别"><a href="#与数组的区别" class="headerlink" title="与数组的区别"></a>与数组的区别</h2><p>​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><a id="more"></a> <h2 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>链表的基本存储结构就是一个个的节点，首先先创建一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// val表示该节点上存储的值</span></div><div class="line"><span class="comment">// next表示该节点的下一个节点</span></div><div class="line"><span class="comment">// 一般的单向链表的尾节点指向null</span></div></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>一般链表的第一个节点为head，用来表示这是一个链表存储，在创建链表的时候我们为链表的第一个节点默认设置为head</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们就实现了一个最简单的链表。仿照数组的操作，之后我们为链表添加上基本的增删改查功能。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>为了方便链表操作，首先要记录一下链表的长度。在操作链表的时候记得相应的增减。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">+    <span class="keyword">this</span>.length = <span class="number">0</span>; <span class="comment">// 链表默认的长度为0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><p>在操作链表之前，先能看到链表的样子，方便后续的测试。只需要遍历一下链表，按照自己喜欢的格式打印出链表即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ok～现在已经得到了一个链表了，现在测试一下这个链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line">testLink.display();  <span class="comment">// 打印这个链表</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;tail<br>链表长度为：0</p></blockquote><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>向链表的尾部添加一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.add = add; <span class="comment">// 添加节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++; <span class="comment">// 链表变长了1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3</p></blockquote><h3 id="查找指定节点"><a href="#查找指定节点" class="headerlink" title="查找指定节点"></a>查找指定节点</h3><p>查找指定节点所在链表中的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// // 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div></pre></td></tr></table></figure><blockquote><p>apple是该链表的第2个节点<br>该链表中不存在这个节点</p></blockquote><h3 id="向指定节点后添加一个节点"><a href="#向指定节点后添加一个节点" class="headerlink" title="向指定节点后添加一个节点"></a>向指定节点后添加一个节点</h3><p>首先先要找到指定的节点，若没有查找这个节点则插入失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div></pre></td></tr></table></figure><blockquote><p>插入成功<br>该链表中不存在这个节点<br>插入失败：不存在该节点</p></blockquote><h3 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length --; <span class="comment">// 链表变短了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div><div class="line"></div><div class="line"><span class="comment">// 删除一个节点</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3<br>head-&gt;first-&gt;ball-&gt;tail<br>链表长度为：2</p></blockquote><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表node节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找给定节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 插入</span></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 删除</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="[https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8](https://baike.baidu.com/item/链表">百度百科-链表</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/19/js-linked/js_linked_logo.jpg&quot; alt=&quot;js_linked_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。&lt;/p&gt;
&lt;h2 id=&quot;与数组的区别&quot;&gt;&lt;a href=&quot;#与数组的区别&quot; class=&quot;headerlink&quot; title=&quot;与数组的区别&quot;&gt;&lt;/a&gt;与数组的区别&lt;/h2&gt;&lt;p&gt;​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript接口与泛型</title>
    <link href="https://mah93.github.io/2019/07/05/typescript-g/"/>
    <id>https://mah93.github.io/2019/07/05/typescript-g/</id>
    <published>2019-07-05T08:23:13.000Z</published>
    <updated>2020-07-09T02:29:06.128Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/05/typescript-g/typescript_var_logo.png" alt="typescript_var_logo.png" title=""><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义方法中参数的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">label: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(<span class="string">"sss"</span>);</div></pre></td></tr></table></figure><p>自定义方法传入参数对json的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelInfo: &#123; label: <span class="built_in">string</span> &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(&#123; label: <span class="string">"ssss"</span> &#125;);</div></pre></td></tr></table></figure><a id="more"></a> <p>接口：行为和动作的规范，对批量方法进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义接口</span></div><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现接口</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="可选属性接口"><a href="#可选属性接口" class="headerlink" title="可选属性接口"></a>可选属性接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">age?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><p>加密的函数类型接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> encrypt &#123;</div><div class="line">(key: <span class="built_in">string</span>, value: <span class="built_in">string</span>): <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> md5:encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> key + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">md5(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</div></pre></td></tr></table></figure><h2 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h2><p>对数组的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserArray &#123;</div><div class="line">[index: <span class="built_in">number</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserArray = [<span class="string">"111"</span>, <span class="string">"222"</span>]</div></pre></td></tr></table></figure><p>对对象的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserObj &#123;</div><div class="line">[index: <span class="built_in">string</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserObj = &#123;name: <span class="string">"20"</span>&#125;</div></pre></td></tr></table></figure><p>对类的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">eat(str: <span class="built_in">string</span>): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"小黑"</span>)</div><div class="line">dog.eat();</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat(food: <span class="built_in">string</span>) &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"小花"</span>)</div><div class="line">cat.eat(<span class="string">"猫粮"</span>);</div></pre></td></tr></table></figure><h2 id="接口的继承与拓展"><a href="#接口的继承与拓展" class="headerlink" title="接口的继承与拓展"></a>接口的继承与拓展</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">eat(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</div><div class="line">work(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Programmer &#123;</div><div class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">coding(code: <span class="built_in">string</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  Web类继承Programmer类并且实现Person接口</span></div><div class="line"><span class="keyword">class</span> Web <span class="keyword">extends</span> Programmer <span class="keyword">implements</span> Person &#123;</div><div class="line"><span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">work() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"work"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>接受string类型的参数，并且返回string类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是要同时返回时string和number，就造成了代码冗余</p><p>使用any类型解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是any放弃了类型检查，会丢失掉参数类型。实际的需求时，传入什么类型的数据，就要返回什么类型的数据。</p><p>泛型：可以支持不确定的数据类型，要求：传入的参数和返回的类型一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="number">123</span>); <span class="comment">// error</span></div></pre></td></tr></table></figure><blockquote><p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 <code>T</code>、<code>U</code>、<code>V</code> 表示。如果在你的参数里，不止拥有一个泛型，你应该使用一个更语义化名称，如 <code>TKey</code> 和 <code>TValue</code> （通常情况下，以 <code>T</code> 做为泛型前缀也在如 C++ 的其他语言里做为模版。）</p></blockquote><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>返回数组中最小的值，同时支持number类型以及string类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MinClass&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span> list: T[] = [];</div><div class="line">add(value: T): <span class="built_in">void</span> &#123;</div><div class="line"><span class="keyword">this</span>.list.push(value);</div><div class="line">&#125;</div><div class="line">min(): T &#123;</div><div class="line"><span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</div><div class="line"><span class="keyword">if</span>(minNum &gt; <span class="keyword">this</span>.list[i]) &#123;</div><div class="line">minNum = <span class="keyword">this</span>.list[i];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> minNum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;(); <span class="comment">// 实例化并且指定泛型T</span></div><div class="line"></div><div class="line">m.add(<span class="number">2</span>);</div><div class="line">m.add(<span class="number">22</span>);</div><div class="line">m.add(<span class="number">13</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(m.min());</div></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>第一种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&#123;</div><div class="line">&lt;T&gt;(value: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getData: Config = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">"张三"</span>);</div></pre></td></tr></table></figure><p>第二种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&lt;T&gt;&#123;</div><div class="line">(value: T): T</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myGetData: Config&lt;sting&gt; = getData;</div><div class="line">myGetData(<span class="string">'20'</span>)</div></pre></td></tr></table></figure><p>类当作参数验证</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MysqlDb&lt;T&gt; &#123;</div><div class="line">add(info:T): <span class="built_in">boolean</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(info);</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ArticleCate &#123;</div><div class="line">title: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">desc: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">status: <span class="built_in">number</span> | <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">constructor</span>(<span class="params">params: &#123;</span></div><div class="line"><span class="params">title: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      desc: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      status: <span class="built_in">number</span> | <span class="literal">undefined</span></span></div><div class="line"><span class="params">&#125;</span>) &#123;</div><div class="line"><span class="keyword">this</span>.title = params.title;</div><div class="line"><span class="keyword">this</span>.desc = params.desc;</div><div class="line"><span class="keyword">this</span>.status = params.status;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ArticleCate(&#123;</div><div class="line">title: <span class="string">"genli"</span>,</div><div class="line">desc: <span class="string">"111"</span>,</div><div class="line">status: <span class="number">1</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> Db = <span class="keyword">new</span> MysqlDb&lt;ArticleCate&gt;();</div><div class="line">Db.add(a);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/av54470911/?p=1" target="_blank" rel="external">6小时快速上手typescript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/05/typescript-g/typescript_var_logo.png&quot; alt=&quot;typescript_var_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;定义方法中参数的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&lt;span class=&quot;string&quot;&gt;&quot;sss&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自定义方法传入参数对json的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;labelInfo: &amp;#123; label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &amp;#125;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&amp;#123; label: &lt;span class=&quot;string&quot;&gt;&quot;ssss&quot;&lt;/span&gt; &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（一）</title>
    <link href="https://mah93.github.io/2019/06/17/golang-study-1/"/>
    <id>https://mah93.github.io/2019/06/17/golang-study-1/</id>
    <published>2019-06-17T09:19:51.000Z</published>
    <updated>2019-06-17T09:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/17/golang-study-1/go_log.png" alt="go_log.png" title=""><h2 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h2><p>安装包下载地址为：<a href="https://golang.org/dl/。" target="_blank" rel="external">https://golang.org/dl/。</a></p><p>如果打不开可以使用这个地址：<a href="https://golang.google.cn/dl/。" target="_blank" rel="external">https://golang.google.cn/dl/。</a></p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a> <h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，<code>testing</code>框架和其他语言中的测试框架类似。</p><p>Go中的单元测试有以下几个要求</p><ul><li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li><li>你必须import <code>testing</code>这个包</li><li>所有的测试用例函数必须是<code>Test</code>开头</li></ul><p>通过<code>go test</code>来执行改目录下所有的单元测试，或者是通过<code>go test -v</code>来输出测试代码中的详细信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> test或者是<span class="keyword">go</span> test -v</div></pre></td></tr></table></figure><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>在go中通过var关键字创建变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 类型声明在变量后面, go可以类型推断</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">2</span></div><div class="line"><span class="comment">// 或者是</span></div><div class="line"><span class="keyword">var</span>(</div><div class="line">  a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">  b <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">)</div><div class="line"><span class="comment">// 或者是</span></div><div class="line">a: = <span class="number">1</span></div><div class="line">b: = <span class="number">1</span></div></pre></td></tr></table></figure><p>在go中内置了很多的方法，比如变量数值的交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a,b = b,a</div></pre></td></tr></table></figure><h3 id="常量的初始化"><a href="#常量的初始化" class="headerlink" title="常量的初始化"></a>常量的初始化</h3><p>常量的初始化可以通过自增来简化代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Monday = <span class="literal">iota</span> + <span class="number">1</span></div><div class="line">Tuesday</div><div class="line">Wdnesday</div><div class="line">)</div></pre></td></tr></table></figure><p>或者是通过位移操作符，区分常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Readable = <span class="number">1</span>&lt;&lt;<span class="literal">iota</span></div><div class="line">Writeable </div><div class="line">Executable</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>go中包含了基础的数据类型，如<code>int</code> 、<code>string</code>等</p><ul><li>go语言中不允许隐式类型转换</li><li>即便是别名的隐式类型转换，也是不被允许的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=a</div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=(<span class="keyword">int64</span>)a</div><div class="line"></div><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = b</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = MyInt(b)</div></pre></td></tr></table></figure><h3 id="内置数值"><a href="#内置数值" class="headerlink" title="内置数值"></a>内置数值</h3><ul><li>math.MaxInt64</li><li>math.MaxFloat64</li><li>math.MaxUnit32</li></ul><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><ul><li>不支持指针运算</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>go中没有前置++</p><p>在数组的比较中，go的<code>==</code>会比较数组的值</p><h3 id="amp-按位置零"><a href="#amp-按位置零" class="headerlink" title="&amp;^按位置零"></a>&amp;^按位置零</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">0</span> -- <span class="number">1</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">0 </span>&amp;^ <span class="number">0</span> -- <span class="number">0</span></div></pre></td></tr></table></figure><p>右边的数值为1则整个为0，右边数值为0的时候，取左边的值</p><h2 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>go语言仅仅支持循环关键字<code>for</code></p><p>实现while条件循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无限循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> a := <span class="number">1</span> == <span class="number">1</span>; a &#123;</div><div class="line"><span class="comment">// 初始赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="switch条件"><a href="#switch条件" class="headerlink" title="switch条件"></a>switch条件</h3><p>在go中不需要加break</p><p>可以在<code>case</code>中命中多个条件</p><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a [<span class="number">3</span>]<span class="built_in">int</span> <span class="comment">//声明并初始化为默认值</span></div><div class="line">a[<span class="number">0</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">b := [<span class="number">3</span>]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">c := [<span class="number">2</span>][<span class="number">2</span>]<span class="built_in">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</div><div class="line">可以通过[...]省略数组长度</div><div class="line"></div><div class="line">d := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>通过for循环访问数组下标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</div><div class="line">t.Log(arr1[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过for-in循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> arr1&#123;</div><div class="line">t.Log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>_</code>表示占位，并不关心该数组的<code>index</code>值</p><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>数组的快速截取，即数组[开始的索引位置，结束的索引位置]</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">a[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">//2</span></div><div class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//2,3</span></div><div class="line">a[<span class="number">1</span>:len(a)] <span class="comment">// 2,3,4,5</span></div><div class="line">a[<span class="number">1</span>:]<span class="comment">// 2,3,4,5</span></div><div class="line">a[:<span class="number">3</span>]<span class="comment">// 1,2,3</span></div></pre></td></tr></table></figure><blockquote><p>go语言不支持负数截取</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><img src="/2019/06/17/golang-study-1/go_slice@2x.png" alt="go_slice@2x.png" title=""><p>其中，ptr指向一片连续的存储空间，len表示改切片存储的元素个数，cap表示改切片的容量。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s0 []<span class="built_in">int</span></div><div class="line">s0 = append(s0, <span class="number">1</span>)</div><div class="line"></div><div class="line">s := []<span class="built_in">int</span>&#123;&#125;</div><div class="line">s1 := []&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line"></div><div class="line">s2 := make([]<span class="built_in">int</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// make函数表示声明一个切片，切片默认声明2个元素为初始零值，改切片的容量为4</span></div><div class="line"><span class="comment">// 未初始化的元素不可访问</span></div></pre></td></tr></table></figure><blockquote><p>切片的容量成倍增长</p><p>切片容量是在增长的，扩容时存储空间不够时会创建一片新的内存空间。所以切片的append操作会重新返回一个新的切片</p></blockquote><h3 id="切片共享存储空间"><a href="#切片共享存储空间" class="headerlink" title="切片共享存储空间"></a>切片共享存储空间</h3><img src="/2019/06/17/golang-study-1/go_slice_mer@2x.png" alt="go_slice_mer@2x.png" title=""><p>对于从同一个切片中截取的切片而言，他们共用同一片内存空间！他们的容量从起始位指向原切片的末尾。</p><blockquote><p>对于切片而言不可以通过<code>==</code>进行比较</p></blockquote><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ul><li><a href="https://time.geekbang.org/course/intro/160" target="_blank" rel="external">Go语言从入门到实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/17/golang-study-1/go_log.png&quot; alt=&quot;go_log.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;安装下载&quot;&gt;&lt;a href=&quot;#安装下载&quot; class=&quot;headerlink&quot; title=&quot;安装下载&quot;&gt;&lt;/a&gt;安装下载&lt;/h2&gt;&lt;p&gt;安装包下载地址为：&lt;a href=&quot;https://golang.org/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.org/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果打不开可以使用这个地址：&lt;a href=&quot;https://golang.google.cn/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.google.cn/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="https://mah93.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mah93.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>TypeSript简介</title>
    <link href="https://mah93.github.io/2019/05/30/typescript-mooc/"/>
    <id>https://mah93.github.io/2019/05/30/typescript-mooc/</id>
    <published>2019-05-30T03:48:30.000Z</published>
    <updated>2019-07-05T08:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/30/typescript-mooc/typescript_intro.jpeg" alt="typescript_intro.jpeg" title=""><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>可以在变量的后面用冒号来指定该参数的类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> myname: string = <span class="string">"hello"</span></div><div class="line">myname = <span class="number">0</span> <span class="comment">// 提示类型错误</span></div><div class="line"></div><div class="line"><span class="comment">// typescript有类型推断</span></div><div class="line"><span class="selector-tag">var</span> myage = <span class="string">"xixi"</span></div><div class="line">myage = <span class="number">13</span> <span class="comment">// 提示类型错误</span></div></pre></td></tr></table></figure><a id="more"></a> <p>不仅可以在变量后面指定类型，还可以在方法后以及方法需要的参数后面</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(name: string)</span>: string </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在类中定义参数类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span> &#123;</div><div class="line"><span class="attribute">name</span>: string;</div><div class="line"><span class="attribute">age</span>: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>给参数一个默认值</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname: <span class="keyword">string</span> = <span class="string">"hello world"</span></div></pre></td></tr></table></figure><p>给方法中的参数指定一个默认值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test(<span class="selector-tag">a</span>: string, <span class="selector-tag">b</span>: string = <span class="string">"jojo"</span>) &#123;</div><div class="line"><span class="comment">// 可以只传a值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>带默认值的参数要放到函数的最后面</p></blockquote><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p> 通过问号为函数指定一个可选参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">test</span><span class="params">(a: <span class="built_in">string</span>, b?: <span class="built_in">string</span>, c: <span class="built_in">string</span> = <span class="string">"jojo"</span>)</span> </span>&#123;</div><div class="line"><span class="comment">// </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>可选参数必须放在必传参数后面</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="拓展参数"><a href="#拓展参数" class="headerlink" title="拓展参数"></a>拓展参数</h3><p>通过拓展运算符为函数添加一个参数集</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">args.forEach()</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>该函数可以接受任意数量的参数</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="built_in">console</span>.log(c)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">test(...list);</div><div class="line"><span class="comment">// 只会输出1，2，3</span></div><div class="line"><span class="comment">// 因为test方法只能接受三个参数</span></div></pre></td></tr></table></figure><h3 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h3><p>通过*来声明一个generator函数</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function * doSomething() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">'start'</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">yield<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'finish'</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">doSomething</span><span class="params">()</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">start</span></span></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">finish</span></span></div></pre></td></tr></table></figure><blockquote><p>在每次调用next()方法后，程序执行到yield就停止</p></blockquote><h3 id="析构表达式"><a href="#析构表达式" class="headerlink" title="析构表达式"></a>析构表达式</h3><p>通过表达式将对象或数组拆解成任意数量的变量</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getStock() &#123;</div><div class="line">return &#123;</div><div class="line"><span class="selector-tag">code</span>: <span class="string">'IBM'</span>,</div><div class="line">price: <span class="number">100</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">var</span> &#123;<span class="selector-tag">code</span>, price&#125; = getStock()</div></pre></td></tr></table></figure><blockquote><p>变量名称需要一一对应</p><p>可以通过冒号给对象里面的修改名称</p><p>var {code: codex, price} = getStock()</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">array</span>1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">var [a, b] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2</span></div><div class="line">var [ , , , d] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// d = 4</span></div><div class="line">var [a, b, ...others] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2, others = [3, 4]</span></div></pre></td></tr></table></figure><h2 id="表达式以及循环"><a href="#表达式以及循环" class="headerlink" title="表达式以及循环"></a>表达式以及循环</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4, 5]</div><div class="line">array.filter(value =&gt; value%2 == 0)</div></pre></td></tr></table></figure><h3 id="forEach-、for-in-和-for-of"><a href="#forEach-、for-in-和-for-of" class="headerlink" title="forEach()、for in 和 for of"></a>forEach()、for in 和 for of</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4];</div><div class="line">array.desc = <span class="string">"array"</span>;</div><div class="line"></div><div class="line">array.forEach(value = &gt; console.log(value));</div><div class="line">// 不允许break，循环对象的值</div><div class="line">// 1， 2， 3， 4</div><div class="line"></div><div class="line">for(var n in array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 循环对象属性名称</div><div class="line">// 1， 2， 3， 4， array</div><div class="line"></div><div class="line">for(var n of array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 忽略属性，可以通过break跳出循环</div><div class="line">// 1， 2， 3， 4</div></pre></td></tr></table></figure><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>访问控制符</p><p>public共有的，在类内部外部均可以使用，默认</p><p>private私有的，在类的内部使用</p><p>protected保护的，类以及其子类中可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">name;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"eat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">"batman"</span>;</div><div class="line">p1.eat();</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">p2.name = <span class="string">"superman"</span>;</div><div class="line">p2.eat();</div></pre></td></tr></table></figure><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>通过super关键字调用父类的方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">constructor() &#123;</div><div class="line"><span class="keyword">super</span>(); <span class="comment">// 调用父类的构造函数</span></div><div class="line">console.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>通过&lt;&gt;来指定数据结构存储的内容类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> work: <span class="keyword">Array</span>&lt;Person&gt; = [];</div></pre></td></tr></table></figure><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>用来建立某种代码约定，使得其他开发者在调用某个方法或者创建新的类时必须遵循接口所定义的代码约定</p><p>通过interface关键字声明一个接口<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> IPerson &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person() &#123;</div><div class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> config: IPerson</span>) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过implements关键字使类实现接口中的方法</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat();</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat grass"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat meat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型定义文件（-d-ts）"><a href="#类型定义文件（-d-ts）" class="headerlink" title="类型定义文件（*.d.ts）"></a>类型定义文件（*.d.ts）</h3><p>通过该文件类型，可以与js其他的模块协同工作</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.imooc.com/learn/763" target="_blank" rel="external">TypeScript入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/05/30/typescript-mooc/typescript_intro.jpeg&quot; alt=&quot;typescript_intro.jpeg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;h3 id=&quot;参数类型&quot;&gt;&lt;a href=&quot;#参数类型&quot; class=&quot;headerlink&quot; title=&quot;参数类型&quot;&gt;&lt;/a&gt;参数类型&lt;/h3&gt;&lt;p&gt;可以在变量的后面用冒号来指定该参数的类型&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myname: string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myname = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// typescript有类型推断&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myage = &lt;span class=&quot;string&quot;&gt;&quot;xixi&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myage = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Flutter简介以及环境配置</title>
    <link href="https://mah93.github.io/2019/04/03/flutter-introduce/"/>
    <id>https://mah93.github.io/2019/04/03/flutter-introduce/</id>
    <published>2019-04-03T03:17:04.000Z</published>
    <updated>2019-04-03T03:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/03/flutter-introduce/flutter_intro.png" alt="flutter_intro.png" title=""><h2 id="App跨平台方案"><a href="#App跨平台方案" class="headerlink" title="App跨平台方案"></a>App跨平台方案</h2><h3 id="Hybrid框架"><a href="#Hybrid框架" class="headerlink" title="Hybrid框架"></a>Hybrid框架</h3><p>Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。</p><p>由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：</p><img src="/2019/04/03/flutter-introduce/flutter_hybrid.png" alt="flutter_hybrid.png" title=""><a id="more"></a> <h3 id="响应式视图"><a href="#响应式视图" class="headerlink" title="响应式视图"></a>响应式视图</h3><p>像ReactJS或其他的响应式编程框架已经变得很流行了，主要是因为他们通过使用从响应式编程中借用的编程模式来简化 Web 视图的创建过程。2015 年， React Native 将响应式视图的许多优势带给了移动应用程序。React Native 是非常受欢迎的（这是它应得的），但是因为 JavaScript 访问了原生 UI 组件，所以它也必须经过这些“桥接器”，界面上的 UI 控件通常被频繁地访问（在动画、转化或者用户用手指“滑动”屏幕上的某些东西时，每秒被访问高达 60 次），因此这很可能会导致性能问题。</p><img src="/2019/04/03/flutter-introduce/flutter_react.png" alt="flutter_react.png" title=""><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>和 React Native 一样，Flutter 也提供响应式的视图，Flutter 采用不同的方法避免由 JavaScript 桥接器引起的性能问题，即用名为 Dart 的程序语言来编译。Dart 是用预编译的方式编译多个平台的原生代码，这允许 Flutter 直接与平台通信，而不需要通过执行上下文切换的 JavaScript 桥接器。编译为原生代码也可以加快应用程序的启动时间。</p><img src="/2019/04/03/flutter-introduce/flutter_frame.png" alt="flutter_frame.png" title=""><h2 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的<strong>原生用户</strong>界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。简单来说，Flutter是一款移动应用程序SDK，包含框架、控件和一些工具，可以用一套代码同时构建Android和iOS应用，并且性能可以达到原生应用一样的性能。详情请参考<a href="https://flutter.io/" target="_blank" rel="external">Flutter简介</a> 。</p><ul><li>快速开发：毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</li><li>富有表现力和灵活的UI：快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</li><li>原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里仅以在Mac下搭建为例，在其它系统上配置环境请参考<a href="https://flutter.dev/docs/get-started/install" target="_blank" rel="external">flutter 官网</a></p><h3 id="获取Flutter-SDK"><a href="#获取Flutter-SDK" class="headerlink" title="获取Flutter SDK"></a>获取Flutter SDK</h3><ol><li><p>去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="external">转到下载页</a> 。</p><p>注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="external">转到下载页</a> 。</p></li><li><p>解压安装包到你想安装的目录，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/development</div><div class="line">unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</div></pre></td></tr></table></figure></li><li><p>添加<code>flutter</code>相关工具到path中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=`pwd`/flutter/bin:$PATH</div></pre></td></tr></table></figure></li></ol><blockquote><p> 由于一些<code>flutter</code>命令需要联网获取数据，如果您是在国内访问，直接访问很可能不会成功。可以使用以下镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">PUB_HOSTED_URL</span>=https://pub.flutter-io.cn</div><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">FLUTTER_STORAGE_BASE_URL</span>=https://storage.flutter-io.cn</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>注意：</strong> 此镜像为临时镜像，并不能保证一直可用，可以参考详情请参考 <a href="https://github.com/flutter/flutter/wiki/Using-Flutter-in-China" target="_blank" rel="external">Using Flutter in China</a> 以获得有关镜像服务器的最新动态。</p></blockquote><h3 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h3><p>您在命令行只能更新当前会话的PATH变量，如<a href="https://flutterchina.club/setup-macos/#clone-the-repo" target="_blank" rel="external">Clone Flutter repo</a>所示。 但是，您可能需要的是永久更新此变量，以便您可以运行<code>flutter</code>命令在任何终端会话中。</p><p>对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如</p><ol><li>确定您Flutter SDK的目录，您将在步骤3中用到。</li><li>打开(或创建) <code>$HOME/.bash_profile</code>. 文件路径和文件名可能在您的机器上不同.</li><li>添加以下行并更改<code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code>为克隆Flutter的git repo的路径:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置</div><div class="line">export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH</div></pre></td></tr></table></figure><blockquote><p>注意：<code>PATH_TO_FLUTTER_GIT_DIRECTORY</code> 为你flutter的路径，比如“~/document/code”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=~/document/code/flutter/bin:$PATH</div></pre></td></tr></table></figure><ol><li>运行 <code>source $HOME/.bash_profile</code> 刷新当前终端窗口.</li></ol><blockquote><p><strong>注意:</strong> 如果你使用的是zsh，终端启动时 <code>~/.bash_profile</code> 将不会被加载，解决办法就是修改 <code>~/.zshrc</code> ，在其中添加：source ~/.bash_profile</p></blockquote><ol><li>通过运行<code>flutter/bin</code>命令验证目录是否在已经在PATH中:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div></pre></td></tr></table></figure><h3 id="安装iOS环境以及Android环境"><a href="#安装iOS环境以及Android环境" class="headerlink" title="安装iOS环境以及Android环境"></a>安装iOS环境以及Android环境</h3><p>安装Xcode以及Android Studio，详情参考<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="external">平台配置</a></p><h3 id="检查flutter环境"><a href="#检查flutter环境" class="headerlink" title="检查flutter环境"></a>检查flutter环境</h3><p>以上步骤完成之后，运行<code>flutter doctor</code>检查环境是否配置成功</p><img src="/2019/04/03/flutter-introduce/flutter_doctor.png" alt="flutter_doctor.png" title=""><p>遇到任何的错误，请按照命令行提示执行</p><h3 id="运行flutter"><a href="#运行flutter" class="headerlink" title="运行flutter"></a>运行flutter</h3><p>通过<code>flutter create myapp</code>命令创建一个flutter 初始项目，通过命令行进入该项目<code>cd myapp</code>，连接好手机设备之后，通过<code>flutter run</code>命令运行app</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">flutter</span> <span class="string">create myapp</span></div><div class="line"><span class="attr">cd</span> <span class="string">myapp</span></div><div class="line"><span class="attr">flutter</span> <span class="string">run</span></div></pre></td></tr></table></figure><p>运行成功之后，可以在app中看到如下页面，通过修改<code>lib/main.dart</code>文件来创建自己的应用</p><img src="/2019/04/03/flutter-introduce/flutter_hello.gif" alt="flutter_hello.gif" title=""><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flutterchina.club/" target="_blank" rel="external">Flutter中文网</a></li><li><a href="https://www.infoq.cn/article/why-is-flutter-revolutionary" target="_blank" rel="external">为什么说 Flutter 是革命性的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_intro.png&quot; alt=&quot;flutter_intro.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;App跨平台方案&quot;&gt;&lt;a href=&quot;#App跨平台方案&quot; class=&quot;headerlink&quot; title=&quot;App跨平台方案&quot;&gt;&lt;/a&gt;App跨平台方案&lt;/h2&gt;&lt;h3 id=&quot;Hybrid框架&quot;&gt;&lt;a href=&quot;#Hybrid框架&quot; class=&quot;headerlink&quot; title=&quot;Hybrid框架&quot;&gt;&lt;/a&gt;Hybrid框架&lt;/h3&gt;&lt;p&gt;Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。&lt;/p&gt;
&lt;p&gt;由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：&lt;/p&gt;
&lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_hybrid.png&quot; alt=&quot;flutter_hybrid.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://mah93.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://mah93.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks小笔记</title>
    <link href="https://mah93.github.io/2019/03/26/react-hooks/"/>
    <id>https://mah93.github.io/2019/03/26/react-hooks/</id>
    <published>2019-03-26T04:43:55.000Z</published>
    <updated>2019-03-26T04:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/26/react-hooks/react-hook.png" alt="react-hook.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，它主要目的是为了解决<strong>状态共享</strong>的问题。是继 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html" target="_blank" rel="external">render-props</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html" target="_blank" rel="external">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p><ol><li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li><li>Hooks 可以引用其他 Hooks。</li><li>更容易将组件的 UI 与状态分离。</li></ol><blockquote><p> 在react-native的0.59.0中，即可支持react hooks的写法。</p></blockquote><a id="more"></a> <h2 id="使用react-hooks创建组件"><a href="#使用react-hooks创建组件" class="headerlink" title="使用react hooks创建组件"></a>使用react hooks创建组件</h2><p>在react native中创建一个组件大概如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      number: <span class="number">0</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">componentDidMount() &#123;</div><div class="line"><span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnMount() &#123;</div><div class="line"> <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentWillReceiveProps(nextProps: <span class="type">Props</span>) &#123;</div><div class="line"><span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">    &lt;<span class="type">View</span>&gt;</div><div class="line">    &lt;<span class="type">Text</span> onPress=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; numer: <span class="keyword">this</span>.state.number + <span class="number">1</span> &#125;)&#125;&gt;</div><div class="line">        &#123;<span class="keyword">this</span>.state.number&#125;</div><div class="line">    &lt;/<span class="type">Text</span>&gt;</div><div class="line">    &lt;/<span class="type">View</span>&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而使用react hooks</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">&#125;</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;, [number]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; setNumber(number + <span class="number">1</span>)&#125;&gt;</div><div class="line">      &#123;number&#125;</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由上述例子可见，使用了react hooks之后，组件由class变成了function。变得更加的轻量级，尤其是在创建无状态组件的时候，使用hooks更加具有优势，代码量减少。</p><h2 id="Hooks-API-Reference"><a href="#Hooks-API-Reference" class="headerlink" title="Hooks API Reference"></a>Hooks API Reference</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; useState &#125; <span class="keyword">from</span> 'react';</div><div class="line">const [<span class="keyword">state</span>, <span class="built_in">set</span>State] = useState(initialState);</div></pre></td></tr></table></figure><p>useState是可以看作是state与setState的替换，它返回有状态值，以及更新它的函数。在初始渲染期间，返回的状态（状态）与作为第一个参数（initialState）传递的值相同。而setState函数用于更新状态。 它接受一个新的状态值并将组件重新渲染。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setState(<span class="keyword">new</span><span class="type">State</span>);</div></pre></td></tr></table></figure><p>在后续重新渲染期间，useState返回的第一个值将始终是应用更新后的最新状态。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line">useEffect(didUpdate);</div></pre></td></tr></table></figure><p>useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。那么他就可以用来代替componentDidMount、componentWillReceiveProps以及componentWillUnmount三个生命周期。而且还支持第二个值来指定某些值作为useEffect的触发条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Clean up the subscription</span></div><div class="line">    subscription.unsubscribe();</div><div class="line">  &#125;;</div><div class="line">&#125;, []);</div></pre></td></tr></table></figure><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">value</span> = useContext(MyContext);</div></pre></td></tr></table></figure><p>接受上下文对象（从React.createContext返回的值）并返回该上下文的当前上下文值。 当前上下文值由树中调用组件上方最近的<mycontext.provider>的值prop确定。</mycontext.provider></p><p>当组件上方最近的<mycontext.provider>更新时，此Hook将触发重新呈现，并将最新的上下文值传递给该MyContext提供程序。</mycontext.provider></p><blockquote><p>useContext的参数必须是上下文对象本身</p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>可以使用这个hook来实现一个redux机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</div><div class="line">      <span class="keyword">return</span> init(action.payload);</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(</div><div class="line">    reducer,</div><div class="line">    &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">      &lt;Text&gt;Count: &#123;state.count&#125;&lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/</span>Text&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: <span class="number">0</span>&#125;)&#125;&gt;</div><div class="line">        Reset</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="其它Hooks"><a href="#其它Hooks" class="headerlink" title="其它Hooks"></a>其它Hooks</h3><p>除了以上提及的hooks，react还内置了其它的hooks，详情请参考<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="external">精读《React Hooks》</a></p></li><li><p><a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/26/react-hooks/react-hook.png&quot; alt=&quot;react-hook.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;React Hooks 是 React &lt;code&gt;16.7.0-alpha&lt;/code&gt; 版本推出的新特性，它主要目的是为了解决&lt;strong&gt;状态共享&lt;/strong&gt;的问题。是继 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;render-props&lt;/a&gt; 和 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;higher-order components&lt;/a&gt; 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。&lt;/p&gt;
&lt;p&gt;React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。&lt;/li&gt;
&lt;li&gt;Hooks 可以引用其他 Hooks。&lt;/li&gt;
&lt;li&gt;更容易将组件的 UI 与状态分离。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt; 在react-native的0.59.0中，即可支持react hooks的写法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-native模版</title>
    <link href="https://mah93.github.io/2019/03/19/react-native-template/"/>
    <id>https://mah93.github.io/2019/03/19/react-native-template/</id>
    <published>2019-03-19T11:45:18.000Z</published>
    <updated>2019-03-19T11:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版</p><p>hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。</p><h3 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h3><p>通过如下命令创建模版工程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template AAA</div></pre></td></tr></table></figure><p>其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"react-native-template-AAA"</span>,<span class="comment">//上传 NPM 仓库的名称</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.0.2"</span><span class="comment">//版本号，同一仓库不可以上传两次同版本号的内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后就可以上传至<a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>上。注册完账号之后在命令行中登录</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><p>之后进入你的模版工程目录发布即可</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm publish --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><a id="more"></a> <h3 id="react-native-template-mah简介"><a href="#react-native-template-mah简介" class="headerlink" title="react-native-template-mah简介"></a>react-native-template-mah简介</h3><p>这是一个关于react-native的模版，用于新项目的初始化或者是作为RN的练习项目</p><p>该模版集成了RN常用的第三方组件，如react-navigation、netinfo等，采用mobx作为数据管理。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>新建项目的时候使用如下命令</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template mah</div></pre></td></tr></table></figure><p>其中XXX为项目的名称可以随便填写，后面mah即指定为以<code>react-native-template-mah</code>为模版新建项目。命令执行完成之后，进入项目根目录</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd XXX</div><div class="line"><span class="built_in">npm</span> install</div><div class="line">react-<span class="keyword">native</span> run-ios &amp;&amp; react-<span class="keyword">native</span> run-android</div></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── src</div><div class="line">|   ├── app.js         <span class="string">//</span> app 配置文件</div><div class="line">|   ├── compenents     <span class="string">//</span> 组件</div><div class="line">|   ├── constant       <span class="string">//</span> 常量</div><div class="line">|   ├── image          <span class="string">//</span> 图片资源</div><div class="line">|   ├── mobx           <span class="string">//</span> mobx逻辑处理</div><div class="line">|   ├── pages          <span class="string">//</span> 页面文件</div><div class="line">|   └── untils         <span class="string">//</span> 常用工具</div><div class="line">├── index.js           <span class="string">//</span> app 入口文件</div><div class="line">├── <span class="string">.eslintrc.js</span>       <span class="string">//</span> eslint配置文件</div><div class="line">├── <span class="string">.prettierrc.js</span>     <span class="string">//</span> prettier配置文件</div><div class="line">└── <span class="string">.flowconfig.js</span>     <span class="string">//</span> flow配置文件</div></pre></td></tr></table></figure><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p>该模版采用mobx作为数据管理工具，在App.js中提供了Provider方法以方便子组件通过inject的方式注入。inject的方式一般用于注入配置之类的数据，对于具体每个页面中的store还是推荐import引入并初始化的方式。一个页面对应一个store管理，对于页面来说需要有一个类似container的父组件调节组件与数据之间的关系，而其子组件使用纯函数创建以确保组件的复用性。</p><p>关于mobx的具体的使用方法请参照<a href="https://cn.mobx.js.org/" target="_blank" rel="external">mobx官网</a></p><h4 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h4><p>react-navigation 3.x与之前的版本有些许不同，但常用的方法依旧是StackNavigation和TabNavigation。通过react-navigation组织页面关系，将所有的跳转配置以及页面配置都在app_router.js下。这种集中的处理方式，为后续维护带来很大的便利。</p><blockquote><p>在自己的项目中引入react-navigation，如果报错的话请查看是否已经安装react-native-gesture-handler</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; npm install --save react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt; react-<span class="keyword">native</span> link react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>模版中采用了axios作为请求工具，具体方法可查看<a href="https://github.com/axios/axios" target="_blank" rel="external">axios的github</a>。在untils/request.js中简单的封装了post和get请求，通过Promise的方式返回数据。</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul><li><p>引入了eslint和prettier作为代码规范的检查</p></li><li><p>引入flow做参数类型检查</p></li><li>实现了换肤功能，为了展示inject的用法</li><li>定义了一些简单的常量，如屏幕宽高</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/b11c134cfa6f" target="_blank" rel="external">《React Native高效开发》之 template</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/a&gt;模版&lt;/h3&gt;&lt;p&gt;项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版&lt;/p&gt;
&lt;p&gt;hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。&lt;/p&gt;
&lt;h3 id=&quot;创建模版&quot;&gt;&lt;a href=&quot;#创建模版&quot; class=&quot;headerlink&quot; title=&quot;创建模版&quot;&gt;&lt;/a&gt;创建模版&lt;/h3&gt;&lt;p&gt;通过如下命令创建模版工程&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;react-&lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; XXX --template AAA&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号&lt;/p&gt;
&lt;figure class=&quot;highlight 1c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;react-native-template-AAA&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//上传 NPM 仓库的名称&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;0.0.2&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//版本号，同一仓库不可以上传两次同版本号的内容&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后就可以上传至&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm官网&lt;/a&gt;上。注册完账号之后在命令行中登录&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm adduser --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后进入你的模版工程目录发布即可&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm publish --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Redux初体验</title>
    <link href="https://mah93.github.io/2019/03/13/redux-learning/"/>
    <id>https://mah93.github.io/2019/03/13/redux-learning/</id>
    <published>2019-03-13T11:29:01.000Z</published>
    <updated>2019-03-13T11:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/13/redux-learning/redux-logo.png" alt="redux-logo.png" title=""><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。</p><h3 id="为什么要用状态管理"><a href="#为什么要用状态管理" class="headerlink" title="为什么要用状态管理"></a>为什么要用状态管理</h3><p>在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。</p><p>setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？</p><a id="more"></a> <p>首先，setState并不能保证是一个同步的方法，有可能是同步的，也有可能是异步的。它是一个合成法方法，后续会调用一系列的方法来完成组件重新渲染，关于setState的问题详情可以看<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">这里</a>。总之，state的状态并不是可以预测的。其次，在实际的生产中，复杂的页面会导致render下的DOM结构非常复杂，会包含一百到几百行的JSX代码。假如这个时候去改变其中某一个button的选中状态，本意是只改动button这个组件，其他的组件保持当前状态不动。当调用setState的时候，它并不会智能的仅仅改变button的状态，而是重新渲染整个庞大的DOM树。虽然React在Virtual DOM做了优化，但这种大规模的无用渲染仍然会影响应用性能。当然有解决的方法，就是将大组件拆分，分成很多的小组件，然后在shouldComponentUpdate中去做优化。关于shouldComponentUpdate相关优化问题可以参考<a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">这里</a>。还有的话就是，state数据与JSX混杂在同一个页面，耦合高十分不方便维护。一般来说页面的UI、逻辑、网络请求分开来写，既方便维护，代码逻辑也很清楚。</p><p>上述的问题只是本人在React-Native上实践遇到的，如果有任何错误，请及时通知我。</p><h3 id="Redux思想"><a href="#Redux思想" class="headerlink" title="Redux思想"></a>Redux思想</h3><p>既然在state以及setState实践上遇到了问题，那么Redux是如何解决这些问题的呢？先来看看Redux的核心概念：Action、Reducer和Store。Store中存储了数据state，state这个对象就像 “Model”，区别是它并没有 setter（修改器方法），因此其它的代码不能随意修改它，造成难以复现的 bug。Action 就是一个普通 JavaScript 对象它是用来描述发生了什么。为了把 action 和 state 串起来，开发一些函数，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 以上差不多就是Redux的全部思想了，Store、Action、Reducer各司其职配合工作。</p><p>在这里还要强调Redux中的三个原则：单一数据源、State 是只读的、使用纯函数来执行修改。</p><ol><li>单一数据源：<strong>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</strong></li><li>State 是只读的：<strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></li><li>使用纯函数来执行修改：<strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></li></ol><h3 id="在React-Native中使用"><a href="#在React-Native中使用" class="headerlink" title="在React-Native中使用"></a>在React-Native中使用</h3><p>既然已经了解了Redux的基础概念，那么就在React-Native中使用它，才能进一步理解Redux是如何运作的。使用Redux实现一个简单的计数器。</p><img src="/2019/03/13/redux-learning/redux-count.png" alt="redux-count.png" title=""><p>就是这样的一个简单的例子，点击➕号数字加一，点击➖数字减一。当然在这里是可以用setState来实现的，为了学习Redux还是将它按照Redux的规范来编写。</p><p>首先要先引入redux，在项目的根目录执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux</span></div></pre></td></tr></table></figure><h4 id="构建UI"><a href="#构建UI" class="headerlink" title="构建UI"></a>构建UI</h4><p>首先我们先构建出这个UI页面，只要是接触过React-Native。那么是很容易实现的，大致的代码是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export default class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, addNumber, inNumber &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;0&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 加一&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UI出现了，那么就差点击事件的处理了。</p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>这里我们需要发起一个事件，在这里点击的时候要让数字加一，所以首先要构建一个Action描述一个这个事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// action</div><div class="line">export const addNumber = number =&gt; (&#123;</div><div class="line">  type: &apos;INCREMENT&apos;,</div><div class="line">  number</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>type相当于key，作为Action的一个标识，注意这里的type是不可以有重复的，保证其唯一性。还接受了一个参数number，就是点击的时候，要在当前的number基础上加一。</p><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>上面的Action仅仅表示了要发生的事情，并没有描述这个事情该怎么做。Reducer的功能就是去具体的实现state的变化，在这里就是承担了加一这个事情。记住，Reducer是一个纯函数，它接收state和action作为参数，并且返回一个新的state。也即是(state, action) =&gt; newState。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// reducer</div><div class="line">export default function changeNumber(state=0, action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">    case &apos;INCREMENT&apos;:</div><div class="line">      return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">        number: action.number + 1</div><div class="line">      &#125;);</div><div class="line">  default:</div><div class="line">  return state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还记得之前的Action设置的type吗？在Reducer中它作为区分不同的Action的一个标识，Reduce通过不同的type可以处理很多的Action。注意到Reducer返回了一个新的对象，虽然只改变了state中的一个字段。这里是通过Object.assign方法来实现的，也可以使用ES6中的{..state, number: action.number + 1}来完成这一操作。</p><p>现在完成了➕事件的处理，就差把onPress事件和Action连接起来了。</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>在一个应用中只存在一个store，为了方便所有子组件访问该store，一般来说会在顶层组件中提供Provider组件，以便于子组件可以通过props的方式访问到store，可以自己实现一个Provider，一般的情况使用的是第三方组件react-redux。在项目的根目录中引用该组件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save react-redux</span></div></pre></td></tr></table></figure><p>在项目的入口文件中，用Provider将UI组件包裹起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Provider&gt;</div><div class="line">&lt;Count /&gt;</div><div class="line">&lt;/Provider&gt;</div></pre></td></tr></table></figure><p>这里还有没将store传入Provider中，首先要创建一个store，通过Redux提供的createStore方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line">import rootReducer from &apos;./src/reducers/index&apos;;</div><div class="line"></div><div class="line">export default class App extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const store = createStore(rootReducer);</div><div class="line">    return (</div><div class="line">      &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Count /&gt;</div><div class="line">      &lt;/Provider&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>createStore方法接受一个Reducer，将刚才写的Reducer传入其中即可完成一个store创建。下面就是将store与UI关联起来。在最开始写完的UI页面中加入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</div><div class="line">import &#123; addNumber &#125; from &apos;./actions/countAction&apos;</div><div class="line"></div><div class="line">type Props = &#123;&#125;;</div><div class="line">class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, plus &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;&#123;number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; plus(number)&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapStateToProps(state)&#123;</div><div class="line">return &#123;</div><div class="line">number: state.number,</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapDispatchToProps(dispatch)&#123;</div><div class="line">  return &#123;</div><div class="line">    plus: id =&gt; &#123;</div><div class="line">      dispatch(addNumber(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(mapStateToProps,mapDispatchToProps)(Count);</div></pre></td></tr></table></figure><p>主要是通过connect这个方法将store中的state以及action都传递给UI页面，可以通过props的方式访问store。在mapStateToProps以及mapDispatchToProps中定义参数名称以方便使用。完成以上所有代码之后，即可尝试运行代码，点击➕是否可以正常显示，减法和加法是同样的流程，这里并不做说明。</p><p>到这里就完成了一个由Redux构建的应用，可以看到为了实现一个方法的调用，做了很多的工作，从Action到Reducer再到state然后在渲染页面。可以说Redux的实现十分的繁琐，所以在具体的生产环节中，一定要思考清楚到底需不需要Redux，这里也有<a href="https://www.redux.org.cn/docs/faq/General.html" target="_blank" rel="external">何时使用Redux</a>的说明以供参考。</p><h4 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h4><p>关于Redux的中间件了解的并不多，这里只做简单的介绍。中间件实现的即是在Action与Reducer中间做一些操作的功能。比如，需要一个异步请求、需要调试每一次Actions执行的时候打印日志。这些都可以使用中间件完成。比如常用的redux-thunk、redux-logger等等。如果还是不知道中间件是做什么的，那么在项目中引用redux-logger</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux-logger</span></div></pre></td></tr></table></figure><p>完成之后，在创建store的时候将中间件添加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import logger from &apos;redux-logger&apos;;</div><div class="line">const store = createStore(rootReducer, applyMiddleware(logger));</div></pre></td></tr></table></figure><p>之后打开React-Native的调试页面，点击➕即可发现，控制台会自动的打印出相关的state信息，并不需要在代码中添加console.log操作，确实是极大的方便了调试。</p><img src="/2019/03/13/redux-learning/redux-logger.png" alt="redux-logger.png" title=""><p>redux-thunk主要是用来实现异步操作，比如网络请求之类的场景这里就不一一做尝试了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于Redux我了解也不是很多，只能做一些简单的demo。在上述例子中并没有介绍Redux其他的应用技巧，在后续的学习中，逐步了解这些技巧的原理后再做记录。Redux确实在开发流程上做出了很多的规范，无论它是否真的适合生产中应用，都是只得学习它的思想的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.redux.org.cn" target="_blank" rel="external">redux中文网</a></p></li><li><p><a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">你真的理解setState吗？</a></p></li><li><a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/13/redux-learning/redux-logo.png&quot; alt=&quot;redux-logo.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。&lt;/p&gt;
&lt;h3 id=&quot;为什么要用状态管理&quot;&gt;&lt;a href=&quot;#为什么要用状态管理&quot; class=&quot;headerlink&quot; title=&quot;为什么要用状态管理&quot;&gt;&lt;/a&gt;为什么要用状态管理&lt;/h3&gt;&lt;p&gt;在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。&lt;/p&gt;
&lt;p&gt;setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="https://mah93.github.io/tags/Redux/"/>
    
  </entry>
  
</feed>
