<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mah93</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mah93.github.io/"/>
  <updated>2019-07-19T09:21:30.750Z</updated>
  <id>https://mah93.github.io/</id>
  
  <author>
    <name>mah93</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js单链表实现</title>
    <link href="https://mah93.github.io/2019/07/19/js-linked/"/>
    <id>https://mah93.github.io/2019/07/19/js-linked/</id>
    <published>2019-07-19T09:17:28.000Z</published>
    <updated>2019-07-19T09:21:30.750Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/19/js-linked/js_linked_logo.jpg" alt="js_linked_logo.jpg" title=""><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><h2 id="与数组的区别"><a href="#与数组的区别" class="headerlink" title="与数组的区别"></a>与数组的区别</h2><p>​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><a id="more"></a> <h2 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>链表的基本存储结构就是一个个的节点，首先先创建一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// val表示该节点上存储的值</span></div><div class="line"><span class="comment">// next表示该节点的下一个节点</span></div><div class="line"><span class="comment">// 一般的单向链表的尾节点指向null</span></div></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>一般链表的第一个节点为head，用来表示这是一个链表存储，在创建链表的时候我们为链表的第一个节点默认设置为head</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们就实现了一个最简单的链表。仿照数组的操作，之后我们为链表添加上基本的增删改查功能。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>为了方便链表操作，首先要记录一下链表的长度。在操作链表的时候记得相应的增减。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">+    <span class="keyword">this</span>.length = <span class="number">0</span>; <span class="comment">// 链表默认的长度为0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><p>在操作链表之前，先能看到链表的样子，方便后续的测试。只需要遍历一下链表，按照自己喜欢的格式打印出链表即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ok～现在已经得到了一个链表了，现在测试一下这个链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line">testLink.display();  <span class="comment">// 打印这个链表</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;tail<br>链表长度为：0</p></blockquote><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>向链表的尾部添加一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.add = add; <span class="comment">// 添加节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++; <span class="comment">// 链表变长了1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3</p></blockquote><h3 id="查找指定节点"><a href="#查找指定节点" class="headerlink" title="查找指定节点"></a>查找指定节点</h3><p>查找指定节点所在链表中的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// // 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div></pre></td></tr></table></figure><blockquote><p>apple是该链表的第2个节点<br>该链表中不存在这个节点</p></blockquote><h3 id="向指定节点后添加一个节点"><a href="#向指定节点后添加一个节点" class="headerlink" title="向指定节点后添加一个节点"></a>向指定节点后添加一个节点</h3><p>首先先要找到指定的节点，若没有查找这个节点则插入失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div></pre></td></tr></table></figure><blockquote><p>插入成功<br>该链表中不存在这个节点<br>插入失败：不存在该节点</p></blockquote><h3 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length --; <span class="comment">// 链表变短了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div><div class="line"></div><div class="line"><span class="comment">// 删除一个节点</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3<br>head-&gt;first-&gt;ball-&gt;tail<br>链表长度为：2</p></blockquote><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表node节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找给定节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 插入</span></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 删除</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="[https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8](https://baike.baidu.com/item/链表">百度百科-链表</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/19/js-linked/js_linked_logo.jpg&quot; alt=&quot;js_linked_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。&lt;/p&gt;
&lt;h2 id=&quot;与数组的区别&quot;&gt;&lt;a href=&quot;#与数组的区别&quot; class=&quot;headerlink&quot; title=&quot;与数组的区别&quot;&gt;&lt;/a&gt;与数组的区别&lt;/h2&gt;&lt;p&gt;​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="数据结构" scheme="https://mah93.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript接口与泛型</title>
    <link href="https://mah93.github.io/2019/07/05/typescript-g/"/>
    <id>https://mah93.github.io/2019/07/05/typescript-g/</id>
    <published>2019-07-05T08:23:13.000Z</published>
    <updated>2019-07-05T08:26:41.788Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/05/typescript-g/typescript_var_logo.png" alt="typescript_var_logo.png" title=""><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义方法中参数的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">label: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(<span class="string">"sss"</span>);</div></pre></td></tr></table></figure><p>自定义方法传入参数对json的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelInfo: &#123; label: <span class="built_in">string</span> &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(&#123; label: <span class="string">"ssss"</span> &#125;);</div></pre></td></tr></table></figure><a id="more"></a> <p>接口：行为和动作的规范，对批量方法进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义接口</span></div><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现接口</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="可选属性接口"><a href="#可选属性接口" class="headerlink" title="可选属性接口"></a>可选属性接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">age?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><p>加密的函数类型接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> encrypt &#123;</div><div class="line">(key: <span class="built_in">string</span>, value: <span class="built_in">string</span>): <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> md5:encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> key + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">md5(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</div></pre></td></tr></table></figure><h2 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h2><p>对数组的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserArray &#123;</div><div class="line">[index: <span class="built_in">number</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserArray = [<span class="string">"111"</span>, <span class="string">"222"</span>]</div></pre></td></tr></table></figure><p>对对象的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserObj &#123;</div><div class="line">[index: <span class="built_in">string</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserObj = &#123;name: <span class="string">"20"</span>&#125;</div></pre></td></tr></table></figure><p>对类的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">eat(str: <span class="built_in">string</span>): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"小黑"</span>)</div><div class="line">dog.eat();</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat(food: <span class="built_in">string</span>) &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"小花"</span>)</div><div class="line">cat.eat(<span class="string">"猫粮"</span>);</div></pre></td></tr></table></figure><h2 id="接口的继承与拓展"><a href="#接口的继承与拓展" class="headerlink" title="接口的继承与拓展"></a>接口的继承与拓展</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">eat(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</div><div class="line">work(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Programmer &#123;</div><div class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">coding(code: <span class="built_in">string</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  Web类继承Programmer类并且实现Person接口</span></div><div class="line"><span class="keyword">class</span> Web <span class="keyword">extends</span> Programmer <span class="keyword">implements</span> Person &#123;</div><div class="line"><span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">work() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"work"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>接受string类型的参数，并且返回string类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是要同时返回时string和number，就造成了代码冗余</p><p>使用any类型解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是any放弃了类型检查，会丢失掉参数类型。实际的需求时，传入什么类型的数据，就要返回什么类型的数据。</p><p>泛型：可以支持不确定的数据类型，要求：传入的参数和返回的类型一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="number">123</span>); <span class="comment">// error</span></div></pre></td></tr></table></figure><blockquote><p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 <code>T</code>、<code>U</code>、<code>V</code> 表示。如果在你的参数里，不止拥有一个泛型，你应该使用一个更语义化名称，如 <code>TKey</code> 和 <code>TValue</code> （通常情况下，以 <code>T</code> 做为泛型前缀也在如 C++ 的其他语言里做为模版。）</p></blockquote><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>返回数组中最小的值，同时支持number类型以及string类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MinClass&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span> list: T[] = [];</div><div class="line">add(value: T): <span class="built_in">void</span> &#123;</div><div class="line"><span class="keyword">this</span>.list.push(value);</div><div class="line">&#125;</div><div class="line">min(): T &#123;</div><div class="line"><span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</div><div class="line"><span class="keyword">if</span>(minNum &gt; <span class="keyword">this</span>.list[i]) &#123;</div><div class="line">minNum = <span class="keyword">this</span>.list[i];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> minNum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;(); <span class="comment">// 实例化并且指定泛型T</span></div><div class="line"></div><div class="line">m.add(<span class="number">2</span>);</div><div class="line">m.add(<span class="number">22</span>);</div><div class="line">m.add(<span class="number">13</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(m.min());</div></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>第一种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&#123;</div><div class="line">&lt;T&gt;(value: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getData: Config = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">"张三"</span>);</div></pre></td></tr></table></figure><p>第二种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&lt;T&gt;&#123;</div><div class="line">(value: T): T</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myGetData: Config&lt;sting&gt; = getData;</div><div class="line">myGetData(<span class="string">'20'</span>)</div></pre></td></tr></table></figure><p>类当作参数验证</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MysqlDb&lt;T&gt; &#123;</div><div class="line">add(info:T): <span class="built_in">boolean</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(info);</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ArticleCate &#123;</div><div class="line">title: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">desc: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">status: <span class="built_in">number</span> | <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">constructor</span>(<span class="params">params: &#123;</span></div><div class="line"><span class="params">title: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      desc: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      status: <span class="built_in">number</span> | <span class="literal">undefined</span></span></div><div class="line"><span class="params">&#125;</span>) &#123;</div><div class="line"><span class="keyword">this</span>.title = params.title;</div><div class="line"><span class="keyword">this</span>.desc = params.desc;</div><div class="line"><span class="keyword">this</span>.status = params.status;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ArticleCate(&#123;</div><div class="line">title: <span class="string">"genli"</span>,</div><div class="line">desc: <span class="string">"111"</span>,</div><div class="line">status: <span class="number">1</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> Db = <span class="keyword">new</span> MysqlDb&lt;ArticleCate&gt;();</div><div class="line">Db.add(a);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/av54470911/?p=1" target="_blank" rel="external">6小时快速上手typescript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/05/typescript-g/typescript_var_logo.png&quot; alt=&quot;typescript_var_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;定义方法中参数的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&lt;span class=&quot;string&quot;&gt;&quot;sss&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自定义方法传入参数对json的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;labelInfo: &amp;#123; label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &amp;#125;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&amp;#123; label: &lt;span class=&quot;string&quot;&gt;&quot;ssss&quot;&lt;/span&gt; &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（一）</title>
    <link href="https://mah93.github.io/2019/06/17/golang-study-1/"/>
    <id>https://mah93.github.io/2019/06/17/golang-study-1/</id>
    <published>2019-06-17T09:19:51.000Z</published>
    <updated>2019-06-17T09:22:08.022Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/17/golang-study-1/go_log.png" alt="go_log.png" title=""><h2 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h2><p>安装包下载地址为：<a href="https://golang.org/dl/。" target="_blank" rel="external">https://golang.org/dl/。</a></p><p>如果打不开可以使用这个地址：<a href="https://golang.google.cn/dl/。" target="_blank" rel="external">https://golang.google.cn/dl/。</a></p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a> <h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，<code>testing</code>框架和其他语言中的测试框架类似。</p><p>Go中的单元测试有以下几个要求</p><ul><li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li><li>你必须import <code>testing</code>这个包</li><li>所有的测试用例函数必须是<code>Test</code>开头</li></ul><p>通过<code>go test</code>来执行改目录下所有的单元测试，或者是通过<code>go test -v</code>来输出测试代码中的详细信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> test或者是<span class="keyword">go</span> test -v</div></pre></td></tr></table></figure><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>在go中通过var关键字创建变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 类型声明在变量后面, go可以类型推断</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">2</span></div><div class="line"><span class="comment">// 或者是</span></div><div class="line"><span class="keyword">var</span>(</div><div class="line">  a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">  b <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">)</div><div class="line"><span class="comment">// 或者是</span></div><div class="line">a: = <span class="number">1</span></div><div class="line">b: = <span class="number">1</span></div></pre></td></tr></table></figure><p>在go中内置了很多的方法，比如变量数值的交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a,b = b,a</div></pre></td></tr></table></figure><h3 id="常量的初始化"><a href="#常量的初始化" class="headerlink" title="常量的初始化"></a>常量的初始化</h3><p>常量的初始化可以通过自增来简化代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Monday = <span class="literal">iota</span> + <span class="number">1</span></div><div class="line">Tuesday</div><div class="line">Wdnesday</div><div class="line">)</div></pre></td></tr></table></figure><p>或者是通过位移操作符，区分常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Readable = <span class="number">1</span>&lt;&lt;<span class="literal">iota</span></div><div class="line">Writeable </div><div class="line">Executable</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>go中包含了基础的数据类型，如<code>int</code> 、<code>string</code>等</p><ul><li>go语言中不允许隐式类型转换</li><li>即便是别名的隐式类型转换，也是不被允许的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=a</div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=(<span class="keyword">int64</span>)a</div><div class="line"></div><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = b</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = MyInt(b)</div></pre></td></tr></table></figure><h3 id="内置数值"><a href="#内置数值" class="headerlink" title="内置数值"></a>内置数值</h3><ul><li>math.MaxInt64</li><li>math.MaxFloat64</li><li>math.MaxUnit32</li></ul><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><ul><li>不支持指针运算</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>go中没有前置++</p><p>在数组的比较中，go的<code>==</code>会比较数组的值</p><h3 id="amp-按位置零"><a href="#amp-按位置零" class="headerlink" title="&amp;^按位置零"></a>&amp;^按位置零</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">0</span> -- <span class="number">1</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">0 </span>&amp;^ <span class="number">0</span> -- <span class="number">0</span></div></pre></td></tr></table></figure><p>右边的数值为1则整个为0，右边数值为0的时候，取左边的值</p><h2 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>go语言仅仅支持循环关键字<code>for</code></p><p>实现while条件循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无限循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> a := <span class="number">1</span> == <span class="number">1</span>; a &#123;</div><div class="line"><span class="comment">// 初始赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="switch条件"><a href="#switch条件" class="headerlink" title="switch条件"></a>switch条件</h3><p>在go中不需要加break</p><p>可以在<code>case</code>中命中多个条件</p><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a [<span class="number">3</span>]<span class="built_in">int</span> <span class="comment">//声明并初始化为默认值</span></div><div class="line">a[<span class="number">0</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">b := [<span class="number">3</span>]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">c := [<span class="number">2</span>][<span class="number">2</span>]<span class="built_in">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</div><div class="line">可以通过[...]省略数组长度</div><div class="line"></div><div class="line">d := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>通过for循环访问数组下标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</div><div class="line">t.Log(arr1[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过for-in循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> arr1&#123;</div><div class="line">t.Log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>_</code>表示占位，并不关心该数组的<code>index</code>值</p><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>数组的快速截取，即数组[开始的索引位置，结束的索引位置]</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">a[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">//2</span></div><div class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//2,3</span></div><div class="line">a[<span class="number">1</span>:len(a)] <span class="comment">// 2,3,4,5</span></div><div class="line">a[<span class="number">1</span>:]<span class="comment">// 2,3,4,5</span></div><div class="line">a[:<span class="number">3</span>]<span class="comment">// 1,2,3</span></div></pre></td></tr></table></figure><blockquote><p>go语言不支持负数截取</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><img src="/2019/06/17/golang-study-1/go_slice@2x.png" alt="go_slice@2x.png" title=""><p>其中，ptr指向一片连续的存储空间，len表示改切片存储的元素个数，cap表示改切片的容量。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s0 []<span class="built_in">int</span></div><div class="line">s0 = append(s0, <span class="number">1</span>)</div><div class="line"></div><div class="line">s := []<span class="built_in">int</span>&#123;&#125;</div><div class="line">s1 := []&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line"></div><div class="line">s2 := make([]<span class="built_in">int</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// make函数表示声明一个切片，切片默认声明2个元素为初始零值，改切片的容量为4</span></div><div class="line"><span class="comment">// 未初始化的元素不可访问</span></div></pre></td></tr></table></figure><blockquote><p>切片的容量成倍增长</p><p>切片容量是在增长的，扩容时存储空间不够时会创建一片新的内存空间。所以切片的append操作会重新返回一个新的切片</p></blockquote><h3 id="切片共享存储空间"><a href="#切片共享存储空间" class="headerlink" title="切片共享存储空间"></a>切片共享存储空间</h3><img src="/2019/06/17/golang-study-1/go_slice_mer@2x.png" alt="go_slice_mer@2x.png" title=""><p>对于从同一个切片中截取的切片而言，他们共用同一片内存空间！他们的容量从起始位指向原切片的末尾。</p><blockquote><p>对于切片而言不可以通过<code>==</code>进行比较</p></blockquote><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ul><li><a href="https://time.geekbang.org/course/intro/160" target="_blank" rel="external">Go语言从入门到实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/17/golang-study-1/go_log.png&quot; alt=&quot;go_log.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;安装下载&quot;&gt;&lt;a href=&quot;#安装下载&quot; class=&quot;headerlink&quot; title=&quot;安装下载&quot;&gt;&lt;/a&gt;安装下载&lt;/h2&gt;&lt;p&gt;安装包下载地址为：&lt;a href=&quot;https://golang.org/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.org/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果打不开可以使用这个地址：&lt;a href=&quot;https://golang.google.cn/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.google.cn/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="https://mah93.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mah93.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>TypeSript简介</title>
    <link href="https://mah93.github.io/2019/05/30/typescript-mooc/"/>
    <id>https://mah93.github.io/2019/05/30/typescript-mooc/</id>
    <published>2019-05-30T03:48:30.000Z</published>
    <updated>2019-07-05T08:23:39.113Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/30/typescript-mooc/typescript_intro.jpeg" alt="typescript_intro.jpeg" title=""><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>可以在变量的后面用冒号来指定该参数的类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> myname: string = <span class="string">"hello"</span></div><div class="line">myname = <span class="number">0</span> <span class="comment">// 提示类型错误</span></div><div class="line"></div><div class="line"><span class="comment">// typescript有类型推断</span></div><div class="line"><span class="selector-tag">var</span> myage = <span class="string">"xixi"</span></div><div class="line">myage = <span class="number">13</span> <span class="comment">// 提示类型错误</span></div></pre></td></tr></table></figure><a id="more"></a> <p>不仅可以在变量后面指定类型，还可以在方法后以及方法需要的参数后面</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(name: string)</span>: string </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在类中定义参数类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span> &#123;</div><div class="line"><span class="attribute">name</span>: string;</div><div class="line"><span class="attribute">age</span>: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>给参数一个默认值</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname: <span class="keyword">string</span> = <span class="string">"hello world"</span></div></pre></td></tr></table></figure><p>给方法中的参数指定一个默认值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test(<span class="selector-tag">a</span>: string, <span class="selector-tag">b</span>: string = <span class="string">"jojo"</span>) &#123;</div><div class="line"><span class="comment">// 可以只传a值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>带默认值的参数要放到函数的最后面</p></blockquote><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p> 通过问号为函数指定一个可选参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">test</span><span class="params">(a: <span class="built_in">string</span>, b?: <span class="built_in">string</span>, c: <span class="built_in">string</span> = <span class="string">"jojo"</span>)</span> </span>&#123;</div><div class="line"><span class="comment">// </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>可选参数必须放在必传参数后面</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="拓展参数"><a href="#拓展参数" class="headerlink" title="拓展参数"></a>拓展参数</h3><p>通过拓展运算符为函数添加一个参数集</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">args.forEach()</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>该函数可以接受任意数量的参数</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="built_in">console</span>.log(c)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">test(...list);</div><div class="line"><span class="comment">// 只会输出1，2，3</span></div><div class="line"><span class="comment">// 因为test方法只能接受三个参数</span></div></pre></td></tr></table></figure><h3 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h3><p>通过*来声明一个generator函数</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function * doSomething() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">'start'</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">yield<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'finish'</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">doSomething</span><span class="params">()</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">start</span></span></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">finish</span></span></div></pre></td></tr></table></figure><blockquote><p>在每次调用next()方法后，程序执行到yield就停止</p></blockquote><h3 id="析构表达式"><a href="#析构表达式" class="headerlink" title="析构表达式"></a>析构表达式</h3><p>通过表达式将对象或数组拆解成任意数量的变量</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getStock() &#123;</div><div class="line">return &#123;</div><div class="line"><span class="selector-tag">code</span>: <span class="string">'IBM'</span>,</div><div class="line">price: <span class="number">100</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">var</span> &#123;<span class="selector-tag">code</span>, price&#125; = getStock()</div></pre></td></tr></table></figure><blockquote><p>变量名称需要一一对应</p><p>可以通过冒号给对象里面的修改名称</p><p>var {code: codex, price} = getStock()</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">array</span>1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">var [a, b] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2</span></div><div class="line">var [ , , , d] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// d = 4</span></div><div class="line">var [a, b, ...others] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2, others = [3, 4]</span></div></pre></td></tr></table></figure><h2 id="表达式以及循环"><a href="#表达式以及循环" class="headerlink" title="表达式以及循环"></a>表达式以及循环</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4, 5]</div><div class="line">array.filter(value =&gt; value%2 == 0)</div></pre></td></tr></table></figure><h3 id="forEach-、for-in-和-for-of"><a href="#forEach-、for-in-和-for-of" class="headerlink" title="forEach()、for in 和 for of"></a>forEach()、for in 和 for of</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4];</div><div class="line">array.desc = <span class="string">"array"</span>;</div><div class="line"></div><div class="line">array.forEach(value = &gt; console.log(value));</div><div class="line">// 不允许break，循环对象的值</div><div class="line">// 1， 2， 3， 4</div><div class="line"></div><div class="line">for(var n in array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 循环对象属性名称</div><div class="line">// 1， 2， 3， 4， array</div><div class="line"></div><div class="line">for(var n of array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 忽略属性，可以通过break跳出循环</div><div class="line">// 1， 2， 3， 4</div></pre></td></tr></table></figure><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>访问控制符</p><p>public共有的，在类内部外部均可以使用，默认</p><p>private私有的，在类的内部使用</p><p>protected保护的，类以及其子类中可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">name;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"eat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">"batman"</span>;</div><div class="line">p1.eat();</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">p2.name = <span class="string">"superman"</span>;</div><div class="line">p2.eat();</div></pre></td></tr></table></figure><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>通过super关键字调用父类的方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">constructor() &#123;</div><div class="line"><span class="keyword">super</span>(); <span class="comment">// 调用父类的构造函数</span></div><div class="line">console.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>通过&lt;&gt;来指定数据结构存储的内容类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> work: <span class="keyword">Array</span>&lt;Person&gt; = [];</div></pre></td></tr></table></figure><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>用来建立某种代码约定，使得其他开发者在调用某个方法或者创建新的类时必须遵循接口所定义的代码约定</p><p>通过interface关键字声明一个接口<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> IPerson &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person() &#123;</div><div class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> config: IPerson</span>) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过implements关键字使类实现接口中的方法</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat();</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat grass"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat meat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型定义文件（-d-ts）"><a href="#类型定义文件（-d-ts）" class="headerlink" title="类型定义文件（*.d.ts）"></a>类型定义文件（*.d.ts）</h3><p>通过该文件类型，可以与js其他的模块协同工作</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.imooc.com/learn/763" target="_blank" rel="external">TypeScript入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/05/30/typescript-mooc/typescript_intro.jpeg&quot; alt=&quot;typescript_intro.jpeg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;h3 id=&quot;参数类型&quot;&gt;&lt;a href=&quot;#参数类型&quot; class=&quot;headerlink&quot; title=&quot;参数类型&quot;&gt;&lt;/a&gt;参数类型&lt;/h3&gt;&lt;p&gt;可以在变量的后面用冒号来指定该参数的类型&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myname: string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myname = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// typescript有类型推断&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myage = &lt;span class=&quot;string&quot;&gt;&quot;xixi&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myage = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Flutter简介以及环境配置</title>
    <link href="https://mah93.github.io/2019/04/03/flutter-introduce/"/>
    <id>https://mah93.github.io/2019/04/03/flutter-introduce/</id>
    <published>2019-04-03T03:17:04.000Z</published>
    <updated>2019-04-03T03:20:45.215Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/03/flutter-introduce/flutter_intro.png" alt="flutter_intro.png" title=""><h2 id="App跨平台方案"><a href="#App跨平台方案" class="headerlink" title="App跨平台方案"></a>App跨平台方案</h2><h3 id="Hybrid框架"><a href="#Hybrid框架" class="headerlink" title="Hybrid框架"></a>Hybrid框架</h3><p>Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。</p><p>由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：</p><img src="/2019/04/03/flutter-introduce/flutter_hybrid.png" alt="flutter_hybrid.png" title=""><a id="more"></a> <h3 id="响应式视图"><a href="#响应式视图" class="headerlink" title="响应式视图"></a>响应式视图</h3><p>像ReactJS或其他的响应式编程框架已经变得很流行了，主要是因为他们通过使用从响应式编程中借用的编程模式来简化 Web 视图的创建过程。2015 年， React Native 将响应式视图的许多优势带给了移动应用程序。React Native 是非常受欢迎的（这是它应得的），但是因为 JavaScript 访问了原生 UI 组件，所以它也必须经过这些“桥接器”，界面上的 UI 控件通常被频繁地访问（在动画、转化或者用户用手指“滑动”屏幕上的某些东西时，每秒被访问高达 60 次），因此这很可能会导致性能问题。</p><img src="/2019/04/03/flutter-introduce/flutter_react.png" alt="flutter_react.png" title=""><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>和 React Native 一样，Flutter 也提供响应式的视图，Flutter 采用不同的方法避免由 JavaScript 桥接器引起的性能问题，即用名为 Dart 的程序语言来编译。Dart 是用预编译的方式编译多个平台的原生代码，这允许 Flutter 直接与平台通信，而不需要通过执行上下文切换的 JavaScript 桥接器。编译为原生代码也可以加快应用程序的启动时间。</p><img src="/2019/04/03/flutter-introduce/flutter_frame.png" alt="flutter_frame.png" title=""><h2 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的<strong>原生用户</strong>界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。简单来说，Flutter是一款移动应用程序SDK，包含框架、控件和一些工具，可以用一套代码同时构建Android和iOS应用，并且性能可以达到原生应用一样的性能。详情请参考<a href="https://flutter.io/" target="_blank" rel="external">Flutter简介</a> 。</p><ul><li>快速开发：毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</li><li>富有表现力和灵活的UI：快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</li><li>原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里仅以在Mac下搭建为例，在其它系统上配置环境请参考<a href="https://flutter.dev/docs/get-started/install" target="_blank" rel="external">flutter 官网</a></p><h3 id="获取Flutter-SDK"><a href="#获取Flutter-SDK" class="headerlink" title="获取Flutter SDK"></a>获取Flutter SDK</h3><ol><li><p>去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="external">转到下载页</a> 。</p><p>注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="external">转到下载页</a> 。</p></li><li><p>解压安装包到你想安装的目录，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/development</div><div class="line">unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</div></pre></td></tr></table></figure></li><li><p>添加<code>flutter</code>相关工具到path中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=`pwd`/flutter/bin:$PATH</div></pre></td></tr></table></figure></li></ol><blockquote><p> 由于一些<code>flutter</code>命令需要联网获取数据，如果您是在国内访问，直接访问很可能不会成功。可以使用以下镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">PUB_HOSTED_URL</span>=https://pub.flutter-io.cn</div><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">FLUTTER_STORAGE_BASE_URL</span>=https://storage.flutter-io.cn</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>注意：</strong> 此镜像为临时镜像，并不能保证一直可用，可以参考详情请参考 <a href="https://github.com/flutter/flutter/wiki/Using-Flutter-in-China" target="_blank" rel="external">Using Flutter in China</a> 以获得有关镜像服务器的最新动态。</p></blockquote><h3 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h3><p>您在命令行只能更新当前会话的PATH变量，如<a href="https://flutterchina.club/setup-macos/#clone-the-repo" target="_blank" rel="external">Clone Flutter repo</a>所示。 但是，您可能需要的是永久更新此变量，以便您可以运行<code>flutter</code>命令在任何终端会话中。</p><p>对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如</p><ol><li>确定您Flutter SDK的目录，您将在步骤3中用到。</li><li>打开(或创建) <code>$HOME/.bash_profile</code>. 文件路径和文件名可能在您的机器上不同.</li><li>添加以下行并更改<code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code>为克隆Flutter的git repo的路径:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置</div><div class="line">export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH</div></pre></td></tr></table></figure><blockquote><p>注意：<code>PATH_TO_FLUTTER_GIT_DIRECTORY</code> 为你flutter的路径，比如“~/document/code”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=~/document/code/flutter/bin:$PATH</div></pre></td></tr></table></figure><ol><li>运行 <code>source $HOME/.bash_profile</code> 刷新当前终端窗口.</li></ol><blockquote><p><strong>注意:</strong> 如果你使用的是zsh，终端启动时 <code>~/.bash_profile</code> 将不会被加载，解决办法就是修改 <code>~/.zshrc</code> ，在其中添加：source ~/.bash_profile</p></blockquote><ol><li>通过运行<code>flutter/bin</code>命令验证目录是否在已经在PATH中:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div></pre></td></tr></table></figure><h3 id="安装iOS环境以及Android环境"><a href="#安装iOS环境以及Android环境" class="headerlink" title="安装iOS环境以及Android环境"></a>安装iOS环境以及Android环境</h3><p>安装Xcode以及Android Studio，详情参考<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="external">平台配置</a></p><h3 id="检查flutter环境"><a href="#检查flutter环境" class="headerlink" title="检查flutter环境"></a>检查flutter环境</h3><p>以上步骤完成之后，运行<code>flutter doctor</code>检查环境是否配置成功</p><img src="/2019/04/03/flutter-introduce/flutter_doctor.png" alt="flutter_doctor.png" title=""><p>遇到任何的错误，请按照命令行提示执行</p><h3 id="运行flutter"><a href="#运行flutter" class="headerlink" title="运行flutter"></a>运行flutter</h3><p>通过<code>flutter create myapp</code>命令创建一个flutter 初始项目，通过命令行进入该项目<code>cd myapp</code>，连接好手机设备之后，通过<code>flutter run</code>命令运行app</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">flutter</span> <span class="string">create myapp</span></div><div class="line"><span class="attr">cd</span> <span class="string">myapp</span></div><div class="line"><span class="attr">flutter</span> <span class="string">run</span></div></pre></td></tr></table></figure><p>运行成功之后，可以在app中看到如下页面，通过修改<code>lib/main.dart</code>文件来创建自己的应用</p><img src="/2019/04/03/flutter-introduce/flutter_hello.gif" alt="flutter_hello.gif" title=""><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flutterchina.club/" target="_blank" rel="external">Flutter中文网</a></li><li><a href="https://www.infoq.cn/article/why-is-flutter-revolutionary" target="_blank" rel="external">为什么说 Flutter 是革命性的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_intro.png&quot; alt=&quot;flutter_intro.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;App跨平台方案&quot;&gt;&lt;a href=&quot;#App跨平台方案&quot; class=&quot;headerlink&quot; title=&quot;App跨平台方案&quot;&gt;&lt;/a&gt;App跨平台方案&lt;/h2&gt;&lt;h3 id=&quot;Hybrid框架&quot;&gt;&lt;a href=&quot;#Hybrid框架&quot; class=&quot;headerlink&quot; title=&quot;Hybrid框架&quot;&gt;&lt;/a&gt;Hybrid框架&lt;/h3&gt;&lt;p&gt;Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。&lt;/p&gt;
&lt;p&gt;由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：&lt;/p&gt;
&lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_hybrid.png&quot; alt=&quot;flutter_hybrid.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://mah93.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://mah93.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks小笔记</title>
    <link href="https://mah93.github.io/2019/03/26/react-hooks/"/>
    <id>https://mah93.github.io/2019/03/26/react-hooks/</id>
    <published>2019-03-26T04:43:55.000Z</published>
    <updated>2019-03-26T04:51:21.115Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/26/react-hooks/react-hook.png" alt="react-hook.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，它主要目的是为了解决<strong>状态共享</strong>的问题。是继 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html" target="_blank" rel="external">render-props</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html" target="_blank" rel="external">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p><ol><li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li><li>Hooks 可以引用其他 Hooks。</li><li>更容易将组件的 UI 与状态分离。</li></ol><blockquote><p> 在react-native的0.59.0中，即可支持react hooks的写法。</p></blockquote><a id="more"></a> <h2 id="使用react-hooks创建组件"><a href="#使用react-hooks创建组件" class="headerlink" title="使用react hooks创建组件"></a>使用react hooks创建组件</h2><p>在react native中创建一个组件大概如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      number: <span class="number">0</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">componentDidMount() &#123;</div><div class="line"><span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnMount() &#123;</div><div class="line"> <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentWillReceiveProps(nextProps: <span class="type">Props</span>) &#123;</div><div class="line"><span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">    &lt;<span class="type">View</span>&gt;</div><div class="line">    &lt;<span class="type">Text</span> onPress=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; numer: <span class="keyword">this</span>.state.number + <span class="number">1</span> &#125;)&#125;&gt;</div><div class="line">        &#123;<span class="keyword">this</span>.state.number&#125;</div><div class="line">    &lt;/<span class="type">Text</span>&gt;</div><div class="line">    &lt;/<span class="type">View</span>&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而使用react hooks</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">&#125;</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;, [number]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; setNumber(number + <span class="number">1</span>)&#125;&gt;</div><div class="line">      &#123;number&#125;</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由上述例子可见，使用了react hooks之后，组件由class变成了function。变得更加的轻量级，尤其是在创建无状态组件的时候，使用hooks更加具有优势，代码量减少。</p><h2 id="Hooks-API-Reference"><a href="#Hooks-API-Reference" class="headerlink" title="Hooks API Reference"></a>Hooks API Reference</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; useState &#125; <span class="keyword">from</span> 'react';</div><div class="line">const [<span class="keyword">state</span>, <span class="built_in">set</span>State] = useState(initialState);</div></pre></td></tr></table></figure><p>useState是可以看作是state与setState的替换，它返回有状态值，以及更新它的函数。在初始渲染期间，返回的状态（状态）与作为第一个参数（initialState）传递的值相同。而setState函数用于更新状态。 它接受一个新的状态值并将组件重新渲染。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setState(<span class="keyword">new</span><span class="type">State</span>);</div></pre></td></tr></table></figure><p>在后续重新渲染期间，useState返回的第一个值将始终是应用更新后的最新状态。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line">useEffect(didUpdate);</div></pre></td></tr></table></figure><p>useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。那么他就可以用来代替componentDidMount、componentWillReceiveProps以及componentWillUnmount三个生命周期。而且还支持第二个值来指定某些值作为useEffect的触发条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Clean up the subscription</span></div><div class="line">    subscription.unsubscribe();</div><div class="line">  &#125;;</div><div class="line">&#125;, []);</div></pre></td></tr></table></figure><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">value</span> = useContext(MyContext);</div></pre></td></tr></table></figure><p>接受上下文对象（从React.createContext返回的值）并返回该上下文的当前上下文值。 当前上下文值由树中调用组件上方最近的<mycontext.provider>的值prop确定。</mycontext.provider></p><p>当组件上方最近的<mycontext.provider>更新时，此Hook将触发重新呈现，并将最新的上下文值传递给该MyContext提供程序。</mycontext.provider></p><blockquote><p>useContext的参数必须是上下文对象本身</p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>可以使用这个hook来实现一个redux机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</div><div class="line">      <span class="keyword">return</span> init(action.payload);</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(</div><div class="line">    reducer,</div><div class="line">    &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">      &lt;Text&gt;Count: &#123;state.count&#125;&lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/</span>Text&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: <span class="number">0</span>&#125;)&#125;&gt;</div><div class="line">        Reset</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="其它Hooks"><a href="#其它Hooks" class="headerlink" title="其它Hooks"></a>其它Hooks</h3><p>除了以上提及的hooks，react还内置了其它的hooks，详情请参考<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="external">精读《React Hooks》</a></p></li><li><p><a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/26/react-hooks/react-hook.png&quot; alt=&quot;react-hook.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;React Hooks 是 React &lt;code&gt;16.7.0-alpha&lt;/code&gt; 版本推出的新特性，它主要目的是为了解决&lt;strong&gt;状态共享&lt;/strong&gt;的问题。是继 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;render-props&lt;/a&gt; 和 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;higher-order components&lt;/a&gt; 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。&lt;/p&gt;
&lt;p&gt;React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。&lt;/li&gt;
&lt;li&gt;Hooks 可以引用其他 Hooks。&lt;/li&gt;
&lt;li&gt;更容易将组件的 UI 与状态分离。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt; 在react-native的0.59.0中，即可支持react hooks的写法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-native模版</title>
    <link href="https://mah93.github.io/2019/03/19/react-native-template/"/>
    <id>https://mah93.github.io/2019/03/19/react-native-template/</id>
    <published>2019-03-19T11:45:18.000Z</published>
    <updated>2019-03-19T11:46:16.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版</p><p>hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。</p><h3 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h3><p>通过如下命令创建模版工程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template AAA</div></pre></td></tr></table></figure><p>其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"react-native-template-AAA"</span>,<span class="comment">//上传 NPM 仓库的名称</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.0.2"</span><span class="comment">//版本号，同一仓库不可以上传两次同版本号的内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后就可以上传至<a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>上。注册完账号之后在命令行中登录</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><p>之后进入你的模版工程目录发布即可</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm publish --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><a id="more"></a> <h3 id="react-native-template-mah简介"><a href="#react-native-template-mah简介" class="headerlink" title="react-native-template-mah简介"></a>react-native-template-mah简介</h3><p>这是一个关于react-native的模版，用于新项目的初始化或者是作为RN的练习项目</p><p>该模版集成了RN常用的第三方组件，如react-navigation、netinfo等，采用mobx作为数据管理。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>新建项目的时候使用如下命令</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template mah</div></pre></td></tr></table></figure><p>其中XXX为项目的名称可以随便填写，后面mah即指定为以<code>react-native-template-mah</code>为模版新建项目。命令执行完成之后，进入项目根目录</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd XXX</div><div class="line"><span class="built_in">npm</span> install</div><div class="line">react-<span class="keyword">native</span> run-ios &amp;&amp; react-<span class="keyword">native</span> run-android</div></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── src</div><div class="line">|   ├── app.js         <span class="string">//</span> app 配置文件</div><div class="line">|   ├── compenents     <span class="string">//</span> 组件</div><div class="line">|   ├── constant       <span class="string">//</span> 常量</div><div class="line">|   ├── image          <span class="string">//</span> 图片资源</div><div class="line">|   ├── mobx           <span class="string">//</span> mobx逻辑处理</div><div class="line">|   ├── pages          <span class="string">//</span> 页面文件</div><div class="line">|   └── untils         <span class="string">//</span> 常用工具</div><div class="line">├── index.js           <span class="string">//</span> app 入口文件</div><div class="line">├── <span class="string">.eslintrc.js</span>       <span class="string">//</span> eslint配置文件</div><div class="line">├── <span class="string">.prettierrc.js</span>     <span class="string">//</span> prettier配置文件</div><div class="line">└── <span class="string">.flowconfig.js</span>     <span class="string">//</span> flow配置文件</div></pre></td></tr></table></figure><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p>该模版采用mobx作为数据管理工具，在App.js中提供了Provider方法以方便子组件通过inject的方式注入。inject的方式一般用于注入配置之类的数据，对于具体每个页面中的store还是推荐import引入并初始化的方式。一个页面对应一个store管理，对于页面来说需要有一个类似container的父组件调节组件与数据之间的关系，而其子组件使用纯函数创建以确保组件的复用性。</p><p>关于mobx的具体的使用方法请参照<a href="https://cn.mobx.js.org/" target="_blank" rel="external">mobx官网</a></p><h4 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h4><p>react-navigation 3.x与之前的版本有些许不同，但常用的方法依旧是StackNavigation和TabNavigation。通过react-navigation组织页面关系，将所有的跳转配置以及页面配置都在app_router.js下。这种集中的处理方式，为后续维护带来很大的便利。</p><blockquote><p>在自己的项目中引入react-navigation，如果报错的话请查看是否已经安装react-native-gesture-handler</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; npm install --save react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt; react-<span class="keyword">native</span> link react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>模版中采用了axios作为请求工具，具体方法可查看<a href="https://github.com/axios/axios" target="_blank" rel="external">axios的github</a>。在untils/request.js中简单的封装了post和get请求，通过Promise的方式返回数据。</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul><li><p>引入了eslint和prettier作为代码规范的检查</p></li><li><p>引入flow做参数类型检查</p></li><li>实现了换肤功能，为了展示inject的用法</li><li>定义了一些简单的常量，如屏幕宽高</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/b11c134cfa6f" target="_blank" rel="external">《React Native高效开发》之 template</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/a&gt;模版&lt;/h3&gt;&lt;p&gt;项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版&lt;/p&gt;
&lt;p&gt;hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。&lt;/p&gt;
&lt;h3 id=&quot;创建模版&quot;&gt;&lt;a href=&quot;#创建模版&quot; class=&quot;headerlink&quot; title=&quot;创建模版&quot;&gt;&lt;/a&gt;创建模版&lt;/h3&gt;&lt;p&gt;通过如下命令创建模版工程&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;react-&lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; XXX --template AAA&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号&lt;/p&gt;
&lt;figure class=&quot;highlight 1c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;react-native-template-AAA&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//上传 NPM 仓库的名称&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;0.0.2&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//版本号，同一仓库不可以上传两次同版本号的内容&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后就可以上传至&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm官网&lt;/a&gt;上。注册完账号之后在命令行中登录&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm adduser --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后进入你的模版工程目录发布即可&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm publish --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Redux初体验</title>
    <link href="https://mah93.github.io/2019/03/13/redux-learning/"/>
    <id>https://mah93.github.io/2019/03/13/redux-learning/</id>
    <published>2019-03-13T11:29:01.000Z</published>
    <updated>2019-03-13T11:34:17.711Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/13/redux-learning/redux-logo.png" alt="redux-logo.png" title=""><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。</p><h3 id="为什么要用状态管理"><a href="#为什么要用状态管理" class="headerlink" title="为什么要用状态管理"></a>为什么要用状态管理</h3><p>在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。</p><p>setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？</p><a id="more"></a> <p>首先，setState并不能保证是一个同步的方法，有可能是同步的，也有可能是异步的。它是一个合成法方法，后续会调用一系列的方法来完成组件重新渲染，关于setState的问题详情可以看<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">这里</a>。总之，state的状态并不是可以预测的。其次，在实际的生产中，复杂的页面会导致render下的DOM结构非常复杂，会包含一百到几百行的JSX代码。假如这个时候去改变其中某一个button的选中状态，本意是只改动button这个组件，其他的组件保持当前状态不动。当调用setState的时候，它并不会智能的仅仅改变button的状态，而是重新渲染整个庞大的DOM树。虽然React在Virtual DOM做了优化，但这种大规模的无用渲染仍然会影响应用性能。当然有解决的方法，就是将大组件拆分，分成很多的小组件，然后在shouldComponentUpdate中去做优化。关于shouldComponentUpdate相关优化问题可以参考<a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">这里</a>。还有的话就是，state数据与JSX混杂在同一个页面，耦合高十分不方便维护。一般来说页面的UI、逻辑、网络请求分开来写，既方便维护，代码逻辑也很清楚。</p><p>上述的问题只是本人在React-Native上实践遇到的，如果有任何错误，请及时通知我。</p><h3 id="Redux思想"><a href="#Redux思想" class="headerlink" title="Redux思想"></a>Redux思想</h3><p>既然在state以及setState实践上遇到了问题，那么Redux是如何解决这些问题的呢？先来看看Redux的核心概念：Action、Reducer和Store。Store中存储了数据state，state这个对象就像 “Model”，区别是它并没有 setter（修改器方法），因此其它的代码不能随意修改它，造成难以复现的 bug。Action 就是一个普通 JavaScript 对象它是用来描述发生了什么。为了把 action 和 state 串起来，开发一些函数，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 以上差不多就是Redux的全部思想了，Store、Action、Reducer各司其职配合工作。</p><p>在这里还要强调Redux中的三个原则：单一数据源、State 是只读的、使用纯函数来执行修改。</p><ol><li>单一数据源：<strong>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</strong></li><li>State 是只读的：<strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></li><li>使用纯函数来执行修改：<strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></li></ol><h3 id="在React-Native中使用"><a href="#在React-Native中使用" class="headerlink" title="在React-Native中使用"></a>在React-Native中使用</h3><p>既然已经了解了Redux的基础概念，那么就在React-Native中使用它，才能进一步理解Redux是如何运作的。使用Redux实现一个简单的计数器。</p><img src="/2019/03/13/redux-learning/redux-count.png" alt="redux-count.png" title=""><p>就是这样的一个简单的例子，点击➕号数字加一，点击➖数字减一。当然在这里是可以用setState来实现的，为了学习Redux还是将它按照Redux的规范来编写。</p><p>首先要先引入redux，在项目的根目录执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux</span></div></pre></td></tr></table></figure><h4 id="构建UI"><a href="#构建UI" class="headerlink" title="构建UI"></a>构建UI</h4><p>首先我们先构建出这个UI页面，只要是接触过React-Native。那么是很容易实现的，大致的代码是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export default class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, addNumber, inNumber &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;0&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 加一&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UI出现了，那么就差点击事件的处理了。</p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>这里我们需要发起一个事件，在这里点击的时候要让数字加一，所以首先要构建一个Action描述一个这个事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// action</div><div class="line">export const addNumber = number =&gt; (&#123;</div><div class="line">  type: &apos;INCREMENT&apos;,</div><div class="line">  number</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>type相当于key，作为Action的一个标识，注意这里的type是不可以有重复的，保证其唯一性。还接受了一个参数number，就是点击的时候，要在当前的number基础上加一。</p><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>上面的Action仅仅表示了要发生的事情，并没有描述这个事情该怎么做。Reducer的功能就是去具体的实现state的变化，在这里就是承担了加一这个事情。记住，Reducer是一个纯函数，它接收state和action作为参数，并且返回一个新的state。也即是(state, action) =&gt; newState。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// reducer</div><div class="line">export default function changeNumber(state=0, action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">    case &apos;INCREMENT&apos;:</div><div class="line">      return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">        number: action.number + 1</div><div class="line">      &#125;);</div><div class="line">  default:</div><div class="line">  return state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还记得之前的Action设置的type吗？在Reducer中它作为区分不同的Action的一个标识，Reduce通过不同的type可以处理很多的Action。注意到Reducer返回了一个新的对象，虽然只改变了state中的一个字段。这里是通过Object.assign方法来实现的，也可以使用ES6中的{..state, number: action.number + 1}来完成这一操作。</p><p>现在完成了➕事件的处理，就差把onPress事件和Action连接起来了。</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>在一个应用中只存在一个store，为了方便所有子组件访问该store，一般来说会在顶层组件中提供Provider组件，以便于子组件可以通过props的方式访问到store，可以自己实现一个Provider，一般的情况使用的是第三方组件react-redux。在项目的根目录中引用该组件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save react-redux</span></div></pre></td></tr></table></figure><p>在项目的入口文件中，用Provider将UI组件包裹起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Provider&gt;</div><div class="line">&lt;Count /&gt;</div><div class="line">&lt;/Provider&gt;</div></pre></td></tr></table></figure><p>这里还有没将store传入Provider中，首先要创建一个store，通过Redux提供的createStore方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line">import rootReducer from &apos;./src/reducers/index&apos;;</div><div class="line"></div><div class="line">export default class App extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const store = createStore(rootReducer);</div><div class="line">    return (</div><div class="line">      &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Count /&gt;</div><div class="line">      &lt;/Provider&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>createStore方法接受一个Reducer，将刚才写的Reducer传入其中即可完成一个store创建。下面就是将store与UI关联起来。在最开始写完的UI页面中加入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</div><div class="line">import &#123; addNumber &#125; from &apos;./actions/countAction&apos;</div><div class="line"></div><div class="line">type Props = &#123;&#125;;</div><div class="line">class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, plus &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;&#123;number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; plus(number)&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapStateToProps(state)&#123;</div><div class="line">return &#123;</div><div class="line">number: state.number,</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapDispatchToProps(dispatch)&#123;</div><div class="line">  return &#123;</div><div class="line">    plus: id =&gt; &#123;</div><div class="line">      dispatch(addNumber(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(mapStateToProps,mapDispatchToProps)(Count);</div></pre></td></tr></table></figure><p>主要是通过connect这个方法将store中的state以及action都传递给UI页面，可以通过props的方式访问store。在mapStateToProps以及mapDispatchToProps中定义参数名称以方便使用。完成以上所有代码之后，即可尝试运行代码，点击➕是否可以正常显示，减法和加法是同样的流程，这里并不做说明。</p><p>到这里就完成了一个由Redux构建的应用，可以看到为了实现一个方法的调用，做了很多的工作，从Action到Reducer再到state然后在渲染页面。可以说Redux的实现十分的繁琐，所以在具体的生产环节中，一定要思考清楚到底需不需要Redux，这里也有<a href="https://www.redux.org.cn/docs/faq/General.html" target="_blank" rel="external">何时使用Redux</a>的说明以供参考。</p><h4 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h4><p>关于Redux的中间件了解的并不多，这里只做简单的介绍。中间件实现的即是在Action与Reducer中间做一些操作的功能。比如，需要一个异步请求、需要调试每一次Actions执行的时候打印日志。这些都可以使用中间件完成。比如常用的redux-thunk、redux-logger等等。如果还是不知道中间件是做什么的，那么在项目中引用redux-logger</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux-logger</span></div></pre></td></tr></table></figure><p>完成之后，在创建store的时候将中间件添加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import logger from &apos;redux-logger&apos;;</div><div class="line">const store = createStore(rootReducer, applyMiddleware(logger));</div></pre></td></tr></table></figure><p>之后打开React-Native的调试页面，点击➕即可发现，控制台会自动的打印出相关的state信息，并不需要在代码中添加console.log操作，确实是极大的方便了调试。</p><img src="/2019/03/13/redux-learning/redux-logger.png" alt="redux-logger.png" title=""><p>redux-thunk主要是用来实现异步操作，比如网络请求之类的场景这里就不一一做尝试了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于Redux我了解也不是很多，只能做一些简单的demo。在上述例子中并没有介绍Redux其他的应用技巧，在后续的学习中，逐步了解这些技巧的原理后再做记录。Redux确实在开发流程上做出了很多的规范，无论它是否真的适合生产中应用，都是只得学习它的思想的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.redux.org.cn" target="_blank" rel="external">redux中文网</a></p></li><li><p><a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">你真的理解setState吗？</a></p></li><li><a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/13/redux-learning/redux-logo.png&quot; alt=&quot;redux-logo.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。&lt;/p&gt;
&lt;h3 id=&quot;为什么要用状态管理&quot;&gt;&lt;a href=&quot;#为什么要用状态管理&quot; class=&quot;headerlink&quot; title=&quot;为什么要用状态管理&quot;&gt;&lt;/a&gt;为什么要用状态管理&lt;/h3&gt;&lt;p&gt;在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。&lt;/p&gt;
&lt;p&gt;setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="https://mah93.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>flow笔记</title>
    <link href="https://mah93.github.io/2019/01/04/flow-note/"/>
    <id>https://mah93.github.io/2019/01/04/flow-note/</id>
    <published>2019-01-04T04:41:21.000Z</published>
    <updated>2019-01-04T04:45:00.658Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/04/flow-note/flow-main.png" alt="flow-main.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JavaScript作为一种脚本语言是没有参数类型这个概念的，所以在编写代码的时候可以给参数赋予任何类型的值。在写JS的时候不用考虑参数类型、参数定义等等概念。当项目逐渐变大，人员逐渐变动的时候，没有任何参数类型再加上代码命名不规范，代码将变得十分难以维护。面对一个参数变量不知道它是用来做什么的。可能会有如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">main = () =&gt; &#123;</div><div class="line">   <span class="comment">//fn1函数获取了一个数据</span></div><div class="line">   <span class="keyword">var</span> <span class="class"><span class="keyword">object</span> </span>= fn1()</div><div class="line">   <span class="comment">//fn2根据获数据，产生一个结果</span></div><div class="line">   <span class="keyword">var</span> result = fn2(<span class="class"><span class="keyword">object</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">   <span class="title">return</span> <span class="title">result</span></span></div><div class="line"><span class="class">&#125;</span></div></pre></td></tr></table></figure><p>Flow是个JavaScript的静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写强类型语言相近的体验。</p><blockquote><p>由于之前是写Objective-C的，对于类型检查还是比较能接受的。虽然在编写代码的时候会繁琐一些，但是由于提前声明了参数的类型，使用起来会更加的“放心”。</p></blockquote><a id="more"></a> <hr><p>以下代码实践均在<code>react native</code>项目中实践</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> flow-bin</div></pre></td></tr></table></figure><p>创建配置文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">touch</span> <span class="selector-class">.flowconfig</span></div></pre></td></tr></table></figure><p>先不管空白的<em>.flowconfig</em>配置文件。在<em>package.json</em>文件里flow脚本。<br><strong>your project/package.json</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"flow"</span>: <span class="string">"flow; test <span class="variable">$?</span> -eq 0 -o <span class="variable">$?</span> -eq 2"</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>然后给需要flow检查的文件里加上<code>//@flow</code>或者<code>/*@flow*/</code>。然后就可以检查了。（也可以在命令中加上–all， 这样就会检查所有文件）。</p><p>在根目录下运行命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> flow</span></div></pre></td></tr></table></figure><p>以上就配置好了flow</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Flow最重要的功能就是允许在参数前添加类型注释，即规定该参数的数据类型。Flow内置了很多的数据类型，有些是给原生类型用的，像 <code>number</code> 和 <code>string</code>。 <code>any</code> 和 <code>mixed</code> 比较宽松，没有把值的类型限定死，而其他字面类型则描述某一种类型。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Flow中常用的基本数据类型有<code>number</code>、<code>string</code>、<code>boolean</code></p><blockquote><p>注意，这里的类型都是小写开头的</p></blockquote><p>他们的用法大致相同。都是在参数中声明该参数的类型，下面是一个使用<code>number</code>的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// js</div><div class="line">plus = (x, y) =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125; </div><div class="line"></div><div class="line">// @flow</div><div class="line">plus = (x: number, y: number) : number =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">plus(1, 2); // 正常返回3</div><div class="line">plus(&apos;1&apos;, 2); // 报错：Cannot call `plus` with `&apos;1&apos;` bound to `x` because string [1] is incompatible with number [2].</div><div class="line"></div><div class="line">// 可以看到使用了Flow之后，当传入了不符合预先声明的类型时Flow就会报错，当然这些错误并不影响代码的运行。</div><div class="line">// 不仅可以在定义函数的时候使用，而且可以在初始化变量的时候，就指定这个参数的类型，这和强类型语言的体验相似</div><div class="line">let number1: number = 5;</div><div class="line">let number2: number = &apos;5&apos;; // 报错</div></pre></td></tr></table></figure><h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><p>Flow中也内置了相关的复合数据类型，如<code>Array</code>、<code>Object</code>、<code>Function</code></p><blockquote><p>注意，这里的类型都是大写开头的</p></blockquote><p>他们的使用方式和基础数据类型差不多，不过<code>Array</code>在声明的时候，不仅可以声明这个参数是数组类型，还可以声明这个数组里面的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">let List1: Array&lt;number&gt; = [1];</div><div class="line">let List2: Array&lt;string&gt; = [&apos;21&apos;, &apos;22&apos;];</div><div class="line">let List3: Array&lt;boolean&gt; = [false];</div><div class="line"></div><div class="line">getFirst = (list: Array&lt;number&gt;) : number =&gt; &#123;</div><div class="line">    return list[0];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="任何数据类型"><a href="#任何数据类型" class="headerlink" title="任何数据类型"></a>任何数据类型</h4><p>当不确定一个参数的类型时，可以使用<code>mixed</code>来声明该参数，但是在使用的时候必须要判断这个参数的类型，否则Flow会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">plus = (y: mixed) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// mixed是混合类型的意思</div></pre></td></tr></table></figure><p>如果不希望这个参数被Flow检查，可以使用<code>any</code>即任意类型。如果频繁使用<code>any</code>来声明参数类型，那么Flow就没有任何意义了，尽量还是避免使用<code>any</code>。</p><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>Flow支持自定义的一些参数类型，不仅仅局限于它内置的几个。可以使用Flow轻松的实现一个枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">type myType = &apos;A&apos; | &apos;B&apos; | &apos;C&apos;;</div><div class="line">let testType: myType = &apos;A&apos;;</div><div class="line">// 定一个枚举，声明的参数如果是该枚举类型，那么它的值一定是在枚举类型中。</div></pre></td></tr></table></figure><h4 id="可选的参数类型"><a href="#可选的参数类型" class="headerlink" title="可选的参数类型"></a>可选的参数类型</h4><p>当一个参数不确定是什么类型的时候，上述的<code>mixed</code>可以实现但是并不常用，通常使用的是<code>|</code>来声明多个参数类型，或者使用<code>?</code>来代替<code>mixed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">plus = (y: ?number) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 这个?和mixed是一样的，意思是这个参数可能是number类型，当然也有可能是其他的类型。那么在使用的时候就需要对参数的类型判断</div><div class="line">// 如果参数的类型有两个，也就是说可能是number类型也可能是string类型，可以使用|来将所有的可能的参数类型列举出来</div><div class="line">plus = (y: number | string) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 和上述的一样，使用之前都需要判断参数的类型才能使用</div></pre></td></tr></table></figure><h4 id="关于-的使用"><a href="#关于-的使用" class="headerlink" title="关于?的使用"></a>关于<code>?</code>的使用</h4><p>Flow中的<code>?</code>有两种使用方法，一个是在参数前表明这个参数是可选的，另一个是在数据类型前表示可能是这个参数类型，也可能是其他的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">let number2: ?number = 43; // 意思是这个参数有可能是number类型</div><div class="line">let string2: ?string = &apos;12&apos;; </div><div class="line"></div><div class="line">plus = (x?: number, y: number) : number =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">// 这里的?意思是这个x参数可能不存在</div></pre></td></tr></table></figure><h3 id="在React-Native中使用"><a href="#在React-Native中使用" class="headerlink" title="在React Native中使用"></a>在React Native中使用</h3><p>在React Native自定义组件的时候，Flow可以用来声明其需要的属性，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">// 该组件的属性</div><div class="line">type Props = &#123;</div><div class="line">  text?: string,</div><div class="line">  pointerEvents?: boolean,</div><div class="line">  timeout?: number,</div><div class="line">  onLoadingTimeout?: Function,</div><div class="line">  offsetY?: number,</div><div class="line">&#125;;  </div><div class="line">// 组件</div><div class="line">export default class Loading extends React.Component&lt;Props&gt; &#123;</div><div class="line">  static defaultProps = &#123;</div><div class="line">    pointerEvents: false,</div><div class="line">    timeout: 0,</div><div class="line">    offsetY: 0,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在自定义组件中不仅可以定义从父组件传递的参数，还可以定义默认属性。其他的用法和上述用法是相同的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flow本质上也只是个检查工具，它并不会自动修正代码中的错误，也不会强制说你没按照它的警告消息修正，就不会让你运行程序。当然，并没有要求什么时候一定要用这类的工具，只是这种作法可以让你的代码更具强健性与提高阅读性，也可以直接避去很多不必要的数据类型使用上的问题，这种开发方式目前在许多框架与函数库项目，或是以JavaScript应用为主的开发团队中都已经都是必用工具，在React、Vue源码中均在使用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="http://www.imooc.com/article/15855" target="_blank" rel="external">Flow - JS静态类型检查工具</a></p></li><li><p><a href="https://segmentfault.com/a/1190000006983211" target="_blank" rel="external">用flow.js提升前端开发的体验</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-flow" target="_blank" rel="external">认识Flow</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/04/flow-note/flow-main.png&quot; alt=&quot;flow-main.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;JavaScript作为一种脚本语言是没有参数类型这个概念的，所以在编写代码的时候可以给参数赋予任何类型的值。在写JS的时候不用考虑参数类型、参数定义等等概念。当项目逐渐变大，人员逐渐变动的时候，没有任何参数类型再加上代码命名不规范，代码将变得十分难以维护。面对一个参数变量不知道它是用来做什么的。可能会有如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;main = () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//fn1函数获取了一个数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;/span&gt;= fn1()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//fn2根据获数据，产生一个结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = fn2(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;   &lt;span class=&quot;title&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;result&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Flow是个JavaScript的静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写强类型语言相近的体验。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于之前是写Objective-C的，对于类型检查还是比较能接受的。虽然在编写代码的时候会繁琐一些，但是由于提前声明了参数的类型，使用起来会更加的“放心”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>init new project</title>
    <link href="https://mah93.github.io/2019/01/02/new-project/"/>
    <id>https://mah93.github.io/2019/01/02/new-project/</id>
    <published>2019-01-02T03:39:46.000Z</published>
    <updated>2019-01-02T08:02:46.906Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/02/new-project/new-project.png" alt="new-project.png" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近要开始写一个新的项目，算是将之前的项目做个总结。把有缺陷的地方进行修改，没有引入的组件引入，算是做一个提炼总结，把之前没有办法修改的问题一一修正。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>我这里使用的是官方提供的<code>react-native-cli</code>即</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init newProject --version <span class="number">0.57</span><span class="number">.0</span></div></pre></td></tr></table></figure><p>新项目当然是使用最新版本了，react-native从低版本向上升级真的是痛苦。</p><p>创建完新的项目之后当然是建立目录结构，目录结构确实是对项目有很大的影响。总之结合之前的项目经验，构建了如下的目录结构，当然其他的也没有问题，这里打算使用Mobx，所以将相关Mobx逻辑代码直接命名了Mobx文件夹。</p><a id="more"></a> <img src="/2019/01/02/new-project/new-file-menu.png" alt="new-file-menu.png" title=""><p>可以是很基础的目录结构，看文件夹名字就可以知道它的功能了。</p><p>在正式开始敲代码前还需要做以下准备工作。</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>eslint是airbnb公司推出的代码规范插件，为编写代码提供标准</p><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="built_in">export</span> PKG=eslint-config-airbnb;</div><div class="line">  npm info <span class="string">"<span class="variable">$PKG</span>@latest"</span> peerDependencies --json | <span class="built_in">command</span> sed <span class="string">'s/[\&#123;\&#125;,]//g ; s/: /@/g'</span> | xargs npm install --save-dev <span class="string">"<span class="variable">$PKG</span>@latest"</span></div><div class="line"></div><div class="line">)</div></pre></td></tr></table></figure><p>还需要安装babel-eslint</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install </span><span class="keyword">babel-eslint </span>--save-dev</div></pre></td></tr></table></figure><p>创建.eslintrc文件，可以将你需要的规则写在这个文件当中。</p><p>之后在package.json中的scripts中添加eslint执行命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint"</span>: <span class="string">"eslint --ext .js src/"</span></div></pre></td></tr></table></figure><blockquote><p>这个命令即为检查src文件夹下所有的js文件，eslint的命令行参数有很多，具体可以查看<a href="https://cn.eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="external">eslint配置</a></p><p>执行npm run lint即可验证该命令是否已经正确配置，如果有任何不符合eslint的规范的地方会在命令行中提示。也可以在上述的.eslintrc文件中修改eslint内置的规则，以符合具体的场景需求。</p><p>如果希望在src文件夹内，有些文件跳过这些规则的检查，可以在根目录下创建.eslintignore文件，将路径写入其中，eslint就会自动跳过这些文件。</p></blockquote><p>至此eslint的添加、引用以及配置都已经设置完毕，配合使用的编辑器中的插件会在日常输入代码的时候提示开发者符合eslint的规范。但是各个编译器的插件功能不同，有时并不会很准确的提示。所以在命令行中执行eslint的命令才能的到真正的检查结果。</p><p>为了避免忘记执行该命令，将不规范的代码提交到远程仓库，我们引入git的hook，它会在每次commit前调用配置中的命令，利用这个hook我们在每次提交前都执行一次eslint命令确保每次提交代码的规范性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> pre-<span class="keyword">commit</span> <span class="comment">--save-dev</span></div></pre></td></tr></table></figure><blockquote><p>如果你不希望此次提交被检查，可以使用-n来跳过hook</p></blockquote><p>并在package.json中加入</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pre-commit"</span>:[</div><div class="line"><span class="string">"eslint"</span></div><div class="line">]</div></pre></td></tr></table></figure><h3 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h3><p>flow是JavaScript 代码的静态类型检查工具，它能够捕获 JavaScript 代码中的常见问题，如静态类型转换不匹配、空指针引用等问题。同时，Flow 还为 JavaScript 新增了类型语法，如类型别名。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> flow-bin</div></pre></td></tr></table></figure><p>创建配置文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">touch</span> <span class="selector-class">.flowconfig</span></div></pre></td></tr></table></figure><p>先不管空白的<em>.flowconfig</em>配置文件。在<em>package.json</em>文件里flow脚本。<br><strong>your project/package.json</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"flow"</span>: <span class="string">"flow; test <span class="variable">$?</span> -eq 0 -o <span class="variable">$?</span> -eq 2"</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>然后给需要flow检查的文件里加上<code>//@flow</code>或者<code>/*@flow*/</code>。然后就可以检查了。（也可以在命令中加上–all， 这样就会检查所有文件）。</p><p>在根目录下运行命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> flow</span></div></pre></td></tr></table></figure><p>以上就配置好了flow，下面写一个简单的小例子来说明flow是如何运行的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> plus = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">plus(<span class="number">10</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure><p>其实也就是和平常写法没什么区别，只是在定义参数的时候要添加该参数的数据类型。如果传入非法的数据类型，flow则会报错。flow在多人开发中还是十分有效果的，如果不想使用typescript，那么js+flow也是不错的选择。flow当然还有很多其他的用法，这里就不一一介绍了。</p><h3 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h3><p>上一个项目中使用的就是mobx，总体来说使用起来十分简单。对于App的流畅性也有很大的提升。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>需要的依赖关系：mobx和mobx-react</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="selector-tag">i</span> mobx mobx-react --save</div></pre></td></tr></table></figure><p>我们还需要安装一个babel插件，以便我们可以使用ES7装饰器：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="selector-tag">i</span> babel-plugin-<span class="attribute">transform</span>-decorators-legacy --save-dev</div></pre></td></tr></table></figure><p>现在，让我们创建一个.babelrc文件来配置我们的插件：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [<span class="string">"react-native"</span>],</div><div class="line">  // 主要这两句话</div><div class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>自RN 0.56版本之后，react-native默认支持bable7，之前的写法都不对了。</p><p>首先，需要安装下面的4个babel库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/core</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/plugin-proposal-decorators</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/plugin-transform-runtime</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/runtime</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>将.babelrn修改为如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   <span class="string">"presets"</span>: [<span class="string">"module:metro-react-native-babel-preset"</span>],</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   <span class="string">"plugins"</span>: [</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     [<span class="string">"@babel/transform-runtime"</span>, &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">       <span class="string">"helpers"</span>: <span class="literal">true</span>,</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">       <span class="string">"regenerator"</span>: <span class="literal">false</span></span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     &#125;]</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   ]</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h3><p>react-navigation 3.x与之前版本有较大区别</p><h4 id="安装react-navigation"><a href="#安装react-navigation" class="headerlink" title="安装react-navigation"></a>安装react-navigation</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react-navigation --save</div></pre></td></tr></table></figure><p>在新版本中新增了一个原生库<code>react-native-gesture-handler</code>如果没有安装，按如下方式安装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span> <span class="comment">--save</span></div><div class="line">react-<span class="keyword">native</span> <span class="keyword">link</span> react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div></pre></td></tr></table></figure><h4 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h4><p>之前使用的是<code>StackNavigator</code>来创建路由，在3.x中使用<code>createStackNavigator</code>并且需要由<code>createAppContainer</code>包裹起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">`react-navigation 1.x`</div><div class="line">const Navigator = StackNavigator(&#123;</div><div class="line">    Home: &#123;screen: Home&#125;</div><div class="line">&#125;,&#123;</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">export default Navigator;</div><div class="line"></div><div class="line">`react-navigation 3.x`</div><div class="line">const Navigator = createStackNavigator(&#123;</div><div class="line">    Home: &#123;screen: Home&#125;</div><div class="line">&#125;,&#123;</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">export default createAppContainer(Navigator);</div></pre></td></tr></table></figure><p>以上，同理<code>TabNavigator</code>修改为<code>createBottomTabNavigator</code></p><p>总之react-navigation 3.x与之前版本有较大出入，更多详情请看<a href="https://reactnavigation.org/" target="_blank" rel="external">react-navigation官网</a></p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>react-native中自带了<code>fetch</code>请求API，由于<code>fetch</code>中有很多功能不好实现，就选择<code>axios</code>做为网络请求库。<code>axios</code>起码可以设置请求超时时间，<code>fetch</code>的话只能使用<code>promise.race()</code>间接实现请求超时的功能。</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> axios</div></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>axios</code>和<code>fetch</code>在使用起来没有什么差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">`get请求`</div><div class="line">axios.get(&apos;/user&apos;, &#123;</div><div class="line">    params: &#123;</div><div class="line">      ID: 12345</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">`post请求`</div><div class="line">axios.post(&apos;/user&apos;, &#123;</div><div class="line">    firstName: &apos;Fred&apos;,</div><div class="line">    lastName: &apos;Flintstone&apos;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>当然<code>axios</code>还有很多配置选项，比如请求超时时间、设置请求头、配置代理、配置相应头等等，这些都可以在<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">axios中文文档</a>中查看</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新建一个项目需要多方面的考虑，这里只是写出我习惯用到的一些框架。后续肯定还有别的需求添加，但是大体上都是一些UI方面的功能性的东西，总体的项目框架已经搭建好了。这个也算是之前项目的一个总结吧。</p><p>以上</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.jianshu.com/p/dc9df5826651" target="_blank" rel="external">react-navigation使用技巧（再进阶）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/02/new-project/new-project.png&quot; alt=&quot;new-project.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近要开始写一个新的项目，算是将之前的项目做个总结。把有缺陷的地方进行修改，没有引入的组件引入，算是做一个提炼总结，把之前没有办法修改的问题一一修正。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h3&gt;&lt;p&gt;我这里使用的是官方提供的&lt;code&gt;react-native-cli&lt;/code&gt;即&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;react-native init newProject --version &lt;span class=&quot;number&quot;&gt;0.57&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新项目当然是使用最新版本了，react-native从低版本向上升级真的是痛苦。&lt;/p&gt;
&lt;p&gt;创建完新的项目之后当然是建立目录结构，目录结构确实是对项目有很大的影响。总之结合之前的项目经验，构建了如下的目录结构，当然其他的也没有问题，这里打算使用Mobx，所以将相关Mobx逻辑代码直接命名了Mobx文件夹。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>动手实现Promise</title>
    <link href="https://mah93.github.io/2018/12/24/my-promise/"/>
    <id>https://mah93.github.io/2018/12/24/my-promise/</id>
    <published>2018-12-24T08:08:35.000Z</published>
    <updated>2018-12-25T04:41:35.068Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/24/my-promise/promise2.jpg" alt="promise2.jpg" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">if(/* 一般是异步操作 */) &#123;</div><div class="line">        resolve(&apos;回调&apos;);</div><div class="line">&#125; else &#123;</div><div class="line">        reject(&apos;error&apos;);</div><div class="line">&#125; </div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((error) =&gt; &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面尝试一下自己去实现Promise的功能。</p><a id="more"></a> <h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 定一个构造函数</div><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    thenFunc = call;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    thenFunc &amp;&amp; thenFunc(value);</div><div class="line">    thenFunc = null;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>定义一个构造函数，将初始化的异步方法传入其中。在函数内部定一个变量来存储promise实例传递进来的then方法，当异步方法开始执行的时候就会在函数内部调用这个变量存储的函数，从将参数回调至promise实例中。</p><p>初始化的异步方法中，resolve参数其实是一个函数，对应到自定义的函数中就是thenCall方法，然后当resolve调用的时候，就是函数内部的用来存储then的变量执行的时候。</p><h4 id="初始化的方法不是异步的"><a href="#初始化的方法不是异步的" class="headerlink" title="初始化的方法不是异步的"></a>初始化的方法不是异步的</h4><p>如果在初始化的时候，传入的不是一个异步的函数，比如下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">resolve(&apos;ssss&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>由于执行顺序的问题，并不会回调到then方法中。可以想办法让then方法先执行，之后再执行resolve，利用Js的循环机制以及setTimeout，将resolve放入栈底执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">        thenFunc &amp;&amp; thenFunc(value);</div><div class="line">        thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>如果对于Js的循环机制和setTimeout不是很了解的话可以<a href="https://blog.csdn.net/u014346301/article/details/53897358" target="_blank" rel="external">参考这篇</a></p></blockquote><p> 这样就可以确保在有then的情况下，resolve在后面执行。</p><h4 id="promise调用时间很晚"><a href="#promise调用时间很晚" class="headerlink" title="promise调用时间很晚"></a>promise调用时间很晚</h4><p>如果初始化Promise实例之后，并没有立即使用它，而是间隔了一段时间再去调用promise的then方法，那么由于resolve已经执行完毕，所以即使是调用过了then方法也不会正确的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    promise.then((data) =&gt; &#123;</div><div class="line">    console.log(data);</div><div class="line">    &#125;).catch((err) =&gt; &#123;</div><div class="line">    console.log(&apos;error&apos; + err);</div><div class="line">    &#125;);  </div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>之前就已经介绍过了，Promise是有三种状态的：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。而且只能从<code>pending</code>转换为另外两种状态，而且是不可逆转的。可以借用Promise的这三种状态，让自己的Promise记住自己当前的状态。</p><p>添加一个记录Promise状态的变量，添加一个存储参数的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125;</div><div class="line">    call(callValue);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 在Promise初始化的时候，Promise的初始状态为<code>pending</code>，执行过thenCall方法后，改变自身状态为<code>fulfilled</code>，并且将传递的参数暂时保存到callValue中。过一段时间后，then执行的时候，由于状态已经改变，则会直接执行then中传递的回调函数，并将callValue作为回调参数。</p><h4 id="添加reject状态"><a href="#添加reject状态" class="headerlink" title="添加reject状态"></a>添加reject状态</h4><p>上述的方法都是只有resolve一个状态，其实reject与resolve相同，仅仅是执行了不同的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  this.catch = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      catchFunc = call;</div><div class="line">    &#125; else if (status === &apos;rejected&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const catchCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      catchFunc &amp;&amp; catchFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;rejected&apos;;</div><div class="line">      catchFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">        reject(&apos;ssss&apos;);</div><div class="line">&#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>关于return this，其实是将对象本身返回以供后续的catch或者其他操作，如果没有那么会报错说没有then方法或者没有catch方法。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><h4 id="自身调用"><a href="#自身调用" class="headerlink" title="自身调用"></a>自身调用</h4><p>Promise可以通过不停地返回Promise对象从而实现链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then().then().then().....</div></pre></td></tr></table></figure><p>由于MyPromise内部是由一个变量来保存的回调函数，只能保存最新的then方法，要是想实现自身的链式调用，那么就需要将其修改为数组，把每一个then传入的回调函数保存起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: Array&lt;Function&gt; = [];</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc.push(call);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc.forEach((fun) =&gt; &#123;</div><div class="line">        fun &amp;&amp; fun(value);</div><div class="line">      &#125;);</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">....</div><div class="line">....</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="串行promise"><a href="#串行promise" class="headerlink" title="串行promise"></a>串行promise</h4><p>更加常见的需求是不同的Promise类型需要在同一个方法中链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 100);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">    console.log(&apos;11&apos; + data);</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;dddd&apos;);</div><div class="line">        &#125;, 100);  </div><div class="line">    &#125;);</div><div class="line">&#125;).then((data) =&gt; &#123;</div><div class="line">console.log(&apos;22&apos; + data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);  </div><div class="line"></div><div class="line">// 控制台输入的结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 并不是预期的</div><div class="line">// 11ssss</div><div class="line">// 22dddd</div></pre></td></tr></table></figure><p>那么如何让后续的then方法，返回的是最新初始化的promise呢？首先考虑的位置就是MyPromise中的then方法。因为返回了一个新的promise，而不是像之前的返回this，所以就没有办法处理新的promise里面的内容。那么就应该区分出来，then方法里是否返回了一个新的promise。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">// 返回了一个新的promise</div><div class="line">    &#125; else &#123;</div><div class="line">        // 正常处理</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在then方法中，首先让传入的回调方法执行，观察它的返回值是否是一个对象并且里面包含着then方法。如果有的话，该回调函数就返回了一个新的pormise。</p><p>上述的方法确实可以判断出来是否传入了新的promise，但是要明确的一点是，then方法中并不是回调函数执行的时候，回调函数是否执行是由thenCall控制。以上的逻辑判断，需要传入thenFunc数组中存储起来，在thenCall中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, value) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((data) =&gt; &#123;</div><div class="line">            call(data);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">        thenFunc.push((value) =&gt; &#123; handlePromise(call, value); &#125;);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">        call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;;</div><div class="line">`将handlePromise传入thenFunc数组中，当其执行的时候，会判断then传入回调函数的返回值。如果是一个promise对象，那么就执行该promise的then函数`</div><div class="line">// 控制台输出结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 11dddd</div></pre></td></tr></table></figure><p>控制台输出并不是预期的结果，但是好消息是出现第二个promise的数据。那么问题在哪里呢，为什么会输出三个结果？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 当第一个then执行的时候,执行到</div><div class="line">const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">// 因为调用了call(value);</div><div class="line">// 在控制台打印了11ssss</div><div class="line">// 之后判断出返回了一个promise对象，执行到</div><div class="line">ret.then((data) =&gt; &#123;</div><div class="line">    call(data);</div><div class="line">&#125;)</div><div class="line">// 这里会执行第二个promise的异步函数</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;dddd&apos;);</div><div class="line">&#125;, 100);  </div><div class="line">// 即在100ms后，回调dddd，注意这里面仍然是在第一个then中回调！</div><div class="line">// 执行到这里的时候控制台并没有输出11dddd，而是先输出了22ssss</div><div class="line">// 因为是一个100ms延迟的异步函数，在调用的时候会直接执行第二个then</div><div class="line">// 此时MyPromise中的value值仍然是ssss，所以会直接输出22ssss</div><div class="line">// 100ms后输出11dddd</div></pre></td></tr></table></figure><p>到了第二次then方法的时候，仍然是第一个值，原因就是return this。仍然返回了本身的promise，而不是第二个promise中的内容。那么可以考虑在then中每次都返回一个新的promise，用来接收新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, resolve: Function) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((value) =&gt; &#123;</div><div class="line">            resolve(value);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        resolve(ret);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        if (status === &apos;pending&apos;) &#123;</div><div class="line">            thenFunc.push(() =&gt; &#123; handlePromise(call, resolve); &#125;);</div><div class="line">        &#125; else if (status === &apos;fulfilled&apos;) </div><div class="line">            call(callValue);</div><div class="line">    &#125;    </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>由于在then中构建了一个新的promise，在每次then中都会调用resolve来改变MyPromise中value的值，确保在下一次的then中获取到新的值。</p><p>以上即可在promise中实现链式调用。</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race()"></a>promise.race()</h4><p>Promise的race方法其实是将几个promise一起执行，首先回调的promise会做为race方法的回调值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.race = (raceList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let count = 0;</div><div class="line">    for (let i = 0; i &lt; raceList.length; i++) &#123;</div><div class="line">      raceList[i].then((value) =&gt; &#123;</div><div class="line">        if (count === 0) &#123;</div><div class="line">          count++;</div><div class="line">          resolve(value);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h4><p>Promise的all方法是将几个promise一起执行，当每个promise返回成功的时候，才会将所有的结果组合成一个数组返回到结果中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.all = (allList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let dataList = [];</div><div class="line">    for (let i = 0; i &lt; allList.length; i++) &#123;</div><div class="line">      allList[i].then((value) =&gt; &#123;</div><div class="line">        dataList.push(value);</div><div class="line">        if (dataList.length == allList.length) &#123;</div><div class="line">          resolve(dataList);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是全部关于自己实现promise的内容，仅仅实现了promise的一部分内容。实现起来还是有一点吃力的，尤其是关于链式调用的实现，更加能理解关于函数编程的思想，总体来说实现的比较乱。网上其他大神都是用es5写的，和es6写法还是有一点出入的。使用es6实现还是比较简洁的，如果有任何问题请不吝赐教。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/yangzhou33/p/9992588.html" target="_blank" rel="external">实现简易promise</a></p></li><li><p><a href="https://www.cnblogs.com/huansky/p/6064402.html" target="_blank" rel="external">手把手教你实现一个完整的 Promise</a></p></li><li><p><a href="https://blog.csdn.net/yibingxiong1/article/details/68075416" target="_blank" rel="external">实现一个自己的promise</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/24/my-promise/promise2.jpg&quot; alt=&quot;promise2.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;const promise = new Promise((resolve, reject) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if(/* 一般是异步操作 */) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        resolve(&amp;apos;回调&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        reject(&amp;apos;error&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;promise.then((data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch((error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面尝试一下自己去实现Promise的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://mah93.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello Promise</title>
    <link href="https://mah93.github.io/2018/12/18/hello-promise/"/>
    <id>https://mah93.github.io/2018/12/18/hello-promise/</id>
    <published>2018-12-18T11:56:03.000Z</published>
    <updated>2018-12-25T04:42:02.386Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/18/hello-promise/promises-methods.png" alt="promises-methods.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>Promise</strong>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<strong>Promise</strong> 是一个对象，从它可以获取异步操作的消息。<strong>Promise</strong> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><strong>Promise</strong>有三种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p><p><strong>Promise</strong>对象初始化时状态为：<code>pending</code>（进行中）</p><p>调用resolve方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>fulfilled</code></p><p>调用rejected方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>rejected</code></p><blockquote><p>1、 <strong>Promise</strong>对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。</p><p>2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。<strong>Promise</strong>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</p></blockquote><a id="more"></a> <h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>简单的初始化一个<strong>Promise</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面初始化了一个<strong>Promise</strong>对象，并创建了一个异步操作：在两秒后调用resolve方法。这里仅仅是初始化了这个对象，并没有调用。继续调用这个promise对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>当执行代码的时候，控制台在两秒钟后打印出了“延迟2s回调”，也就是说在上面初始化<strong>Promise</strong>的resolve里面的参数回调到了下面then方法中的data参数中。简单来说就是then里面的函数，会传递到<strong>Promise</strong>中并由resolve来控制这个函数的执行时间以及执行所需要的参数并回调。</p><p>上述代码的执行过程就是<strong>Promise</strong>内部状态由<code>pending</code>变为<code>fulfilled</code>。</p><p><strong>Promise</strong>还有从<code>pending</code>变为<code>rejected</code>的过程。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        let number = getRandomNumber();</div><div class="line">        <span class="keyword">if</span>(number &gt; <span class="number">5</span>) &#123;</div><div class="line">            resolve(<span class="string">'大于5'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reject(<span class="string">'不大于5'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'then'</span>);</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'catch'</span>);</div><div class="line"><span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>在<strong>Promise</strong>中初始化了一个简单逻辑，两秒之后获得一个随机数字，该数字大于5的时候调用resolve方法，反之则调用reject方法。由上面的例子可以得知，当数字大于5的时候会在then中打印。那么当数字小于5的时候，则会在catch中打印改数字。</p><p><strong>简单总结下来，resolve方法回调至then中，reject方法回调至catch中。</strong></p><p>那么可以借用<strong>Promise</strong>的特点，简单的封装一个网络请求。使用<code>resolve</code>和<code>reject</code>分别包装正常返回和异常返回的值和信息。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">            fetch(url)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span> =&gt;</span> &#123;</div><div class="line">                    <span class="keyword">return</span> response.json();</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(responseData)</span> =&gt;</span> &#123;</div><div class="line">                    resolve(responseData);</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">catch</span>(function (error) &#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求返回的数据</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求报错</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>通过上面的例子<strong>Promise</strong>可以理解为是一个类似延迟加载的异步回调函数，那么其实也可以用普通的方法实现<strong>Promise</strong>的功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">myPromise</span> = <span class="params">(callback)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</div><div class="line">        callback(<span class="string">'随便什么数据'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">myPromise(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>它也会和<strong>Promise</strong>拥有同样的效果。那<strong>Promise</strong>到底能实现什么不可替代的功能呢？</p><p>假如有许多的异步操作需要执行，比如连续的三个请求，每一次请求都需要从前一个请求中获取参数，那么它的写法如下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetch(url1).<span class="keyword">then</span>(<span class="function"><span class="params">(data1)</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (data1 == <span class="number">200</span>) &#123;</div><div class="line">        fetch(url2).<span class="keyword">then</span>(<span class="function"><span class="params">(data2)</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span>(data2 == <span class="number">200</span>) &#123;</div><div class="line">                fetch(url3) ....</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>虽然可以实现需求，然是代码看起来并不那么友好，它庞大的层级结构使之无法轻易被修改。如果要是需要在第二个请求和第三个请求中再加入一些异步操作，那么将是不可修改的，这被称为回调地狱(Callback hell)。</p><p>使用<strong>Promise</strong>即可解决上述问题，<strong>Promise</strong>的优势在于，可以在then方法中继续写<strong>Promise</strong>对象并返回，然后继续调用then来进行回调操作。也就是说可以一直return一个<strong>Promise</strong>对象，可以一直在在后面调用then方法。如果使用<strong>Promise</strong>后上述的需求可以写为</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 分别将三个请求包装为函数</div><div class="line"><span class="function"><span class="title">request1</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url1);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request2</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request3</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url3);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 调用时</div><div class="line">request1().<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span>=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> request2();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> request3();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;).<span class="keyword">catch</span>();</div></pre></td></tr></table></figure><p>只需要在then中调用下一个<strong>Promise</strong>，上一个<strong>Promise</strong>中回调的数据即可传递下去。</p><blockquote><p>关于回调地狱(Callback hell)的问题也可以使用async/await解决，类似的代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> task() async &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    try&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String id = await request1();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String userInfo = await request2();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     await request3();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //执行接下来的操作   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125; catch(e)&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //错误处理   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(e);   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125;  </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p><strong>Promise.all</strong>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.all([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p><code>p</code>的状态由<code>promise1</code>、<code>promise2</code>、<code>promise3</code>决定，分成两种情况。</p><p>（1）只有<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>promise1</code>、<code>promise2</code>、<code>promise3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><blockquote><p>注意，如果作为参数的 promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p></blockquote><h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p><strong>Promise.race</strong>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.race([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p>上面代码中，只要有任何一个promise改变状态，那么p的状态也会跟着改变。也就是说最快改变状态的promise会让其他promise不会回调。</p><p>可以通过这个方法来完成一个请求超时功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([</div><div class="line">  fetch(url),</div><div class="line">  <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> Error(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">  &#125;)</div><div class="line">]);</div><div class="line"></div><div class="line">p</div><div class="line">.<span class="keyword">then</span>(<span class="built_in">console</span>.log)</div><div class="line">.<span class="keyword">catch</span>(<span class="built_in">console</span>.error);</div></pre></td></tr></table></figure><p>即当5s内请求没有返回结果，就返回请求超时。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">ES6标准入门（阮一峰）</a></p></li><li><p><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="external">大白话讲解Promise（一）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/18/hello-promise/promises-methods.png&quot; alt=&quot;promises-methods.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，&lt;strong&gt;Promise&lt;/strong&gt; 是一个对象，从它可以获取异步操作的消息。&lt;strong&gt;Promise&lt;/strong&gt; 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;有三种状态：&lt;code&gt;pending&lt;/code&gt;、&lt;code&gt;fulfilled&lt;/code&gt;、&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;对象初始化时状态为：&lt;code&gt;pending&lt;/code&gt;（进行中）&lt;/p&gt;
&lt;p&gt;调用resolve方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用rejected方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、 &lt;strong&gt;Promise&lt;/strong&gt;对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;strong&gt;Promise&lt;/strong&gt;对象的状态改变，只有两种可能：从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;和从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://mah93.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Masonry笔记</title>
    <link href="https://mah93.github.io/2018/12/07/masonry/"/>
    <id>https://mah93.github.io/2018/12/07/masonry/</id>
    <published>2018-12-07T09:21:26.000Z</published>
    <updated>2018-12-25T04:41:45.097Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。</p><p>Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂</p><p>Masonry属性与NSLayoutAttrubute的对照表如下</p><table><thead><tr><th>Masonry</th><th>NSLayoutAttrubute</th><th>说明</th></tr></thead><tbody><tr><td>left</td><td>NSLayoutAttrubuteLeft</td><td>左侧</td></tr><tr><td>top</td><td>NSLayoutAttrubuteTop</td><td>上侧</td></tr><tr><td>right</td><td>NSLayoutAttrubuteRight</td><td>右侧</td></tr><tr><td>bottom</td><td>NSLayoutAttrubuteBottom</td><td>下侧</td></tr><tr><td>leading</td><td>NSLayoutAttrubuteLeading</td><td>首部</td></tr><tr><td>trailing</td><td>NSLayoutAttrubuteTrailing</td><td>尾部</td></tr><tr><td>width</td><td>NSLayoutAttrubuteWidth</td><td>宽度</td></tr><tr><td>height</td><td>NSLayoutAttrubuteHeight</td><td>高度</td></tr><tr><td>centerX</td><td>NSLayoutAttrubuteCenterX</td><td>水平中心</td></tr><tr><td>centerY</td><td>NSLayoutAttrubuteCenterY</td><td>竖直中心</td></tr><tr><td>baseline</td><td>NSLayoutAttrubuteBaseline</td><td>文本基线</td></tr></tbody></table><a id="more"></a> <h3 id="NSLayoutAttrubute"><a href="#NSLayoutAttrubute" class="headerlink" title="NSLayoutAttrubute"></a>NSLayoutAttrubute</h3><p>下面是用NSLayoutAttrubute，约束一个子视图，使之每个边与其父视图间距为10</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="string">UIView</span> <span class="meta">*superview</span> <span class="string">=</span> <span class="string">self.view;</span></div><div class="line"></div><div class="line"><span class="string">UIView</span> <span class="meta">*view1</span> <span class="string">=</span> <span class="string">[[UIView</span> <span class="string">alloc]</span> <span class="string">init];</span></div><div class="line"><span class="string">view1.translatesAutoresizingMaskIntoConstraints</span> <span class="string">=</span> <span class="literal">NO</span><span class="string">;</span></div><div class="line"><span class="string">view1.backgroundColor</span> <span class="string">=</span> <span class="string">[UIColor</span> <span class="string">greenColor];</span></div><div class="line"><span class="string">[superview</span> <span class="attr">addSubview:view1];</span></div><div class="line"></div><div class="line"><span class="string">UIEdgeInsets</span> <span class="string">padding</span> <span class="string">=</span> <span class="string">UIEdgeInsetsMake(10,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">);</span></div><div class="line"></div><div class="line"><span class="string">[superview</span> <span class="attr">addConstraints:@[</span></div><div class="line"></div><div class="line">    <span class="string">//view1</span> <span class="string">constraints</span></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.top],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.left],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.bottom],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.right],</span></div><div class="line"></div><div class="line"> <span class="string">]];</span></div></pre></td></tr></table></figure><p>而使用了Masonry实现相同的约束，仅仅需要几行代码</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="name">view</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</div><div class="line">    make.edges.insets(<span class="name">UIEdgeInsetsMake</span>(<span class="name">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>))<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>Masonry支持CocoaPods，可以直接通过podfile文件进行集成，要在CocoaPods中添加下面代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod</span> <span class="string">'Masonry'</span></div><div class="line">pod install</div></pre></td></tr></table></figure><p>之后直接在项目中引用即可，详情请参考<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">github</a></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>首先是约束的相关api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">/*</div><div class="line">mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class="line">mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class="line">mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class="line">*/</div></pre></td></tr></table></figure><blockquote><p> 在使用Masonry的约束之前，首先要将view添加到superview上</p><p>之后调用mas_makeConstraints添加相应的约束</p></blockquote><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.centerX.equalTo(subView.mas_centerX); // 水平</div><div class="line">    make.centerY.equalTo(subView.mas_centerY); // 竖直</div><div class="line">    make.size.mas_equalTo(CGSizeMake(100, 100));</div><div class="line">&#125;];</div></pre></td></tr></table></figure><table><thead><tr><th>水平居中</th><th style="text-align:center"><img src="/2018/12/07/masonry/center_v.png" alt="center_v.png" title=""></th></tr></thead><tbody><tr><td><strong>竖直居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center_h.png" alt="center_h.png" title=""></td></tr><tr><td><strong>居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center.png" alt="center.png" title=""></td></tr></tbody></table><h3 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 添加一个与父视图上下左右都相距<span class="number">20</span>的view</div><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.insets(UIEdgeInsetsMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>));</div><div class="line"></div><div class="line">    /*  </div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">    */</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/insets.png" alt="insets.png" title=""><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图水平排列，之间的间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(subView.mas_left).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(view2.mas_left).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view2);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(view1.mas_right).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(subView.mas_right).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition.png" alt="apposition.png" title=""><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图竖直并列，之间间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(subView.mas_top).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(view2.mas_top).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view2);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(view1.mas_bottom).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(subView.mas_bottom).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_v.png" alt="apposition_v.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//  上层左右并列，并与下层对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view3.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view3.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.mas_equalTo(view1.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view1.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.height.equalTo(view1);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_2.png" alt="apposition_2.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  右侧上下并列，并与左侧对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerY.equalTo(subView.mas_centerY);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view2.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view3.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view3);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view2.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_3.png" alt="apposition_3.png" title=""><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上仅仅是最最基础的布局，在实际的生产过程中要复杂许多。但是Masonry的确简化了NSLayoutConstraint的写法，使之更加语义化。虽然写法更加的复杂，对于团队开发也是一种规范。写下本笔记主要是为了记载自己学习Masonry的过程，暂时不能投入生产中，也无法更加熟练深刻的运用，仅记之以供后日查阅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。&lt;/p&gt;
&lt;p&gt;Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂&lt;/p&gt;
&lt;p&gt;Masonry属性与NSLayoutAttrubute的对照表如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Masonry&lt;/th&gt;
&lt;th&gt;NSLayoutAttrubute&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;left&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeft&lt;/td&gt;
&lt;td&gt;左侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTop&lt;/td&gt;
&lt;td&gt;上侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;right&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteRight&lt;/td&gt;
&lt;td&gt;右侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bottom&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBottom&lt;/td&gt;
&lt;td&gt;下侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leading&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeading&lt;/td&gt;
&lt;td&gt;首部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTrailing&lt;/td&gt;
&lt;td&gt;尾部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteWidth&lt;/td&gt;
&lt;td&gt;宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteHeight&lt;/td&gt;
&lt;td&gt;高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerX&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterX&lt;/td&gt;
&lt;td&gt;水平中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerY&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterY&lt;/td&gt;
&lt;td&gt;竖直中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;baseline&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBaseline&lt;/td&gt;
&lt;td&gt;文本基线&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://mah93.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Charles学习</title>
    <link href="https://mah93.github.io/2018/06/28/charles-learn/"/>
    <id>https://mah93.github.io/2018/06/28/charles-learn/</id>
    <published>2018-06-28T04:14:48.000Z</published>
    <updated>2018-12-25T04:42:23.110Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/charles-learn/charles-logo.png" alt="charles-logo.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器.它允许一个开发者查看所有连接互联网的HTTP通信.这些包括request,response现HTTP headers (包含cookies与caching信息).</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。可以在<a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles官网</a>下载（该软件为付费软件，试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时）</p><a id="more"></a> <h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><p>在安装的过程中，Charles会请求系统代理的权限。如果在安装的过程中，没有设置或者跳过，可以在主页面中重新设置代理权限。</p><img src="/2018/06/28/charles-learn/charles-setting.png" alt="charles-setting.png" title=""><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>Charles的主界面如下图所示，左半边是发出去的请求URL以及URL过滤器，右半边是请求的相关信息，头部是相应的请求工具，如断点、重发等等</p><img src="/2018/06/28/charles-learn/charles-main.png" alt="charles-main.png" title=""><h3 id="截取模拟器的请求"><a href="#截取模拟器的请求" class="headerlink" title="截取模拟器的请求"></a>截取模拟器的请求</h3><p>在Proxy 菜单，选中Proxy Settings ,打开对话框，设置端口号（默认是8888，也可以自定义），并选中 Enable transparent Http proxying 选项，如下图所示：</p><img src="/2018/06/28/charles-learn/charles-proxy.png" alt="charles-proxy.png" title=""><p>当在iOS模拟器做HTTP请求时，左边会相应出现请求的URL。</p><h3 id="抓取HTTPS报文"><a href="#抓取HTTPS报文" class="headerlink" title="抓取HTTPS报文"></a>抓取HTTPS报文</h3><p>Charles不仅能够抓取http协议的包，也能抓取https协议的包，但是由于https是经过加密的，因为抓取的包中的内容是以密文方式展现的，通过配置Charles的SSL可以方便的以明文查看https协议传输的内容</p><ul><li><h4 id="电脑上配置证书"><a href="#电脑上配置证书" class="headerlink" title="电脑上配置证书"></a>电脑上配置证书</h4></li></ul><p>选中Charles，在“Help”菜单中选择—&gt;“SSL Proxying”—&gt;“Install Charles Root Certificate”，会自动打开钥匙串访问。<br><img src="/2018/06/28/charles-learn/charles-cer.png" alt="charles-cer.png" title=""></p><p>但是默认是不被信任的状态，右键该证书，选择显示简介，将证书设置为完全信任状态。</p><img src="/2018/06/28/charles-learn/charles-confi.png" alt="charles-confi.png" title=""><ul><li><h4 id="移动设备上配置证书"><a href="#移动设备上配置证书" class="headerlink" title="移动设备上配置证书"></a>移动设备上配置证书</h4></li></ul><p>一般情况下我们会使用安卓或者苹果设备进行抓包，无论是哪种设备，下述流程大体一致：</p><ol><li>将移动设备与开启Charles的电脑设备设置在同一Wi-Fi下，并且将移动设备的HTTP代理改成电脑的IP。</li></ol><p>以苹果设备为例：打开设置—&gt;无线局域网—&gt;选择网络—&gt;点击网络名称旁边的感叹号—&gt;将配置HTTP代理设置为手动模式—&gt;输入电脑IP，端口号为8888</p><img src="/2018/06/28/charles-learn/charles-iphone-setting.jpg" alt="charles-iphone-setting.jpg" title=""><ol><li>打开移动设备的浏览器，访问<strong>chls.pro/ssl</strong>会提示下载一个描述文件，下载安装即可。</li><li>打开移动设备，将该证书设置为信任状态。</li></ol><p>以苹果设备为例：打开设置—&gt;通用—&gt;关于本机—&gt;证书信任设置—&gt;将证书设置为信任状态。</p><ul><li><h4 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h4></li></ul><p>选中Charles，在“Proxy”菜单中选择—&gt;“SSL Proxying Settings ”，在弹出的页面中勾选Enable SSL Proxying。并在下方添加需要抓取的URL，端口号为443<br><img src="/2018/06/28/charles-learn/charles-ssl.png" alt="charles-ssl.png" title=""></p><p>之后在移动端操作，即可看到相应的请求信息。</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><h4 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h4></li></ul><p>Charles可以对某一接口进行重发，以尝试重放交易服务器响应。</p><p>右键单击URL选择<strong>Repeat</strong>，Charles会自动将该URL以及URL包含的内容原封不动的再次提交至服务器。</p><p>右键单击URL选择<strong>Repeat Advanced</strong>，在弹出框中设置重复次数、并发数以及延时等。对服务器进行简单的性能测试。</p><img src="/2018/06/28/charles-learn/charles-repeat.png" alt="charles-repeat.png" title=""><ul><li><h4 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h4></li></ul><p>Charles可以在请求发出前，或者是请求返回至设备前将请求拦截并篡改。</p><p>右键单击URL选择<strong>Breakpoints</strong>，然后在该请求再次发起的时候，会被拦截下来。选择<strong>Edit Request</strong>可以进行修改请求信息，修改完成后点击<strong>Execute</strong>该请求会继续发出。</p><ul><li><h4 id="模拟慢速网络"><a href="#模拟慢速网络" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h4></li></ul><p>有时候开发中需要测试用户在网络情况比较的差的时候应用的表现情况，可以使用Charles限流设置，”Proxy” -&gt; “Thorttle Settings” 中设置如下：</p><img src="/2018/06/28/charles-learn/charles-lowNet.png" alt="charles-lowNet.png" title="">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/charles-learn/charles-logo.png&quot; alt=&quot;charles-logo.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器.它允许一个开发者查看所有连接互联网的HTTP通信.这些包括request,response现HTTP headers (包含cookies与caching信息).&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。可以在&lt;a href=&quot;http://www.charlesproxy.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Charles官网&lt;/a&gt;下载（该软件为付费软件，试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时）&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://mah93.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://mah93.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>React-Native代码规范</title>
    <link href="https://mah93.github.io/2018/05/07/code-standard/"/>
    <id>https://mah93.github.io/2018/05/07/code-standard/</id>
    <published>2018-05-07T04:22:40.000Z</published>
    <updated>2018-12-25T04:42:15.109Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/07/code-standard/code-standard.jpg" alt="code-standard.jpg" title=""><blockquote><p>代码规范只是让代码更容易被理解，让多人开发时代码也能保持内部一致性。</p><p>制定代码规范的标准因团队而异，可以根据多数人的开发习惯或者是参考别人的规范</p><p>实现代码规范的方法有很多种，在React-Native中可以使用ESLint配合编译器进行代码规范审核</p><p>不必矫枉过正</p></blockquote><a id="more"></a> <h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><h4 id="变量规范"><a href="#变量规范" class="headerlink" title="变量规范"></a>变量规范</h4><ul><li>代码中变量的命名均不能以下划线或符号开始，也不能以下划线或符号为结束</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">错误：_<span class="built_in">title</span> / $<span class="built_in">title</span> / title_ / <span class="built_in">title</span>$</div></pre></td></tr></table></figure><ul><li>变量命名采用lowerCamelCase驼峰命名的方式，第一个字母必须小写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：myName / birthDay</div></pre></td></tr></table></figure><ul><li>命名严禁使用拼音或者是拼音与英文混合的方式，正确的英文拼写和语法可以让阅读者易于理解，避免歧义</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：shengchan / fenshu / <span class="keyword">bigshan</span></div><div class="line"><span class="keyword">正确：production </span>／ grade ／ <span class="keyword">bigMountain</span></div></pre></td></tr></table></figure><ul><li>常用的单词，在不引起歧义的情况下可以缩写</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：<span class="keyword">user</span>Msg 等价于 <span class="keyword">user</span>Messaage</div></pre></td></tr></table></figure><ul><li>数组或者对象变量，需明确指出其类型</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确： studentList / <span class="keyword">user</span>Object</div></pre></td></tr></table></figure><ul><li>常量的命名全部采用大写，单词与单词之间采用下划线进行分割。力求保证见文知意，不要害怕变量过长</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：<span class="keyword">MaxValue</span> / <span class="keyword">MAXVALUE</span></div><div class="line">正确：MAX_STUDENT_GRADE</div></pre></td></tr></table></figure><ul><li>对所有的变量，对象的引用，请使用const</li></ul><h4 id="函数规范"><a href="#函数规范" class="headerlink" title="函数规范"></a>函数规范</h4><ul><li>方法、函数一律使用ES6中箭头函数的声明方式</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">     test() &#123;&#125;</div><div class="line">正确：test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure><ul><li>方法名、函数名一律采用lowerCamelCase驼峰命名的方式，第一个字母必须小写</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：getAllUserInformation = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure><ul><li>类名使用UpperCamelCase驼峰命名的方式，第一个字母必须大写</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：<span class="builtin-name">export</span><span class="built_in"> default </span>class StringUtil &#123;&#125;</div></pre></td></tr></table></figure><h4 id="组件规范"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范</h4><ul><li>JSX中的方法，超过一行必须写成一个新的函数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：<span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">onPress</span>=<span class="string">&#123;this.doSomething&#125;</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>组件嵌套时，子组件与父组件要有2个空格的缩进</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;Father&gt;</span></div><div class="line">  <span class="section">&lt;Children /&gt;</span></div><div class="line"><span class="section">&lt;/Father&gt;</span></div></pre></td></tr></table></figure><ul><li>组件需要设置样式的时候，如果只有一个样式可以用内联的方式写在JSX内，如果两个以上必须使用StyleSheet创建样式</li><li>当一个组件有多个属性需要配置的时候，务必多行书写</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">TouchableOpacity</span></span></span></div><div class="line"><span class="xml">  onPress=</span><span class="template-variable">&#123;() =&gt; &#123;&#125;</span><span class="xml">&#125;</span></div><div class="line"><span class="xml">  style=</span><span class="template-variable">&#123;&#125;</span><span class="xml"></span></div><div class="line"><span class="xml">&gt;</span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></div></pre></td></tr></table></figure><ul><li>自定义组件命名的时候，用UpperCamelCase命名。</li><li>自定义组件，要详细写出属性列表，并解释每个属性的意思。为每个属性初始化一个默认值</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="module-access"><span class="module"><span class="identifier">FlexButton</span>.</span></span>propTypes = &#123;</div><div class="line">  press: <span class="module-access"><span class="module"><span class="identifier">PropTypes</span>.</span></span>func,</div><div class="line">  top: <span class="module-access"><span class="module"><span class="identifier">PropTypes</span>.</span></span>number.isRequired,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="module-access"><span class="module"><span class="identifier">FlexButton</span>.</span></span>defaultProps = &#123;</div><div class="line">  press:<span class="function"> <span class="params">()</span> =&gt;</span> &#123;&#125;,</div><div class="line">  top: <span class="number">0</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>无状态的组件，即不涉及组件内部数据、UI变化的组件。请继承自PureComponent而不是Component</li></ul><h4 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h4><ul><li>关键字左右需加空格，如if/for/else等关键字</li></ul><ul><li>任何运算符左右必须都有一个空格，包括赋值、逻辑运算符、加减乘除等</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：grade=<span class="number">20</span></div><div class="line">正确：grade = <span class="number">20</span></div></pre></td></tr></table></figure><ul><li>大括号使用约定。如果大括号内为空，则写成{}即可，不需要换行。如果是非空代码块则左边括号空一格，右边闭括号需要换行，与方法名对其</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">例如：const getTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li>单行字符数不超过120个（可在eslint中设置）超过的字符需要换行。单页代码不超过300行，超过的需要重构代码。</li><li>方法参数在传入的时候，多个参数逗号前必须加括号</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">onMsgCallBack</span> = <span class="params">(msg, title, name)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>合理使用空格，将不同功能或者是不同业务逻辑的方法分开。</li></ul><h4 id="条件语句规范"><a href="#条件语句规范" class="headerlink" title="条件语句规范"></a>条件语句规范</h4><ul><li>简单的if/else逻辑判断，请使用三目运算符。逻辑判断请勿超过三层，如果超过了请重新思考代码逻辑。或者使用switch</li><li>在一个 switch 块内，每个case要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止;在一个 switch 块内，都必须包含一个default 语句并且 放在最后，即使它什么代码也没有。</li></ul><h4 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h4><ul><li>变量或者是属性，可以在后面使用单行注释来说明这个变量或者属性的用途</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> userName = <span class="string">'Jace'</span>; <span class="comment">// 用户姓名</span></div></pre></td></tr></table></figure><ul><li>类、类方法的注释不得使用//单行注释，必须使用/**/的多行注释。方法中如果需要传入参数，或者是有返回值。请在注释中详细写出。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 获取所有信息</span></div><div class="line"><span class="comment"> * param: name 获取信息人姓名</span></div><div class="line"><span class="comment"> * param: number 获取信息人编号</span></div><div class="line"><span class="comment"> * return: msg 返回用户信息</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> fetchAllMsg = <span class="function">(<span class="params">name, <span class="built_in">number</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// doFetch</span></div><div class="line">    <span class="keyword">return</span> msg</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>逻辑代码中需要注释出逻辑流程</li><li>注释掉的代码，如果不再使用请尽快删除，以免给后续维护人员带来麻烦。如果只是暂时注释，请说明注释原因</li></ul><h3 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h3><ul><li>确定好项目的文件目录结构，要求文件层次清晰，功能划分明确</li></ul><ul><li>文件命名遵循lowerCamelCase方式命名。如果是某一个平台特有的文件，可以加上ios或者android的后缀作为区分</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：index<span class="selector-class">.ios</span><span class="selector-class">.js</span> / index<span class="selector-class">.android</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure><ul><li>文件开头需写明该文件作用、作者以及创建时间</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 登录页面</div><div class="line"> * <span class="keyword">by</span> XXX <span class="keyword">at</span> <span class="number">2018</span><span class="number">-2</span><span class="number">-10</span></div><div class="line"> */</div></pre></td></tr></table></figure><h3 id="ESLint安装指南"><a href="#ESLint安装指南" class="headerlink" title="ESLint安装指南"></a>ESLint安装指南</h3><p>在项目的根目录中运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="built_in">export</span> PKG=eslint-config-airbnb;</div><div class="line">  npm info <span class="string">"<span class="variable">$PKG</span>@latest"</span> peerDependencies --json | <span class="built_in">command</span> sed <span class="string">'s/[\&#123;\&#125;,]//g ; s/: /@/g'</span> | xargs npm install --save-dev <span class="string">"<span class="variable">$PKG</span>@latest"</span></div><div class="line">)</div></pre></td></tr></table></figure><p>之后需要安装babel-eslint，并创建.eslintrc。可以在里面写入自己的代码规则，类似于下方</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</div><div class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</div><div class="line">  <span class="string">"rules"</span>: &#123;</div><div class="line">  // 你的规则</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"parserOptions"</span>: &#123;</div><div class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</div><div class="line">      <span class="string">"experimentalObjectRestSpread"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所有的规则可以在<a href="https://cn.eslint.org/docs/rules/" target="_blank" rel="external">ESLint规则</a>中查看，然后根据你的要求写到rules下</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"rules"</span>: &#123;</div><div class="line"><span class="string">"no-bitwise"</span>: <span class="string">[0]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li><li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li><li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/07/code-standard/code-standard.jpg&quot; alt=&quot;code-standard.jpg&quot; title=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;代码规范只是让代码更容易被理解，让多人开发时代码也能保持内部一致性。&lt;/p&gt;
&lt;p&gt;制定代码规范的标准因团队而异，可以根据多数人的开发习惯或者是参考别人的规范&lt;/p&gt;
&lt;p&gt;实现代码规范的方法有很多种，在React-Native中可以使用ESLint配合编译器进行代码规范审核&lt;/p&gt;
&lt;p&gt;不必矫枉过正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发指北</title>
    <link href="https://mah93.github.io/2018/04/27/react-native-develop-guide/"/>
    <id>https://mah93.github.io/2018/04/27/react-native-develop-guide/</id>
    <published>2018-04-27T09:31:47.000Z</published>
    <updated>2018-12-25T04:41:13.135Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/27/react-native-develop-guide/react-native-develop-north.jpg" alt="react-native-develop-north.jpg" title=""><h3 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h3><ul><li>搭建开发环境</li></ul><p>根据自身的硬件环境，分别安装不同的环境，具体请看官网的教程。<a href="https://reactnative.cn/docs/0.44/getting-started.html#content" target="_blank" rel="external">#搭建开发环境</a></p><ul><li>关于node</li></ul><p>开发RN项目之前，需要熟悉几个npm命令。例如</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure><p>安装该项目中所有依赖包，一般写在package.json中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> XXX <span class="comment">--save</span></div></pre></td></tr></table></figure><p>为你的项目中添加某个依赖包</p><p>等等。。</p><a id="more"></a> <p>当你在本地运行一个React Native的项目时，会同步打开一个终端。会在本地的8081端口启动Js Server，当程序启动的时候，会通过这个服务读取Js代码，并完成页面的渲染。在程序运行的过程中，要保持这个终端处于一直运行的状态。不涉及原生代码改动的时候，无需重新编译。重新Reload页面即可。</p><ul><li>React Native版本</li></ul><p>开始一个新的项目之前，首先确定要使用的RN版本（官方每三个月更新一次），基本上都会使用0.43以上的版本。因为许多组件在之前的老版本并不存在，比如FlatList。新建一个指定版本的RN项目只需</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init MyApp --version 0.39.2</div></pre></td></tr></table></figure><blockquote><p>注意版本号必须精确到两个小数点。</p></blockquote><ul><li>开发工具</li></ul><p>开发工具推荐使用WebStorm或者是VSCode，下载一个Chrome浏览器对于调试有很大帮助。</p><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>除了正常的开发工作，你可能还需要一些辅助的功能来帮助更好的开发</p><ul><li>ESLint</li></ul><p>ESLint是一个JS插件，用来检测代码规范性。它自己包含了一些规范，当然你也可以自己去配置一些符合自己编码习惯的规则。虽然它是一个代码检测，但也不是所有的规则都需要遵循。在.eslintrc中编辑你的规则。<a href="https://cn.eslint.org/" target="_blank" rel="external">ESLint中文官方网站</a></p><p>当配置好你的规则之后，打开IDE的代码检测功能。当你违反了制定的代码规范，会以红标提示。你也可以手动执行命令进行代码检测。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint <span class="params">--ext</span> <span class="string">.js</span> src test</div></pre></td></tr></table></figure><p>执行完之后，会精确到代码行数的报错。</p><blockquote><p>如果需要强制执行，请使用pre-commit插件。它会在每次commit之前执行某些操作，如果遇到问题，就会停止commit操作。</p></blockquote><p>如果你不希望有些代码进行代码检测，把它们的路径加入到.eslintignore文件中:)</p><ul><li>mock</li></ul><p>界面完成之后，可能你的后台服务并没有完成。有些界面会根据数据的不同进行调整。这时候可以通过node服务，模拟一个后台服务器并mock出模拟数据返回到前台页面，完成简单的接口测试。</p><p>你可以使用express来搭建一个简单的node服务器</p><p>通过mock来完成简单的数据，具体方式请参见<a href="http://mockjs.com/" target="_blank" rel="external">mock官方网站</a></p><ul><li>git</li></ul><p>无论是单人开发还是多人协作，git无疑是最好的版本控制工具。日常开发中涉及的git命令并不多，学习成本也不高，请务必使用。实在是没有使用过的请参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰GIT教程</a>!</p><p>这里需要强调的是分支管理，如果是多人开发必须制定一些规则使每个人可以更加方便的开发。</p><ol><li>新建master分支，用于大版本的合并，并设立保护分支</li><li>新建develop分支，用于日常的开发工作，并设立保护分支</li><li>新建submit分支，用于测试版本</li><li>为每一个人新建一个分支，每个人只能在自己的分支上进行开发工作，下班前提交到自己的远程分支上</li><li>一个阶段的代码完成后，需要合并到develop分支，需提交合并请求由项目管理员进行合并操作</li><li>合并之后每个成员合并develop分支</li></ol><p>以上可以根据项目的需求自行修改</p><h3 id="需要考虑的事情"><a href="#需要考虑的事情" class="headerlink" title="需要考虑的事情"></a>需要考虑的事情</h3><p>一个新的项目首先要考虑的就是结构：目录结构、代码结构、系统架构等等，这些会一直影响着项目的健壮性、拓展性。但当代码遇到问题的时候，重构也是必要的。</p><ul><li>目录结构</li></ul><p>这里说的是文件的物理结构。</p><p>1.功能相同的放入同一个文件夹</p><p>功能相同就是说，把所有的页面放入一个文件夹，把所有的逻辑处理放入一个文件夹类似于这种分类方式。优点是同类型的文件都放在一起。缺点是关于同一个页面的代码会分散在几个或者好几个文件夹中，寻找起来比较麻烦。</p><p>2.统一模块的代码放入同一个文件夹</p><p>统一模块的代码包含了这个模块的界面、逻辑处理、网络请求等所有涉及的代码，一个文件夹代表着一个功能模块。优点是相关代码放在一起，寻找或者引用的时候比较快，代码迁移比较方便。缺点是功能模块难以有明确的区分点，一些页面有复用情况。</p><ul><li>代码结构</li></ul><p>你可以在React Naitve的代码中编写JS，也可以写JSX，还可以写样式表或者是内联在JSX中的样式，网络请求也可以写。上面所有的内容都可以写在同一个JS中，这里就需要制定规则。哪些可以写在一起，哪些需要新建另外一个文件去辅助。</p><p>当然还有一些可有可无的东西，例如注释、属性列表等。它们可以帮助代码更好的被理解，增加代码可读性。也可以制定合理的代码规范，配合插件可以很好的使用。</p><ul><li>系统架构</li></ul><p>有关系统架构需要考虑的因素就更多了，如何去处理数据逻辑，网络请求如何去实现，页面与页面之间的联系如何进行等等。这些问题会涉及很多的第三方组件，你需要用以下几个方面去考察这个第三方组件：</p><ol><li>github上stars的数量，可以直观反映出这个组件的质量如何</li><li>上一次提交的时间。如果超过一年没有更新过，那么很可能并不适合新版的RN</li><li>github上issuse数量，当遇到问题的时候大部分都是通过issuse解决</li></ol><p>当然这仅仅是最基本的方面，还有许多别的考察方面，比如它的实现方式，README有没有写的比较详细等等。当你逐个确定要使用的组件之后，一一引入。有些仅仅在开发阶段使用的组件，可以将它们引入开发依赖包中，以免打包进入项目，使得项目包变大。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/27/react-native-develop-guide/react-native-develop-north.jpg&quot; alt=&quot;react-native-develop-north.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;开发前准备&quot;&gt;&lt;a href=&quot;#开发前准备&quot; class=&quot;headerlink&quot; title=&quot;开发前准备&quot;&gt;&lt;/a&gt;开发前准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;搭建开发环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据自身的硬件环境，分别安装不同的环境，具体请看官网的教程。&lt;a href=&quot;https://reactnative.cn/docs/0.44/getting-started.html#content&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#搭建开发环境&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于node&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发RN项目之前，需要熟悉几个npm命令。例如&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装该项目中所有依赖包，一般写在package.json中&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; XXX &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为你的项目中添加某个依赖包&lt;/p&gt;
&lt;p&gt;等等。。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>react学习摘要</title>
    <link href="https://mah93.github.io/2018/04/11/react-deep-learn/"/>
    <id>https://mah93.github.io/2018/04/11/react-deep-learn/</id>
    <published>2018-04-11T09:16:26.000Z</published>
    <updated>2018-12-25T04:41:20.030Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/11/react-deep-learn/react-deep-learn.png" alt="react-deep-learn.png" title=""><h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><p>​    在react中，render执行的结果并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。虚拟DOM具有batching(批处理)和高效的Diff算法。由虚拟DOM来确保只对界面上真正的部分进行实际的DOM操作。</p><p>​    比较innerHTML 和Virtual DOM 的重绘过程如下：</p><ul><li>innerHTML: render html string + 重新创建所有 DOM 元素</li></ul><ul><li>Virtual DOM: render Virtual DOM + diff算法+ 必要的 DOM 更新</li></ul><h4 id="批量DOM处理"><a href="#批量DOM处理" class="headerlink" title="批量DOM处理"></a>批量DOM处理</h4><p>​    依靠 setState 的异步性，React在一段时间间隔内，将所有DOM更新收集起来，然后批量处理。也就是说调用setState的时候并不会立即更新状态，而是一段时间时候统一将变动的属性集体进行更新。从而达到减少渲染次数，提高性能的目的。</p><a id="more"></a> <h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>​    在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。</p><p>​    即给定任意两棵树，找到最少的转换步骤。但是<a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="external">标准的的Diff算法</a>复杂度需要O(n^3)。Facebook工程师结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n)：</p><ol><li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li><li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li></ol><h3 id="不同节点类型的比较"><a href="#不同节点类型的比较" class="headerlink" title="不同节点类型的比较"></a>不同节点类型的比较</h3><p>为了在树之间进行比较，我们首先要能够比较两个节点，在React中即比较两个虚拟DOM节点，当两个节点不同时，应该如何处理。这分为两种情况：</p><ol><li>节点类型不同。</li><li>节点类型相同，但是属性不同。</li></ol><ul><li><h5 id="节点类型不同"><a href="#节点类型不同" class="headerlink" title="节点类型不同"></a>节点类型不同</h5></li></ul><p>即在树的同一个位置，前后两次输出了不同类型的节点。React会直接删除掉之前的节点，然后创建并插入新的节点。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;span /&gt;</div><div class="line">=&gt; [removeNode &lt;div /&gt;], [insertNode &lt;span /&gt;]</div></pre></td></tr></table></figure><blockquote><p>需要注意的是，删除节点意味着彻底销毁该节点，而不是再后续的比较中再去看是否有另外一个节点等同于该删除的节点。如果该删除的节点之下有子节点，那么这些子节点也会被完全删除，它们也不会用于后面的比较。</p></blockquote><p>当React在同一个位置遇到不同的组件时，也是简单的销毁第一个组件，而把新创建的组件加上去。这正是应用了第一个假设，不同的组件一般会产生不一样的DOM结构，与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去。</p><h5 id="逐层进行节点比较"><a href="#逐层进行节点比较" class="headerlink" title="逐层进行节点比较"></a>逐层进行节点比较</h5><p>在React中，树的算法其实非常简单，那就是两棵树只会对同一层次的节点进行比较。</p><img src="/2018/04/11/react-deep-learn/react-study.png" alt="react-study.png" title=""><p>React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。</p><p>有如下的节点树变换：</p><img src="/2018/04/11/react-deep-learn/dom-transform.png" alt="dom-transform.png" title=""><p>A节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>parent.remove(A); </div><div class="line"><span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>append(A);</div></pre></td></tr></table></figure><ul><li><h5 id="节点类型相同"><a href="#节点类型相同" class="headerlink" title="节点类型相同"></a>节点类型相同</h5></li></ul><p>React会对属性进行重设从而实现节点的转换。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div id=<span class="string">"before"</span> /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;div id=<span class="string">"after"</span> /&gt;</div><div class="line">=&gt; [replaceAttribute id <span class="string">"after"</span>]</div></pre></td></tr></table></figure><p>虚拟DOM的style属性稍有不同，其值并不是一个简单字符串而必须为一个对象，因此转换过程如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div style=&#123;&#123;col<span class="symbol">or:</span> 'red'&#125;&#125; /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;div style=&#123;&#123;fontWeig<span class="symbol">ht:</span> 'bold'&#125;&#125; /&gt;</div><div class="line">=&gt; [removeStyle color], [addStyle font-weight 'bold']</div></pre></td></tr></table></figure><h5 id="列表节点的比较"><a href="#列表节点的比较" class="headerlink" title="列表节点的比较"></a>列表节点的比较</h5><p>​    上面介绍了对于不在同一层的节点的比较，即使它们完全一样，也会销毁并重新创建。那么当它们在同一层时，又是如何处理的呢？这就涉及到列表节点的Diff算法。相信很多使用React的同学大多遇到过这样的警告：</p><img src="/2018/04/11/react-deep-learn/react-warning.png" alt="react-warning.png" title=""><p>这是React在遇到列表时却又找不到key时提示的警告。虽然无视这条警告大部分界面也会正确工作，但这通常意味着潜在的性能问题。因为React觉得自己可能无法高效的去更新这个列表。</p><p>​    列表节点的操作通常包括添加、删除和排序。例如下图，我们需要往B和C直接插入节点F，在jQuery中我们可能会直接使用$(B).after(F)来实现。而在React中，我们只会告诉React新的界面应该是A-B-F-C-D-E，由Diff算法完成更新界面。</p><img src="/2018/04/11/react-deep-learn/react-diif-1.png" alt="react-diif-1.png" title=""><p>这时如果每个节点都没有唯一的标识，React无法识别每一个节点，那么更新过程会很低效，即，将C更新成F，D更新成C，E更新成D，最后再插入一个E节点。效果如下图所示：</p><img src="/2018/04/11/react-deep-learn/react-diff-2.png" alt="react-diff-2.png" title=""><p>可以看到，React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点E，涉及到的DOM操作非常多。而如果给每个节点唯一的标识（key），那么React能够找到正确的位置去插入新的节点，入下图所示：</p><img src="/2018/04/11/react-deep-learn/react-diff-3.png" alt="react-diff-3.png" title=""><h3 id="diff算法对代码的影响"><a href="#diff算法对代码的影响" class="headerlink" title="diff算法对代码的影响"></a>diff算法对代码的影响</h3><ul><li>由于diff算法对于DOM树的添加删除的特点，保持稳定的DOM结构会有助于性能的提升。</li><li>对于列表节点提供唯一的key属性可以帮助React定位到正确的节点进行比较，从而大幅减少DOM操作次数，提高了性能。</li></ul><h2 id="setState究竟干了些什么"><a href="#setState究竟干了些什么" class="headerlink" title="setState究竟干了些什么"></a>setState究竟干了些什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">constructor() &#123;</div><div class="line">    super();</div><div class="line">    this.state = &#123;</div><div class="line">      val: 0</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">    console.log(this.state.val);    // 第 1 次 log</div><div class="line"></div><div class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">    console.log(this.state.val);    // 第 2 次 log</div><div class="line"></div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">      console.log(this.state.val);  // 第 3 次 log</div><div class="line"></div><div class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">      console.log(this.state.val);  // 第 4 次 log</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">&gt; 问上述代码中 4 次 console.log 打印出来的 val 分别是多少？</div><div class="line">&gt; 答案：4 次 log 的值分别是：0、0、2、3。</div></pre></td></tr></table></figure><p>上述面试题说明了，setState方法并不是同步的，也不是异步的。这牵扯到了react的更新机制。</p><p>以下是翻自官方setState原代码的注解，官网的说明也是类似:</p><blockquote><p>不保证<code>this.state</code>会立即更新，所以在调用这个方法后存取<code>this.state</code>可能会回传旧的值。</p><p>不保证呼叫<code>setState</code>就会同步地执行，而它们也可能最终被被批量调用(多次呼叫的情况下)。你可以提供额外的回调(callback)，回调(callback)将会在<code>setState</code>实际被完成时被执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/11/react-deep-learn/react-deep-learn.png&quot; alt=&quot;react-deep-learn.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;虚拟dom&quot;&gt;&lt;a href=&quot;#虚拟dom&quot; class=&quot;headerlink&quot; title=&quot;虚拟dom&quot;&gt;&lt;/a&gt;虚拟dom&lt;/h2&gt;&lt;p&gt;​    在react中，render执行的结果并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。虚拟DOM具有batching(批处理)和高效的Diff算法。由虚拟DOM来确保只对界面上真正的部分进行实际的DOM操作。&lt;/p&gt;
&lt;p&gt;​    比较innerHTML 和Virtual DOM 的重绘过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innerHTML: render html string + 重新创建所有 DOM 元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Virtual DOM: render Virtual DOM + diff算法+ 必要的 DOM 更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;批量DOM处理&quot;&gt;&lt;a href=&quot;#批量DOM处理&quot; class=&quot;headerlink&quot; title=&quot;批量DOM处理&quot;&gt;&lt;/a&gt;批量DOM处理&lt;/h4&gt;&lt;p&gt;​    依靠 setState 的异步性，React在一段时间间隔内，将所有DOM更新收集起来，然后批量处理。也就是说调用setState的时候并不会立即更新状态，而是一段时间时候统一将变动的属性集体进行更新。从而达到减少渲染次数，提高性能的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://mah93.github.io/2018/02/26/science-net/"/>
    <id>https://mah93.github.io/2018/02/26/science-net/</id>
    <published>2018-02-26T03:36:09.000Z</published>
    <updated>2018-12-25T04:40:49.462Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/26/science-net/science-network.png" alt="science-network.png" title=""><blockquote><p>由于特殊的情况，出差所在的地方同性交友网站上不去，CSDN打不开，百度云盘用不了（不要问我问什么。记录一下自己是如何走在被查水表的路上。</p></blockquote><p>科学上网的方式有很多种，可以自己购买一台位于国外的VPS服务器搭建SS客户端，自己手动搭梯子。如果是懒得自己折腾可以购买VPN账号，但是很多的VPN服务商不稳定，有可能用着用着就被封了。所以一个月一个月买比较靠谱。这里说明一下购买账号后的操作。</p><h4 id="下载Shadowsocks客户端"><a href="#下载Shadowsocks客户端" class="headerlink" title="下载Shadowsocks客户端"></a>下载Shadowsocks客户端</h4><p>自行百度下载的方式，下载好之后。双击打开，把买入的账号填进去，点击确定。</p><p>启用系统代理即可。</p><p>打开浏览器，就可以开始你的科学上网之旅了。</p><p>如果你的账号不限制设备，并且想用手机同时用。可以在手机市场搜索Shadowsocks，同样的配置。iOS用户可以用SsrConnectPro。</p><h4 id="特殊环境引起的问题"><a href="#特殊环境引起的问题" class="headerlink" title="特殊环境引起的问题"></a>特殊环境引起的问题</h4><p>上述配置完成之后，依然不能访问到github，将ss的代理模式更改为全局代理。</p><p>即使是全局模式，命令行中，依然访问不到github。</p><p>查看Shadowsocks的本地代理端口，一般是1087端口。</p><p>打开命令行</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi .gitconfig</div><div class="line">`在git的配置文件中添加http和https的代理`</div><div class="line">[http]</div><div class="line">proxy = http:<span class="comment">//localhost:1087</span></div><div class="line">[https]</div><div class="line">proxy = https:<span class="comment">//localhost:1087</span></div><div class="line">`如果需要使用coding等国内的代码托管服务，请注释以上四行配置`</div></pre></td></tr></table></figure><p>配置并保存后，就可以和github上的好基友玩耍了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/02/26/science-net/science-network.png&quot; alt=&quot;science-network.png&quot; title=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;由于特殊的情况，出差所在的地方同性交友网站上不去，CSDN打不开，
      
    
    </summary>
    
      <category term="工具" scheme="https://mah93.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://mah93.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jenkins小结</title>
    <link href="https://mah93.github.io/2018/02/01/jenkins-summary/"/>
    <id>https://mah93.github.io/2018/02/01/jenkins-summary/</id>
    <published>2018-02-01T10:51:50.000Z</published>
    <updated>2018-12-25T04:41:58.639Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/01/jenkins-summary/jenkins_logo.jpg" alt="jenkins_logo.jpg" title=""><h3 id="what’s-jenkins"><a href="#what’s-jenkins" class="headerlink" title="what’s jenkins?"></a>what’s jenkins?</h3><blockquote><p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p><p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p></blockquote><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p><a id="more"></a> <h3 id="安装（centOS）"><a href="#安装（centOS）" class="headerlink" title="安装（centOS）"></a>安装（centOS）</h3><p>在centOS系统中，使用yum安装</p><ul><li>创建 <code>jenkins</code>的 <code>yum</code>的源文件</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/jenkins.repo</div></pre></td></tr></table></figure><p>在 <code>jenkins.repo</code>中加入以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">[jenkins]</span></div><div class="line"><span class="attr">name</span>=Jenkins</div><div class="line"><span class="attr">baseurl</span>=http://pkg.jenkins-ci.org/redhat</div><div class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></div></pre></td></tr></table></figure><ul><li><code>rpm</code>增加<code>jenkins</code>源的<code>key</code></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>sudo rpm --<span class="keyword">import</span> <span class="symbol">http:</span>/<span class="regexp">/pkg.jenkins-ci.org/redhat</span><span class="regexp">/jenkins-ci.org.key</span></div></pre></td></tr></table></figure><ul><li>安装 <code>jenkins</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum <span class="keyword">install</span> jenkins</div></pre></td></tr></table></figure><ul><li>配置Jenkins文件（可跳过）</li></ul><p>主要可以配置<code>jenkins</code>的运行端口和监听端口，以及启动用户，配置文件地址为<code>/etc/sysconfig/jenkins</code>，下面为主要修改内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /etc/sysconfig/jenkins</div><div class="line"><span class="comment"># 修改启动用户为root,默认为jenkins</span></div><div class="line">JENKINS_USER=<span class="string">"root"</span></div><div class="line"><span class="comment"># 修改运行端口为9999，默认为8080</span></div><div class="line">JENKINS_PORT=<span class="string">"9999"</span></div></pre></td></tr></table></figure><ul><li>启动<code>jenkins</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo<span class="built_in"> service </span>jenkins start</div></pre></td></tr></table></figure><p>访问相应端口号即可访问jenkins主页</p><h3 id="安装（其他系统）"><a href="#安装（其他系统）" class="headerlink" title="安装（其他系统）"></a>安装（其他系统）</h3><p>直接在<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>中下载相应的<em>war包</em>，下载完成后，打开终端，进入到war包所在目录，执行以下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">java </span>-<span class="keyword">jar </span><span class="keyword">jenkins.war </span>--httpPort=<span class="number">8888</span></div></pre></td></tr></table></figure><p>httpPort指的就是Jenkins所使用的http端口，这里指定8888，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入相应地址</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>第一次打开jenkins，需要输入密码</p><img src="/2018/02/01/jenkins-summary/jenkins.jpg" alt="jenkins.jpg" title=""><p>密码文件<code>/var/lib/jenkins/secrets/initialAdminPassword</code>, 然后填入点击<code>Continue</code></p><blockquote><p>如果忘记密码了，打开JENKINS_HOME/users目录下忘记密码的用户名文件夹，里面有一个config.xml。找到<passwordhash>节点，把里面的内容换成jbcrypt:$2a$10$DdaWzN64JgUtLdvxWIflcuQu2fgrrMSAMabF5TSrGK5nXitqK9ZMS</passwordhash></p><p>保存并重启jenkins，再次登陆jenkins，密码重置为111111</p></blockquote><p>打开jenkins首页如下：</p><img src="/2018/02/01/jenkins-summary/jenkins_home.jpg" alt="jenkins_home.jpg" title=""><h3 id="安装plugin"><a href="#安装plugin" class="headerlink" title="安装plugin"></a>安装plugin</h3><p>Jenkins支持很多的plugin，这些plugin极大地丰富了Jenkins的功能。安装plugin有两种方式：自动安装和手动安装。</p><ul><li><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>在首页中选中系统管理</p></li></ul><img src="/2018/02/01/jenkins-summary/jenkins_menu.png" alt="jenkins_menu.png" title=""><p>点击插件管理</p><img src="/2018/02/01/jenkins-summary/jenkins_plugin.png" alt="jenkins_plugin.png" title=""><p>在可选插件中，选择需要的plugin并直接安装。</p><blockquote><p>在可选插件列表中没有显示任何plugin</p><p>选择插件管理-高级-升级站点-更改URL为</p><p><code>[http://mirror.xmission.com/jenkins/updates/update-center.json]</code>-点击提交即可</p></blockquote><ul><li><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4></li></ul><p>如果说在列表中搜索不到，还可以前往<a href="https://plugins.jenkins.io/" target="_blank" rel="external">jenkins plugin</a>下载，进行手动安装</p><p>选择在『高级』标签下，上传插件栏中点击选择文件：</p><img src="/2018/02/01/jenkins-summary/jenkins_upload.png" alt="jenkins_upload.png" title=""><p>点击上传按钮，便会自动上传并安装。</p><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>安装好必要的plugin之后，就可以开始构建自己的项目了，在菜单中选择新建，输入项目名并选择构建一个自由风格的软件项目：</p><img src="/2018/02/01/jenkins-summary/jenkins_build.png" alt="jenkins_build.png" title=""><p>点击ok后，进入构建配置页面。可以根据项目需求，去配置触发器、搭建构建环境、构建脚本以及构建后部署或者其他操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/01/jenkins-summary/jenkins_logo.jpg&quot; alt=&quot;jenkins_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;what’s-jenkins&quot;&gt;&lt;a href=&quot;#what’s-jenkins&quot; class=&quot;headerlink&quot; title=&quot;what’s jenkins?&quot;&gt;&lt;/a&gt;what’s jenkins?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。&lt;/p&gt;
&lt;p&gt;持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;
    
    </summary>
    
      <category term="Jenkins" scheme="https://mah93.github.io/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://mah93.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Locust使用说明</title>
    <link href="https://mah93.github.io/2017/12/23/locust-introduce/"/>
    <id>https://mah93.github.io/2017/12/23/locust-introduce/</id>
    <published>2017-12-23T14:13:20.000Z</published>
    <updated>2018-12-25T04:41:51.767Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/23/locust-introduce/locust_logo@2x.png" alt="locust_logo@2x.png" title=""><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/locustio/locust" target="_blank" rel="external">Locust</a> 是一个开源负载测试工具。使用python代码定义用户行为，也可以仿真百万个用户。</p><p>Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。</p><p>Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式gevent。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>使用纯 Python 代码编写用户测试场景；不需要 UIs 或者 XML</li><li>分布式&amp;可伸缩 - 支持成千上万的用户</li><li>基于 Web 的 UI</li><li>可以测试任意系统；虽然 Locust 是面向 Web 的，但是也可以测试其他任意的系统</li></ul><a id="more"></a> <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>安装Python2 或Python3，通过命令行或者是官网安装</p><h3 id="安装Locust"><a href="#安装Locust" class="headerlink" title="安装Locust"></a>安装Locust</h3><p>通过pip命令安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip  install --<span class="built_in">index</span> http<span class="variable">s:</span>//pypi.mirrors.ustc.edu.<span class="keyword">cn</span>/simple/ locust</div></pre></td></tr></table></figure><p>安装完成后，命令行中验证</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locust <span class="comment">--help</span></div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建test-py"><a href="#创建test-py" class="headerlink" title="创建test.py"></a>创建test.py</h3><p>创建一个test.py，然后编辑</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from locust import HttpLocust, TaskSet, task</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span>(<span class="title">TaskSet</span>):</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        pass</div><div class="line">        </div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.post(<span class="string">"/login"</span>, &#123;</div><div class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</div><div class="line">            <span class="string">"password"</span>: <span class="string">""</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.get(<span class="string">"/"</span>)</div><div class="line"></div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.get(<span class="string">"/about/"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span>(<span class="title">HttpLocust</span>):</span></div><div class="line">    task_set = WebsiteTasks</div><div class="line">    min_wait = <span class="number">5000</span></div><div class="line">    max_wait = <span class="number">15000</span></div></pre></td></tr></table></figure><p>task_set：任务指定的方法</p><p>min_wait：最小等待时间（ms）</p><p>max_ wait：最大等待时间（ms）</p><p>on_start：会首先执行该方法</p><p>@task（1）：单个任务（权重）</p><p>每次执行任务，会在最小等待时间到最大等待时间中随机执行，按照task的权重执行某一任务</p><h3 id="自定义成功失败"><a href="#自定义成功失败" class="headerlink" title="自定义成功失败"></a>自定义成功失败</h3><p>locust会根据一次请求的状态码来确定该次请求是否成功，并表现在界面上。</p><p>当需要测试的接口，涉及到业务。就需要根据返回的数据来判断该次请求是否成功</p><p>需要将post请求改成以下方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with self<span class="selector-class">.client</span><span class="selector-class">.post</span>(<span class="string">"/login"</span>, &#123;<span class="string">"username"</span>: <span class="string">"test_user"</span>,<span class="string">"password"</span>: <span class="string">"123"</span>&#125;) as response:</div><div class="line">        response.success(<span class="string">'success'</span>)<span class="comment">//成功</span></div><div class="line">        response.failure(<span class="string">'error'</span>)<span class="comment">//失败</span></div></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>编辑完test.py之后，在命令行中输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locust -f <span class="string">./test.py</span> <span class="params">--host=</span>你的服务器地址</div></pre></td></tr></table></figure><p>没有报错之后，打开本地8089端口，即可看到locust的测试页面</p><img src="/2017/12/23/locust-introduce/locust.png" alt="locust-home" title="locust-home"><p>输入所需测试强度，即可开始测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/23/locust-introduce/locust_logo@2x.png&quot; alt=&quot;locust_logo@2x.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/locustio/locust&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Locust&lt;/a&gt; 是一个开源负载测试工具。使用python代码定义用户行为，也可以仿真百万个用户。&lt;/p&gt;
&lt;p&gt;Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。&lt;/p&gt;
&lt;p&gt;Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式gevent。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用纯 Python 代码编写用户测试场景；不需要 UIs 或者 XML&lt;/li&gt;
&lt;li&gt;分布式&amp;amp;可伸缩 - 支持成千上万的用户&lt;/li&gt;
&lt;li&gt;基于 Web 的 UI&lt;/li&gt;
&lt;li&gt;可以测试任意系统；虽然 Locust 是面向 Web 的，但是也可以测试其他任意的系统&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="https://mah93.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mah93.github.io/tags/Python/"/>
    
      <category term="Locust" scheme="https://mah93.github.io/tags/Locust/"/>
    
  </entry>
  
</feed>
