<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mah93</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mah93.github.io/"/>
  <updated>2020-07-09T02:29:35.535Z</updated>
  <id>https://mah93.github.io/</id>
  
  <author>
    <name>mah93</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Symbol、Proxy、Reflect学习摘要</title>
    <link href="https://mah93.github.io/2020/07/09/es6-summary/"/>
    <id>https://mah93.github.io/2020/07/09/es6-summary/</id>
    <published>2020-07-09T02:24:15.000Z</published>
    <updated>2020-07-09T02:29:35.535Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/07/09/es6-summary/es6-logo.jpg" alt="es6-logo.jpg" title=""><h2 id="Symbol概述"><a href="#Symbol概述" class="headerlink" title="Symbol概述"></a>Symbol概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p><code>Symbol</code>表示独一无二的值，它是 JavaScript 语言的<strong>第七种数据类型</strong></p><a id="more"></a> <blockquote><p>其他六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</p><p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，而不是对象</p></blockquote><h2 id="Symbol使用"><a href="#Symbol使用" class="headerlink" title="Symbol使用"></a>Symbol使用</h2><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"></div><div class="line">s1 <span class="comment">// Symbol(foo)</span></div><div class="line">s2 <span class="comment">// Symbol(bar)</span></div><div class="line"></div><div class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></div><div class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></div></pre></td></tr></table></figure><p><code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没有参数的情况</span></div><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 有参数的情况</span></div><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div></pre></td></tr></table></figure><p><code>Symbol</code>类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> log = &#123;&#125;;</div><div class="line"></div><div class="line">log.levels = &#123;</div><div class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</div><div class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</div><div class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>);</div><div class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>);</div></pre></td></tr></table></figure><h3 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h3><p><code>Symbol.for()</code>它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// true</span></div></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><blockquote><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p></blockquote><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></div></pre></td></tr></table></figure><blockquote><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p></blockquote><h2 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h2><p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（<code>meta programming</code>），即对编程语言进行编程。</p><p><code>Proxy</code>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code>这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h2 id="Proxy使用"><a href="#Proxy使用" class="headerlink" title="Proxy使用"></a>Proxy使用</h2><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div></pre></td></tr></table></figure><p><code>Proxy</code> 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> handler = &#123;</div><div class="line">    get(target, propKey, receiver) &#123;</div><div class="line">      <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</div><div class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">        propKey = <span class="built_in">String</span>(target.length + index);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> target = [];</div><div class="line">  target.push(...elements);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</div><div class="line">arr[<span class="number">-1</span>] <span class="comment">// c</span></div></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pipe = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> funcStack = [];</div><div class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</div><div class="line">    get : <span class="function"><span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> fn(val);</div><div class="line">        &#125;,value);</div><div class="line">      &#125;</div><div class="line">      funcStack.push(<span class="built_in">window</span>[fnName]);</div><div class="line">      <span class="keyword">return</span> oproxy;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> oproxy;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</div><div class="line"><span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</div><div class="line"></div><div class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></div></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 新写法</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法</span></div><div class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 新写法</span></div><div class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Proxy</span>(target, &#123;</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target, name, value, receiver);</div><div class="line">    <span class="keyword">if</span> (success) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> success;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰 ECMAScript 6 入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/07/09/es6-summary/es6-logo.jpg&quot; alt=&quot;es6-logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Symbol概述&quot;&gt;&lt;a href=&quot;#Symbol概述&quot; class=&quot;headerlink&quot; title=&quot;Symbol概述&quot;&gt;&lt;/a&gt;Symbol概述&lt;/h2&gt;&lt;p&gt;ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入&lt;code&gt;Symbol&lt;/code&gt;的原因。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt;表示独一无二的值，它是 JavaScript 语言的&lt;strong&gt;第七种数据类型&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>啥是docker</title>
    <link href="https://mah93.github.io/2020/01/08/what-is-docker/"/>
    <id>https://mah93.github.io/2020/01/08/what-is-docker/</id>
    <published>2020-01-08T09:28:05.000Z</published>
    <updated>2020-01-08T09:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/08/what-is-docker/docker_logo.png" alt="docker_logo.png" title=""><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><a id="more"></a> <h2 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="安装Docker-Desktop"><a href="#安装Docker-Desktop" class="headerlink" title="安装Docker Desktop"></a>安装Docker Desktop</h2><p>在docker官网上注册之后，下载desktop客户端</p><img src="/2020/01/08/what-is-docker/docker_desktop.png" alt="docker_desktop.png" title=""><p>选择平台之后双击安装即可，安装之后在命令行中输入docker得到相应输出后，即安装完成</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker search</td><td>查找所以可用软件包</td></tr><tr><td>docker pull</td><td>获取软件包</td></tr><tr><td>docker images</td><td>查看本地镜像</td></tr><tr><td>docker ps -a</td><td>查看正在运行的容器</td></tr><tr><td>docker rm</td><td>删除容器</td></tr><tr><td>docker run</td><td>运行容器</td></tr><tr><td>docker rmi</td><td>删除镜像</td></tr></tbody></table><h2 id="例子：安装redis"><a href="#例子：安装redis" class="headerlink" title="例子：安装redis"></a>例子：安装redis</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> docker search redis</div><div class="line"><span class="symbol">$</span> docker pull redis</div><div class="line"><span class="symbol">$</span> docker run -p <span class="number">6379</span>:<span class="number">6379</span> -v <span class="symbol">$</span>PWD/data:/data  -d redis:latest redis-server --appendonly <span class="keyword">yes</span></div><div class="line"><span class="symbol">$</span> docker run -it redis:latest redis-cli -h <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span></div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="[http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html](http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/08/what-is-docker/docker_logo.png&quot; alt=&quot;docker_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Docker是什么&quot;&gt;&lt;a href=&quot;#Docker是什么&quot; class=&quot;headerlink&quot; title=&quot;Docker是什么&quot;&gt;&lt;/a&gt;Docker是什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。&lt;/strong&gt;它是目前最流行的 Linux 容器解决方案。&lt;/p&gt;
&lt;p&gt;Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。&lt;/p&gt;
&lt;p&gt;总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://mah93.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://mah93.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记</title>
    <link href="https://mah93.github.io/2019/12/30/iOS-learn/"/>
    <id>https://mah93.github.io/2019/12/30/iOS-learn/</id>
    <published>2019-12-30T09:28:57.000Z</published>
    <updated>2020-07-09T02:28:29.192Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/12/30/iOS-learn/iOS-intro.png" alt="iOS-intro.png" title=""><p>以下笔记是边看视频课程边记录下来的，供以后自己查阅复习使用</p><h2 id="Runtime学习笔记1"><a href="#Runtime学习笔记1" class="headerlink" title="Runtime学习笔记1"></a>Runtime学习笔记1</h2><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>在OC中，调用方法其实是给对象发送消息</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[Person <span class="keyword">new</span>] <span class="string">sendMessage:</span>@<span class="string">"gelo"</span>];</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">objc_msgSend([Person <span class="keyword">new</span>], <span class="meta">@selector</span>(<span class="string">sendMessage:</span>), <span class="string">"gelo"</span>);</div></pre></td></tr></table></figure><p>通过对象的isa指针找到class，如果有方法的话，直接调用。没有找到的话，通过继承树查找，进入消息转发机制</p><a id="more"></a> <img src="/2019/12/30/iOS-learn/runtime-forwardflow.png" alt="runtime-forwardflow.png" title=""><p>动态方法解析，动态添加方法实现  </p><p>​    resolveInstanceMethod</p><p>快速转发，当前的类或者继承树没有该方法的实现，在更加广的范围寻找</p><p>​    forwardingTargetForSelector</p><p>慢速转发</p><p>​    methodSignatureForSelector</p><p>​    forwardInvocation</p><p>doesNotRecognizeSelector:</p><h3 id="方法交换-Method-Swizzling"><a href="#方法交换-Method-Swizzling" class="headerlink" title="方法交换 Method Swizzling"></a>方法交换 Method Swizzling</h3><p>用自己写的方法替换系统方法，通过class_getInstanceMethod方法获取，通过method_exchangeImplementations交换两个函数</p><h3 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h3><p>遍历字典获取key和value</p><p>key作为属性名，value作为属性值</p><p>通过objc_msgSend发送set方法</p><h3 id="模型转字典"><a href="#模型转字典" class="headerlink" title="模型转字典"></a>模型转字典</h3><p>字典的key通过模型的属性列表获取</p><p>字典的value通过调用get方法获取</p><h3 id="实现KVO"><a href="#实现KVO" class="headerlink" title="实现KVO"></a>实现KVO</h3><p>KVO是基于runtime的</p><p>A监听B 系统会为B创建一个子类 </p><p>B的isa指针指向B的子类</p><p>在子类中重新set方法</p><h2 id="KVO底层实现"><a href="#KVO底层实现" class="headerlink" title="KVO底层实现"></a>KVO底层实现</h2><h3 id="KVO的基础使用"><a href="#KVO的基础使用" class="headerlink" title="KVO的基础使用"></a>KVO的基础使用</h3><p>观察某一个对象的某个属性</p><p>options参数可以观察一下几个值</p><p>new  返回变化后的新值</p><p>old    返回变化前的旧值</p><p>init    注册的时候就会发一次通知，改变后的值的时候也会发送</p><p>prior  新值和旧值都会返回</p><p>KVO默认是自动模式，每次修改值都会发送通知</p><p>手动发送通知的时候，对象调用willchangeValueForKey，改变之后调用didchangeValueForKey</p><p>监听属性下面的属性值，只需要在监听path中通过点监听：”dog.age”（属性依赖）</p><p>KVO监听的是set方法。比如监听不到数组的add方法</p><p>要是需要监听容器方法，需要结合KVC</p><p>需要监听对象下多个属性，只需要监听对象本身，并实现keyPat<em>*</em>ForKey。返回需要的真正监听的内部属性的NSSet</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>属性是对成员变量和set、get方法的封装</p><p>KVO观察的是set方法（设置成员变量之后，外部通过person-&gt;name方法修改，KVO监听不到）通过runtime创建一个观察者的子类（NSKVONotifying_Person）重写set方法。修改指针到子类、在重写的方法里面调用willchangeValueForKey、superSetName、didchangeValueForKey。</p><p>在创建的子类中，没有父类的set方法！需要重写set方法</p><p>OC的方法中包含SEL（方法编号）、IMP（方法实现）一一对应。调用方法的时候发送的是SEL</p><p>OC的方法调用里面有两个默认参数：id self，SEL _cmd。由于sendMsg传递了该参数（调用者以及SEL）</p><h3 id="监听容器类（NSArray、NSDic）"><a href="#监听容器类（NSArray、NSDic）" class="headerlink" title="监听容器类（NSArray、NSDic）"></a>监听容器类（NSArray、NSDic）</h3><p>通过KVO观察容器属性的变化，利用KVC</p><p>通过KVC的mutableArray**ForKey返回一个容器对象，向该对象添加元素可以实现KVO。内部新建子类、重写add方法。</p><p>KVO返回的NSDic中，kind类型</p><p>观察set方法 返回1</p><p>观察插入方法 返回2</p><p>观察删除方法 返回3</p><p>观察替换方法 返回4</p><h3 id="数组中count"><a href="#数组中count" class="headerlink" title="数组中count"></a>数组中count</h3><p>使用KVO中监听不到数组中的count、使用KVC同样取不到[array valueForKey:@”count”]</p><p>count是集合运算符，KVC需要用@”@count”取值。</p><p>count是只读属性</p><h2 id="数组（NSMutableArray）"><a href="#数组（NSMutableArray）" class="headerlink" title="数组（NSMutableArray）"></a>数组（NSMutableArray）</h2><p>关于数组的容量，容量不够用的时候，会成倍的增加</p><p>对象本身是指针，指向该对象的结构体</p><p>x/100xb arr 打印arr 100个内存地址</p><p>找到count的内存地址，修改内存地址的值，进而可以修改count的值</p><h2 id="Runtime学习笔记2"><a href="#Runtime学习笔记2" class="headerlink" title="Runtime学习笔记2"></a>Runtime学习笔记2</h2><h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><p>OC代码会转化为C语言执行，使用runtime的时候，需要关闭代码的严格检测</p><p>调用函数的方法：</p><p>[p eat]</p><p>[p performSelector: SEL]</p><p>objc_msgSend()</p><p>使用runtime创建对象：<br>类名.class即为对象  Person.class  ==   objc_getClass(“Person”)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在目录下执行</span></div><div class="line">clang --rewrite-objc main.m</div><div class="line"><span class="comment">// 手动编译OC代码生成cpp文件</span></div></pre></td></tr></table></figure><h3 id="归档-解档"><a href="#归档-解档" class="headerlink" title="归档/解档"></a>归档/解档</h3><p>归档和解档对象，需要遵循NSCoding的协议，并且实现协议方法</p><p>KVC可以使用id类型为属性赋值</p><p>Ivar：成员变量</p><p>Method：成员方法</p><p><strong>C语言 基本数据类型的指针  函数内部是为了修改外部的值</strong></p><p>class_copyIvarList获取所有属性数量</p><p>关键字copy、new、creat代表着会在堆区域（malloc）开辟空间</p><p>方法执行完毕—&gt;方法调用栈平衡—&gt;内部变量指针出栈—&gt;但是指针指向的堆区的值还在—&gt;内存泄漏</p><p>在OC中使用C的代码，要手动释放指针，防止内存溢出</p><h3 id="OC方法定位以及替换"><a href="#OC方法定位以及替换" class="headerlink" title="OC方法定位以及替换"></a>OC方法定位以及替换</h3><p>OC的方法表：返回值类型+参数类型一样  编号就一样</p><p>​                类</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>SEL 编号   —————  IMP实现（地址指针）</p><p>用HOOK！钩住系统方法，在调用之前修改方法的调用</p><p>在分类中的load方法（由于预加载，比main更早执行）中交换IMP</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="comment">// 获取替换后的类方法</span></div><div class="line">    Method otherMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNameNextWith:));</div><div class="line">    <span class="comment">// 获取替换前的类方法</span></div><div class="line">    Method method = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</div><div class="line">    <span class="comment">// 然后交换类方法</span></div><div class="line">    method_exchangeImplementations(otherMethod, method);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">UIImage</span> *)imageNameNextWith:(<span class="built_in">NSString</span> *)nameString &#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</div><div class="line">    image = [<span class="built_in">UIImage</span> imageNameNextWith:[nameString stringByAppendingString:<span class="string">@"tupian.jpg"</span>]];</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于在imageNameNextWith中调用自身，并不会引起循环引用。</p><p>交换之前</p><p>SEL（系统方法：ImageNamed） —————&gt;   IMP（系统方法：ImageNamed的实现地址指针）</p><p>SEL（自己的方法：ImageNamedNextWith） —————&gt;   IMP（自己的方法：ImageNamedNextWith的实现地址指针）</p><p>交换之后</p><p>SEL（系统方法：ImageNamed） —————&gt;   IMP（自己的方法：ImageNamedNextWith的实现地址指针）</p><p>SEL（自己的方法：ImageNamedNextWith） —————&gt;   IMP（系统方法：ImageNamed的实现地址指针）</p><p>交换之后，每当再次调用imageNameNextWith方法的时候，<strong>实际上执行的是系统方法ImageNamed指向的方法实现</strong>，所以不会引起循环调用。</p><p>OC对象本质上是指针占用8个字节</p><p><strong>OC方法调用顺序：消息发送——&gt;SEL——&gt;IMP——&gt;代码——&gt;函数——&gt;汇编</strong></p><h2 id="函数响应式编程RAC"><a href="#函数响应式编程RAC" class="headerlink" title="函数响应式编程RAC"></a>函数响应式编程RAC</h2><h3 id="RAC的代理"><a href="#RAC的代理" class="headerlink" title="RAC的代理"></a>RAC的代理</h3><p>RAC里面内部实现类似于通知</p><ol><li>创建信号 提供外界订阅</li></ol><p>创建了一个容量为1的可变数组_subscribers</p><p>支持多个订阅者订阅该信号</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RACSubject *subject = [RACSubject subject]<span class="comment">;</span></div></pre></td></tr></table></figure><ol><li>订阅信号（注册通知）</li></ol><p>创建订阅者对象</p><p>将Block放到订阅者对象中</p><p>将订阅者对象放入_subscribers里面</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[subject subscribeNext:^(<span class="name"><span class="builtin-name">id</span></span>)&#123;</div><div class="line">  // 函数式编程，免除了遵循协议，引用方法的步骤</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><ol><li>发送信号（发起通知）</li></ol><p>遍历_subscribers取出中的订阅者对象</p><p>执行订阅者对象中的Block</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[subject sentNext:@"hahha]</span><span class="comment">;</span></div></pre></td></tr></table></figure><p>RAC中可以使用Selector通过方法名称创建信号，直接订阅</p><h3 id="RAC中的KVO"><a href="#RAC中的KVO" class="headerlink" title="RAC中的KVO"></a>RAC中的KVO</h3><p>RAC可以直接用Block回调，在观察多个属性的时候，可以避免在回调函数中判断。</p><p>RAC同样不能观察到数组的count</p><h3 id="RAC监听事件"><a href="#RAC监听事件" class="headerlink" title="RAC监听事件"></a>RAC监听事件</h3><p>将按钮的点击事件包装成信号，订阅</p><h3 id="RAC中的Timer"><a href="#RAC中的Timer" class="headerlink" title="RAC中的Timer"></a>RAC中的Timer</h3><p>使用NSTimer的时候，创建完之后需要添加到NSRunLoop中</p><p>在NSTread子线程中需要手动启动NSRunLoop</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] run]</div></pre></td></tr></table></figure><p>RAC中通过信号创建子线程并发Timer，底层使用GCD创建</p><h3 id="RAC中的宏定义"><a href="#RAC中的宏定义" class="headerlink" title="RAC中的宏定义"></a>RAC中的宏定义</h3><p>当输入框内容发生变化，相应更新到_label上</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="constructor">RAC(<span class="params">_label</span>, <span class="params">text</span>)</span> = <span class="module-access"><span class="module"><span class="identifier">_textField</span>.</span></span>rac_textSignal;</div></pre></td></tr></table></figure><p>只要对象的属性发生改变，就会产生信号</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">RACObserver</span>(<span class="params">self, name</span>)</span> sub....</div></pre></td></tr></table></figure><p>关于Block中的循环引用，但是在特殊情况下是允许循环应用的出现</p><p>NSURLSession中的delegate是强引用，目的是发送请求的时候只需要一个对象。是单例</p><p>使用强引用，并不会销毁，导致内存泄漏</p><h2 id="Socket探索"><a href="#Socket探索" class="headerlink" title="Socket探索"></a>Socket探索</h2><p>IP地址可以在网络上定位到一台终端设备</p><p>端口号可以访问到设备上的服务：比如80端口为Apache端口服务</p><p>网络的七层协议从上至下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p>标准帧格式数据包</p><p>socket处于传输层、IP/TCP协议在网络层</p><h3 id="TCP与UDP协议的区别"><a href="#TCP与UDP协议的区别" class="headerlink" title="TCP与UDP协议的区别"></a>TCP与UDP协议的区别</h3><p>UDP（用户数据报协议）短信</p><p>​    只管发送，不确认对方是否收到</p><p>​    将数据及源和目的封装成数据包中，不需要建立连接</p><p>​    每个数据报大小限制在64k</p><p>​    因为无需连接，因此是不可靠协议</p><p>​    不需要连接，速度快</p><p>TCP（传输控制协议）电话</p><p>​    建立连接，形成传输数据通道</p><p>​    在连接中进行大数据传输（数据大小不受限制）</p><p>​    通过三次握手连接，是可靠的协议，安全送达</p><p>​    必须建立连接，效率稍低</p><p>直播推流、游戏是UDP协议，下载的过程是TCP协议</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>类比插座，socket需要两端的IP+端口号建立连接</p><ol><li>创建socket</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> domain：  协议域 <span class="type">AF_INET</span> = <span class="type">IPV4</span>   <span class="type">IPV6</span></div><div class="line"> <span class="class"><span class="keyword">type</span>：    <span class="type">Socket</span>类型 <span class="type">SOCK_STREAM</span>(<span class="type">TCP</span>)/<span class="type">SOCK_DGRAM</span>(<span class="type">UDP</span>)</span></div><div class="line"> protocol： <span class="type">IPPROTO_TCP</span>, 传入<span class="number">0</span>， 会自动根据第二个值选择合适的协议</div><div class="line">*/</div><div class="line"><span class="title">int</span> clientSocket = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure><ol><li>连接服务器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">服务器IP地址结构体指针</span></div><div class="line"><span class="comment">结构体长度</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></div><div class="line">serverAddr.sin_family = AF_INET;<span class="comment">//IPV4</span></div><div class="line">serverAddr.sin_port = htons(<span class="number">80</span>);<span class="comment">//端口号</span></div><div class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);<span class="comment">//IP地址</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> connectResult = connect();</div><div class="line"><span class="comment">// 返回0代表连接成功</span></div></pre></td></tr></table></figure><p>netcat工具，用于监听本地端口</p><ol><li>发送数据</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">发送内容地址</span></div><div class="line"><span class="comment">发送内容长度</span></div><div class="line"><span class="comment">发送方式标志，一般为0</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">返回值</span></div><div class="line"><span class="comment">发送成功之后返回发送字节长度，失败返回error</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="selector-tag">send</span>();</div></pre></td></tr></table></figure><ol><li>读取数据</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">客户端socket</span></div><div class="line"><span class="comment">接受内容缓冲区域地址</span></div><div class="line"><span class="comment">接受内容缓冲区长度</span></div><div class="line"><span class="comment">接受方式标志，0表示阻塞，必须等待服务器返回数据</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">返回值</span></div><div class="line"><span class="comment">接受成功之后返回发送字节长度，失败返回error</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="built_in">uint</span>8_t buffer[<span class="number">1024</span>];</div><div class="line">recv();</div><div class="line"></div><div class="line">通过data数据读取二进制数组，解析返回字节流</div></pre></td></tr></table></figure><ol><li>关闭socket</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close()<span class="comment">;</span></div></pre></td></tr></table></figure><h2 id="HTTP访问"><a href="#HTTP访问" class="headerlink" title="HTTP访问"></a>HTTP访问</h2><p>通过向百度的IP地址，发送”GET HTTP/1.1\n  Host: www.baidu.com\n\n”可以接收到百度服务器返回的百度首页数据。</p><p>手写了一个HTTP协议</p><blockquote><p> Connection被废弃的原因</p><p> 异步下载，无法回调数据，因为Runloop默认在子线程不开启</p><p>线程管理</p><p>线程中有<strong>任务</strong>才有可能不被释放</p></blockquote><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>https本身不会对客户端进行验证</p><p>加密算法：RSA</p><p>RSA：公钥和私钥</p><p>明文+公钥 = 密文</p><p>密文+私钥 = 明文</p><p>第一次请求HTTPS服务器，客户端安装证书（下载公钥并保存），通讯时通过该公钥加密传输</p><p>登录校验时随机盐可以提高安全性</p><h2 id="加密详解"><a href="#加密详解" class="headerlink" title="加密详解"></a>加密详解</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>base64是编码方式，不属于加密算法</p><p>可以将任意的二进制数据进行编码 编码成为65中字符的文本文件</p><p>0-9，a-z，A-Z，+ / =</p><p>对称加密：</p><p>DES</p><p>3DES</p><p>AES（高级密码标准）</p><p>数学算法：</p><p>哈希函数MD5</p><h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>free()以及CFRelease()的区别</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>setup        初始化</p><p>tearDown  销毁</p><p>所有的测试用例必须以test开头</p><p>given</p><p>when</p><p>then</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="MVC解耦"><a href="#MVC解耦" class="headerlink" title="MVC解耦"></a>MVC解耦</h3><p>vc代码过于沉重</p><p>代码耦合性过高    UI与Model的通讯</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>面向协议编程—代理</p><p>@synchronized(self)多线程锁</p><p>通过代理使UI与Model通讯</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>双向绑定：数据和UI的绑定，即修改一处另一处随之修改<br>异步的一般处理：代理、通知、匿名函数（Block）</p><p>从数据   —–&gt;   UI 通过Block进行通讯<br>从UI  ——-&gt;  数据  通过KVO监听通讯</p><p>NSMutableArray是线程不安全的，在处理里面的数据的时候需要加锁</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>进程</p><p>线程</p><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- alloc init</div><div class="line">+ detacNewThread</div><div class="line">- self <span class="keyword">perform</span></div></pre></td></tr></table></figure><img src="/2019/12/30/iOS-learn/thread-status.png" alt="thread-status.png" title=""><p>线程的名称</p><p>线程的优先级</p><h3 id="多线程的共享资源"><a href="#多线程的共享资源" class="headerlink" title="多线程的共享资源"></a>多线程的共享资源</h3><p>线程不安全：获取的数据和预期可能不一样</p><p>互斥锁：线程同步，@synchronized 当一个线程在操作数据的时候，其它线程不得操作该数据</p><h3 id="原子属性-atomic"><a href="#原子属性-atomic" class="headerlink" title="原子属性 atomic"></a>原子属性 atomic</h3><p>原子属性是线程安全的，自旋锁</p><p>原子属性的成员变量，在set方法中会添加@synchronized保护线程安全</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/12/30/iOS-learn/iOS-intro.png&quot; alt=&quot;iOS-intro.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;以下笔记是边看视频课程边记录下来的，供以后自己查阅复习使用&lt;/p&gt;
&lt;h2 id=&quot;Runtime学习笔记1&quot;&gt;&lt;a href=&quot;#Runtime学习笔记1&quot; class=&quot;headerlink&quot; title=&quot;Runtime学习笔记1&quot;&gt;&lt;/a&gt;Runtime学习笔记1&lt;/h2&gt;&lt;h3 id=&quot;消息转发&quot;&gt;&lt;a href=&quot;#消息转发&quot; class=&quot;headerlink&quot; title=&quot;消息转发&quot;&gt;&lt;/a&gt;消息转发&lt;/h3&gt;&lt;p&gt;在OC中，调用方法其实是给对象发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[[Person &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;] &lt;span class=&quot;string&quot;&gt;sendMessage:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;gelo&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;objc_msgSend([Person &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;], &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;sendMessage:&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;gelo&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过对象的isa指针找到class，如果有方法的话，直接调用。没有找到的话，通过继承树查找，进入消息转发机制&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://mah93.github.io/categories/iOS/"/>
    
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>敏感词过滤Aho-Corasick算法</title>
    <link href="https://mah93.github.io/2019/09/26/aho-corasick/"/>
    <id>https://mah93.github.io/2019/09/26/aho-corasick/</id>
    <published>2019-09-26T09:23:08.000Z</published>
    <updated>2019-09-26T09:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/26/aho-corasick/ac-logo.jpg" alt="ac-logo.jpg" title=""><h2 id="多模式串匹配算法简介"><a href="#多模式串匹配算法简介" class="headerlink" title="多模式串匹配算法简介"></a>多模式串匹配算法简介</h2><p>敏感词过滤最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。</p><p>字符串匹配算法有很多比如BF算法、RK算法、BM算法、KMP算法还有Trie树。前面四种算法都是单模式串匹配算法，只有Trie树是多模式串匹配算法。</p><p>我们可以针对每个敏感词，通过单模式匹配算法与用户输入的文字内容进行匹配。但是这样做的话，每个需要匹配的敏感词都需要扫描一遍用户输入的内容。如果敏感词有很多，并且用户输入的内容很长，这种处理的方法就显得比较低效。</p><p>与单模式匹配算法相比，多模式串匹配算法在敏感词过滤这个问题上处理就很高效了，它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在。</p><a id="more"></a> <h2 id="Aho-Corasick算法"><a href="#Aho-Corasick算法" class="headerlink" title="Aho-Corasick算法"></a>Aho-Corasick算法</h2><p>Aho-Corasick算法一般称作AC自动机，<strong>AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在trie树上罢了。</strong></p><p>AC自动机有三个核心函数，分别是：</p><ul><li>success状态，成功转移到下一个节点（即Trie树）</li><li>failure状态，在该节点匹配失败，则跳转到一个特定的节点，从根节点到这个特定的节点的路径恰好是失败前文本的一部分。</li><li>output状态，匹配到了敏感词</li></ul><p>根据以上AC算法的特点，改进Trie节点的属性如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key, parent, word</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];    </div><div class="line">    <span class="keyword">this</span>.parent = parent;   <span class="comment">// 该节点的父节点，用于构建failure表</span></div><div class="line">    <span class="keyword">this</span>.failure = <span class="literal">null</span>;    <span class="comment">// 失效之后指向的节点</span></div><div class="line">    <span class="keyword">this</span>.word = word        <span class="comment">// 该节点是否为某一个敏感词的尾字符 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="构建Trie树"><a href="#构建Trie树" class="headerlink" title="构建Trie树"></a>构建Trie树</h2><p>和普通的trie构建是一样的，逐个插入节点。假设敏感词以及待过滤的字符串，均是小写的英文字母。以英文字母的ASCII码作为数组下标存储节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>];</div><div class="line">      </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">let</span> isWord = data.length === <span class="number">1</span>;</div><div class="line">        <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>], node, isWord);</div><div class="line">        children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>] = insertNode;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="添加Failure失效节点"><a href="#添加Failure失效节点" class="headerlink" title="添加Failure失效节点"></a>添加Failure失效节点</h2><p>下图是以<code>[&#39;HER&#39;, &#39;HEQ&#39;, &#39;SHR&#39;]</code>构建的trie树：</p><img src="/2019/09/26/aho-corasick/ac-failure.png" alt="ac-failure.png" title=""><p>在这张图中，虚线表示failure后的指向，上面我们也说到failure状态的作用，就是在失配的时候告诉程序往哪里走，为什么要这么做，从这张表我们可以很清楚的看到，当我们匹配<code>SHER</code>时，程序会走右边的分支，当走到S &gt; H &gt; E时，会出现失配，怎么办？可能有小伙伴会想到回滚到ROOT从H开始重新匹配，但这样回溯是有成本的，我们既然走了H节点，为什么要回溯呢？</p><p>这个时候failure就发挥作用了，我们看到右分支的H有一条虚线指向了左分支的H，我们也知道这就是failure的指向，通过这个指向，我们很轻松的将当前状态移交过去。程序继续匹配E &gt; R，加上移交过来的H，我们可以轻松的匹配到HER。</p><p><strong>问：假设有一个节点为currNode，它的子节点是childNode，那么子节点childNode的failure指向怎么求？</strong></p><p><em>解：首先，我们需要找到childNode父节点currNode的failure指向，假设这个指向是Q的话，<strong>我们就要看看Q的孩子（children属性）中有没有与childNode字符相同（key相同）的节点</strong>，如果有的话，这个节点就是childNode的failure指向。如果没有，我们就需要沿着currNode -&gt; failure -&gt; failure重复上述过程，如果一直没找到，就将其指向root。</em></p><p>由此可知，一个节点的失效指针一定在该节点的上层。需要注意的是，我们在构建Trie树时，并不知道failure指向到哪里的，所以failure指向需要在Trie树构建完成后插入。</p><p>首先将trie树第二层节点的失效指针指向root，之后逐层为每一个节点添加失效指针，即采用广度优先遍历Trie树：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFailure</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> currQueue = <span class="built_in">Object</span>.values(<span class="keyword">this</span>.root.children);</div><div class="line">  </div><div class="line">  <span class="keyword">while</span> (currQueue.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">let</span> nextQueue = [];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currQueue.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> node = currQueue[i]</div><div class="line">        <span class="keyword">let</span> key = node.key</div><div class="line">        <span class="keyword">let</span> parent = node.parent</div><div class="line">        node.failure = <span class="keyword">this</span>.root</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> node.children) &#123;</div><div class="line">          nextQueue.push(node.children[k])</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parent) &#123;</div><div class="line">          <span class="keyword">let</span> failure = parent.failure</div><div class="line">          <span class="keyword">while</span> (failure) &#123;</div><div class="line">            <span class="keyword">let</span> children = failure.children[key.charCodeAt() - <span class="number">97</span>]</div><div class="line">            <span class="keyword">if</span> (children) &#123;</div><div class="line">              node.failure = children</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            failure = failure.failure</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      currQueue = nextQueue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h2><p>对于Trie树上的一些准备工作已经做完了，下面就是要对待匹配的字符串进行过滤。从头遍历当遇到output表中的节点时，就是出现了敏感词。在匹配失败的时候顺着失效节点继续匹配过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> children = <span class="keyword">this</span>.root.children;</div><div class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.root;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;word.length; i++)&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(currentNode.children[word[i].charCodeAt() - <span class="number">97</span>] == <span class="literal">null</span> &amp;&amp; currentNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      currentNode = currentNode.failure;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currentNode = currentNode.children[word[i].charCodeAt() - <span class="number">97</span>];</div><div class="line">    <span class="keyword">if</span> (currentNode == <span class="literal">null</span>) &#123;</div><div class="line">      currentNode = <span class="keyword">this</span>.root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> temNode = currentNode;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(temNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      <span class="keyword">if</span>(temNode.word === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出现了敏感词'</span>);</div><div class="line">      &#125; </div><div class="line">      temNode = temNode.failure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line"><span class="comment">// 生成trie树</span></div><div class="line">trie.insert(<span class="string">'he'</span>);</div><div class="line">trie.insert(<span class="string">'his'</span>);</div><div class="line">trie.insert(<span class="string">'she'</span>);</div><div class="line">trie.insert(<span class="string">'hers'</span>);</div><div class="line"></div><div class="line">trie.getFailure();</div><div class="line"></div><div class="line"><span class="comment">// 测试数据</span></div><div class="line">trie.filter(<span class="string">'ushers'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 该字符串出现了三个敏感词</span></div></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key, parent, word</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="keyword">this</span>.failure = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.word = word</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Trie</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>, <span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 添加根节点</span></div><div class="line">    <span class="keyword">this</span>.insert = insert; <span class="comment">// 插入</span></div><div class="line">    <span class="keyword">this</span>.insertData = insertData;</div><div class="line">  </div><div class="line">    <span class="keyword">this</span>.getFailure = getFailure;</div><div class="line">    <span class="keyword">this</span>.filter = filter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>];</div><div class="line">      </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">let</span> isWord = data.length === <span class="number">1</span>;</div><div class="line">        <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>], node, isWord);</div><div class="line">        children[data[<span class="number">0</span>].charCodeAt() - <span class="number">97</span>] = insertNode;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFailure</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> currQueue = <span class="built_in">Object</span>.values(<span class="keyword">this</span>.root.children);</div><div class="line">  </div><div class="line">  <span class="keyword">while</span> (currQueue.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">let</span> nextQueue = [];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currQueue.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> node = currQueue[i]</div><div class="line">        <span class="keyword">let</span> key = node.key</div><div class="line">        <span class="keyword">let</span> parent = node.parent</div><div class="line">        node.failure = <span class="keyword">this</span>.root</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> node.children) &#123;</div><div class="line">          nextQueue.push(node.children[k])</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parent) &#123;</div><div class="line">          <span class="keyword">let</span> failure = parent.failure</div><div class="line">          <span class="keyword">while</span> (failure) &#123;</div><div class="line">            <span class="keyword">let</span> children = failure.children[key.charCodeAt() - <span class="number">97</span>]</div><div class="line">            <span class="keyword">if</span> (children) &#123;</div><div class="line">              node.failure = children</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            failure = failure.failure</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      currQueue = nextQueue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> children = <span class="keyword">this</span>.root.children;</div><div class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.root;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;word.length; i++)&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(currentNode.children[word[i].charCodeAt() - <span class="number">97</span>] == <span class="literal">null</span> &amp;&amp; currentNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      currentNode = currentNode.failure;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    currentNode = currentNode.children[word[i].charCodeAt() - <span class="number">97</span>];</div><div class="line">    <span class="keyword">if</span> (currentNode == <span class="literal">null</span>) &#123;</div><div class="line">      currentNode = <span class="keyword">this</span>.root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> temNode = currentNode;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(temNode != <span class="keyword">this</span>.root) &#123;</div><div class="line">      <span class="keyword">if</span>(temNode.word === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'出现了敏感词'</span>);</div><div class="line">      &#125; </div><div class="line">      temNode = temNode.failure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line"><span class="comment">// 生成trie树</span></div><div class="line">trie.insert(<span class="string">'he'</span>);</div><div class="line">trie.insert(<span class="string">'his'</span>);</div><div class="line">trie.insert(<span class="string">'she'</span>);</div><div class="line">trie.insert(<span class="string">'hers'</span>);</div><div class="line"></div><div class="line">trie.getFailure();</div><div class="line"></div><div class="line"><span class="comment">// 测试数据</span></div><div class="line">trie.filter(<span class="string">'ushers'</span>)</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://juejin.im/post/5cfa6bb6f265da1b8a4f0ed8#heading-4" target="_blank" rel="external">TypeScript：Aho–Corasick算法实现敏感词过滤</a></p></li><li><p><a href="http://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html" target="_blank" rel="external">Aho-Corasick算法的Java实现与分析</a></p></li><li><p><a href="https://time.geekbang.org/column/article/72810" target="_blank" rel="external">36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/26/aho-corasick/ac-logo.jpg&quot; alt=&quot;ac-logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;多模式串匹配算法简介&quot;&gt;&lt;a href=&quot;#多模式串匹配算法简介&quot; class=&quot;headerlink&quot; title=&quot;多模式串匹配算法简介&quot;&gt;&lt;/a&gt;多模式串匹配算法简介&lt;/h2&gt;&lt;p&gt;敏感词过滤最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。&lt;/p&gt;
&lt;p&gt;字符串匹配算法有很多比如BF算法、RK算法、BM算法、KMP算法还有Trie树。前面四种算法都是单模式串匹配算法，只有Trie树是多模式串匹配算法。&lt;/p&gt;
&lt;p&gt;我们可以针对每个敏感词，通过单模式匹配算法与用户输入的文字内容进行匹配。但是这样做的话，每个需要匹配的敏感词都需要扫描一遍用户输入的内容。如果敏感词有很多，并且用户输入的内容很长，这种处理的方法就显得比较低效。&lt;/p&gt;
&lt;p&gt;与单模式匹配算法相比，多模式串匹配算法在敏感词过滤这个问题上处理就很高效了，它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="https://mah93.github.io/2019/09/07/trie/"/>
    <id>https://mah93.github.io/2019/09/07/trie/</id>
    <published>2019-09-07T08:35:18.000Z</published>
    <updated>2020-07-09T02:29:21.919Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/07/trie/Trie-logo.png" alt="Trie-logo.png" title=""><h2 id="Trie树简介"><a href="#Trie树简介" class="headerlink" title="Trie树简介"></a>Trie树简介</h2><p>Trie 树，也叫字典树或者叫前缀树。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的树状结构，用来解决在一组字符串集合中快速查找某个字符串的问题。Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><a id="more"></a> <p>下面展示了一个由“hello”、“her”、“hi”、“how”、“see”以及“so”组成的Trie树。</p><img src="/2019/09/07/trie/Trie-Tres.jpg" alt="Trie-Tres.jpg" title=""><h2 id="Trie特点"><a href="#Trie特点" class="headerlink" title="Trie特点"></a>Trie特点</h2><p>由上图中的Trie中可知</p><ul><li>Trie的每个节点存储一个字符，根节点不保存字符</li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><h2 id="实现Trie树"><a href="#实现Trie树" class="headerlink" title="实现Trie树"></a>实现Trie树</h2><h3 id="Trie树节点"><a href="#Trie树节点" class="headerlink" title="Trie树节点"></a>Trie树节点</h3><p>由于每个节点只存储一个字符，以及指向它的子节点，那么对于每个节点有如下的数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中key保存了这个节点的值，children中保存了该节点的所有子节点（对于小写英文字母而言，这个数组的长度为26）</p><h3 id="Trie树的插入"><a href="#Trie树的插入" class="headerlink" title="Trie树的插入"></a>Trie树的插入</h3><p>构建一棵Trie树就是将字符串逐个插入的过程。由于Trie的特点，插入操作的过程中。要先判断Trie是否已经存在了与待插入字符串相同的前缀，找到所有的公共前缀后，将不同的字符插入Trie中。对于插入的过程，大致的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用递归插入字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = <span class="literal">null</span>;</div><div class="line">    </div><div class="line">   <span class="comment">// 判断存储子节点的数组中，是否有与插入字符串的第一个值匹配的节点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">        <span class="keyword">if</span> (children[i].key == data[<span class="number">0</span>]) &#123;</div><div class="line">            haveData = children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="comment">// 待插入的第一个字符已经存在children数组中，则继续判断下一个字符</span></div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">// 未找到相应的子节点，分为两种情况</span></div><div class="line">      <span class="comment">// 已经是现有Trie的叶子节点</span></div><div class="line">        <span class="keyword">if</span>(children.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.push(insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">// 要在当前的children中找到合适的位置，插入字符</span></div><div class="line">            <span class="keyword">let</span> validPosition = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[j].key &lt; data[<span class="number">0</span>]) &#123;</div><div class="line">                    validPosition++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.splice(validPosition, <span class="number">0</span>, insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在插入Trie树的过程中，需要遍历所有的字符串，时间复杂度是O(n)，n表示所有字符串的长度和。</p><h3 id="Trie树的查找"><a href="#Trie树的查找" class="headerlink" title="Trie树的查找"></a>Trie树的查找</h3><p>查找的过程与插入的过程类似，需要逐层遍历，寻找与待匹配字符串相同的字符。其大概代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span> || <span class="keyword">this</span>.root.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">// 遍历children</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.searchNext(<span class="keyword">this</span>.root.children[i], data)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 递归查找</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchNext</span>(<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(data[<span class="number">0</span>] !== node.key) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">  <span class="comment">// 该节点已经是叶子节点，并且待查找字符串已查找完毕</span></div><div class="line">    <span class="keyword">if</span>(children.length === <span class="number">0</span> &amp;&amp; data.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(children.length &gt; <span class="number">0</span> &amp;&amp; data.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">            <span class="comment">// 继续判断下一个字符</span></div><div class="line">            <span class="keyword">if</span>(children[i].key === data[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> searchNext(children[i], data.substring(<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Trie树已经构建完成的情况下，查找一个字符串是否在Trie中效率是非常高的，其事件复杂度为O(K)，k表示待查找字符串的长度。</p><h3 id="Trie树的删除"><a href="#Trie树的删除" class="headerlink" title="Trie树的删除"></a>Trie树的删除</h3><p>先递归查找到字符串的叶子节点，然后从字符串的叶子节点逐级向根节点递归删除叶子节点，直到删除字符串。其大概的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNode</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search(data)) &#123; <span class="comment">// 判断是否存在该单词（字符串）</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deleteNext(<span class="keyword">this</span>.root, i, data, data)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* @param parent 父节点</span></div><div class="line"><span class="comment">* @param index 子节点在父节点children数组中的索引位置</span></div><div class="line"><span class="comment">* @param stringData 递归遍历中的字符串</span></div><div class="line"><span class="comment">* @param delStr 调用delete方法时的原始字符串</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNext</span>(<span class="params">parent, index, stringData, delStr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = parent.children[index];</div><div class="line">    <span class="comment">// 若字符与节点key不相等，则不匹配</span></div><div class="line">    <span class="keyword">if</span> (stringData[<span class="number">0</span>] != node.key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若与key相等，继续判断</span></div><div class="line">        <span class="keyword">let</span> children = node.children;</div><div class="line">        <span class="keyword">if</span> (children.length == <span class="number">0</span> &amp;&amp; stringData.length == <span class="number">1</span>) &#123; <span class="comment">// 叶子节点，最后一个字符，则完全匹配</span></div><div class="line">            <span class="comment">// 删除叶子节点，利用父节点删除子节点原理</span></div><div class="line">            parent.children.splice(index, <span class="number">1</span>);</div><div class="line">            <span class="comment">// 字符串从尾部移除一个字符后，继续遍历删除方法</span></div><div class="line">            <span class="keyword">this</span>.deleteNode(delStr.substring(<span class="number">0</span>, delStr.length - <span class="number">1</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children.length &gt; <span class="number">0</span> &amp;&amp; stringData.length &gt; <span class="number">1</span>) &#123; <span class="comment">// 既不是叶子节点，也不是最后一个字符，则继续递归查找</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[i].key == stringData[<span class="number">1</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.deleteNext(node, i, stringData.substring(<span class="number">1</span>), delStr); <span class="comment">// 记得return 递归函数，否则获取的返回值为undefined</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Trie改进"><a href="#Trie改进" class="headerlink" title="Trie改进"></a>Trie改进</h2><p>Trie树是非常消耗内存的数据结构，用的是一种空间换时间的思路。Trie树的问题就在于存储子节点的children数组中。如果字符串中只包含从a到z的26个字符，那么children的长度就为26。<strong>注意，这里说的是每一个Trie树的节点，都需要申请一个长度为26的数组，即使这个节点只有一个子节点！</strong></p><p>那么如果字符串包含了大小写，或者是数字特殊字符。Trie所需的空间就更大了。尤其是在重复的前缀不多的情况下，Trie树不但不能节省内存，而且还有可能浪费更多的内存空间。可以想到的方法就是，将children修改为其他的数据结构，比如有序数组、跳表等。</p><p>对只有一个子节点的节点，而且此节点不是一个串的结束节点可以将此节点与子节点合并，这就是<strong>缩点优化</strong>。</p><img src="/2019/09/07/trie/Trie-up.jpg" alt="Trie-up.jpg" title=""><h2 id="Trie树完整代码"><a href="#Trie树完整代码" class="headerlink" title="Trie树完整代码"></a>Trie树完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TrieNode</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Trie</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 添加根节点</span></div><div class="line">    <span class="keyword">this</span>.insert = insert; <span class="comment">// 插入</span></div><div class="line">    <span class="keyword">this</span>.insertData = insertData;</div><div class="line">    <span class="keyword">this</span>.search = search; <span class="comment">// 查找</span></div><div class="line">    <span class="keyword">this</span>.searchNext = searchNext;</div><div class="line">    <span class="keyword">this</span>.deleteNode = deleteNode; <span class="comment">// 删除</span></div><div class="line">    <span class="keyword">this</span>.deleteNext = deleteNext;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.nodeNumber = <span class="number">0</span>; <span class="comment">// trie所有节点个数</span></div><div class="line">    <span class="keyword">this</span>.print = print; <span class="comment">// 打印Trie树</span></div><div class="line">    <span class="keyword">this</span>.printHelper = printHelper;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.insertData(data, <span class="keyword">this</span>.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertData</span>(<span class="params">data, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">let</span> haveData = <span class="literal">null</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">        <span class="keyword">if</span> (children[i].key == data[<span class="number">0</span>]) &#123;</div><div class="line">            haveData = children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(haveData) &#123;</div><div class="line">        <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), haveData);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(children.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.push(insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">let</span> validPosition = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[j].key &lt; data[<span class="number">0</span>]) &#123;</div><div class="line">                    validPosition++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> insertNode = <span class="keyword">new</span> TrieNode(data[<span class="number">0</span>]);</div><div class="line">            children.splice(validPosition, <span class="number">0</span>, insertNode);</div><div class="line">            <span class="keyword">this</span>.insertData(data.substring(<span class="number">1</span>), insertNode); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data === <span class="string">''</span> || <span class="keyword">this</span>.root.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.searchNext(<span class="keyword">this</span>.root.children[i], data)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchNext</span>(<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(data[<span class="number">0</span>] !== node.key) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">let</span> children = node.children;</div><div class="line">    <span class="keyword">if</span>(children.length === <span class="number">0</span> &amp;&amp; data.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(children.length &gt; <span class="number">0</span> &amp;&amp; data.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">            <span class="keyword">if</span>(children[i].key === data[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> searchNext(children[i], data.substring(<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNode</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search(data)) &#123; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deleteNext(<span class="keyword">this</span>.root, i, data, data)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNext</span>(<span class="params">parent, index, stringData, delStr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = parent.children[index];</div><div class="line">    <span class="keyword">if</span> (stringData[<span class="number">0</span>] != node.key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> children = node.children;</div><div class="line">        <span class="keyword">if</span> (children.length == <span class="number">0</span> &amp;&amp; stringData.length == <span class="number">1</span>) &#123; </div><div class="line">            parent.children.splice(index, <span class="number">1</span>);</div><div class="line">            <span class="keyword">this</span>.deleteNode(delStr.substring(<span class="number">0</span>, delStr.length - <span class="number">1</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children.length &gt; <span class="number">0</span> &amp;&amp; stringData.length &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> children) &#123;</div><div class="line">                <span class="keyword">if</span> (children[i].key == stringData[<span class="number">1</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.deleteNext(node, i, stringData.substring(<span class="number">1</span>), delStr);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.root.children) &#123;</div><div class="line">        <span class="keyword">this</span>.nodeNumber++;</div><div class="line">        <span class="keyword">this</span>.printHelper(<span class="keyword">this</span>.root.children[i], [<span class="keyword">this</span>.root.children[i].key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHelper</span> (<span class="params">node, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node.children.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;'</span>, data.join(<span class="string">''</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> node.children) &#123;</div><div class="line">        <span class="keyword">this</span>.nodeNumber++;</div><div class="line">        data.push(node.children[i].key);</div><div class="line">        <span class="keyword">this</span>.printHelper(node.children[i], data);</div><div class="line">        data.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> trie = <span class="keyword">new</span> Trie();</div><div class="line"></div><div class="line">trie.insert(<span class="string">'apple'</span>);</div><div class="line">trie.insert(<span class="string">'appcd'</span>);</div><div class="line">trie.insert(<span class="string">'banana'</span>);</div><div class="line"></div><div class="line">trie.print();</div><div class="line"><span class="built_in">console</span>.log(trie.search(<span class="string">"app"</span>));</div><div class="line">trie.deleteNode(<span class="string">'appcd'</span>)</div><div class="line">trie.print();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(trie.nodeNumber);</div><div class="line"></div><div class="line"><span class="comment">// 输出结果</span></div><div class="line">&gt; appcd</div><div class="line">&gt; apple</div><div class="line">&gt; banana</div><div class="line"><span class="literal">false</span></div><div class="line">&gt; apple</div><div class="line">&gt; banana</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>第一次看Trie树的概念，完全没明白到底是什么样的数据结构。直到看了Trie树的图示例，一下就明白了，Trie树的概念非常好理解，就是把相同的前缀放到一起构成了一个数据结构。在对比字符串的时候，就像查字典一层层的比较。</p><p>对于每个节点的存储结构确实比较绕，每次遍历children数组就相当于去往下一层比较了，反正每次涉及到递归函数总是不好理解。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.jianshu.com/p/ba70ca95c33b" target="_blank" rel="external">Trie树的JS或TS实现</a></p></li><li><p><a href="https://time.geekbang.org/column/article/72414" target="_blank" rel="external">Trie树：如何实现搜索引擎的搜索关键词提示功能？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/07/trie/Trie-logo.png&quot; alt=&quot;Trie-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Trie树简介&quot;&gt;&lt;a href=&quot;#Trie树简介&quot; class=&quot;headerlink&quot; title=&quot;Trie树简介&quot;&gt;&lt;/a&gt;Trie树简介&lt;/h2&gt;&lt;p&gt;Trie 树，也叫字典树或者叫前缀树。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的树状结构，用来解决在一组字符串集合中快速查找某个字符串的问题。Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://mah93.github.io/2019/08/12/binary-search/"/>
    <id>https://mah93.github.io/2019/08/12/binary-search/</id>
    <published>2019-08-12T09:12:54.000Z</published>
    <updated>2019-08-12T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/12/binary-search/binary-logo.png" alt="binary-logo.png" title=""><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>二分查找（Binary Search）算法，也叫折半查找算法。在给顺序表结构中（也就是数组）快速查找某一个值或者某个区间。二分查找的时间复杂度是O(logn)。虽然二分查找看起来很简单，实现出来的代码不够寥寥十几行，但是就是会出错，要么漏个等号，要么少加1。也就是<strong>思路很简单，细节是魔鬼</strong></p><p>本文均抄自Leetcode精选解题，本文原作者是labuladong</p><a id="more"></a> <h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>二分查找的写法基本固定，根据不同的场景修改起始值、判断条件、中止值非常容易忽略细节</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> binary<span class="constructor">Search(<span class="params">nums</span>, <span class="params">target</span>)</span> &#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, </div><div class="line">    <span class="keyword">let</span> right = ...;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(...) &#123;</div><div class="line">        <span class="keyword">let</span> mid = parse<span class="constructor">Int((<span class="params">right</span> + <span class="params">left</span>)</span><span class="operator"> / </span><span class="number">2</span>); <span class="comment">// 向下取整</span></div><div class="line">        <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span><span class="operator"> == </span>target) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span> &lt; target) &#123;</div><div class="line">            left = ...</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">mid</span>]</span> &gt; target) &#123;</div><div class="line">            right = ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ...;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于mid的取值问题，mid=（right+left）/2是有问题的，因为当right和left比较大的时候，相加的值有可能导致溢出。改进的方法是写成mid = left + (right-left)/2。如果要进行极致的性能优化，可以将除以2的操作写成位运算，left + (right-left) &gt;&gt; 1，相比于除法，计算机计算位运算的速度更快。</p><blockquote><p>本文均写成(right + left) / 2方便阅读，给定的数组均是升序数组</p></blockquote><h2 id="查找某一固定值"><a href="#查找某一固定值" class="headerlink" title="查找某一固定值"></a>查找某一固定值</h2><p>在给定的升序数组中，查找该数组中的某一个值，返回该值在数组中所处下标位置，若不存在该值则返回-1</p><p>例：给定数组[1,3,4,6,9,11,23,55]，查找数字6</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;=right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么-while-循环的条件中是-lt-，而不是-lt-？"><a href="#为什么-while-循环的条件中是-lt-，而不是-lt-？" class="headerlink" title="为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？"></a>为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</h4><p>因为right初始化的值是nums.length-1，即数组中最后一个元素，而不是nums.length。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</p><p>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">   <span class="keyword">return</span> mid;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。</p><p>while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 33 又小于等于 22 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 22，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 22 没有被搜索，如果这时候直接返回 -1 就是错误的。</p></li><li><h4 id="为什么-left-mid-1，right-mid-1？我看有的代码是-right-mid或者-left-mid，没有这些加加减减，到底怎么回事，怎么判断？"><a href="#为什么-left-mid-1，right-mid-1？我看有的代码是-right-mid或者-left-mid，没有这些加加减减，到底怎么回事，怎么判断？" class="headerlink" title="为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？"></a>为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？</h4><p>这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？</p><p>当然是 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</p></li></ul><h2 id="查找第一个等于给定元素的值-左边界"><a href="#查找第一个等于给定元素的值-左边界" class="headerlink" title="查找第一个等于给定元素的值(左边界)"></a>查找第一个等于给定元素的值(左边界)</h2><p>类似于上一个例子，现在我们给定的数组变成了[1,6,6,6,9]，需要返回第一个等于6的元素的下标。运行上面的函数返回值为2，因为第一个值的mid就等于了6。那么如何改进二分查找，才能找到第一个等于6的元素呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么-while-left-lt-right-而不是-lt"><a href="#为什么-while-left-lt-right-而不是-lt" class="headerlink" title="为什么 while(left &lt; right) 而不是 &lt;= ?"></a>为什么 while(left &lt; right) 而不是 &lt;= ?</h4><p>用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。</p><p>while(left &lt; right)终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。</p></li><li><h4 id="为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办？"><a href="#为什么没有返回-1-的操作？如果-nums-中不存在-target-这个值，怎么办？" class="headerlink" title="为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？"></a>为什么没有返回 <code>-1</code> 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</h4><p>  对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 6 的元素有 1 个。</p><p>  比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1的元素有 0 个。</p><p>  再比如说 nums 不变，target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。</p><p>  综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我   们简单添加两行代码就能在正确的时候 return -1：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// target 比所有数都大</span></div><div class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"><span class="comment">// 类似之前算法的处理方式</span></div><div class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</div></pre></td></tr></table></figure></li><li><h4 id="为什么-left-mid-1，right-mid-？和之前的算法不一样？"><a href="#为什么-left-mid-1，right-mid-？和之前的算法不一样？" class="headerlink" title="为什么 left = mid + 1，right = mid ？和之前的算法不一样？"></a>为什么 left = mid + 1，right = mid ？和之前的算法不一样？</h4><p>这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之        后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。</p></li><li><h4 id="为什么该算法能够搜索左侧边界？"><a href="#为什么该算法能够搜索左侧边界？" class="headerlink" title="为什么该算法能够搜索左侧边界？"></a>为什么该算法能够搜索左侧边界？</h4><p>关键在于对于 nums[mid] == target 这种情况的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (nums[mid] == target)</div><div class="line">    right = mid;</div></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p></li></ul><h2 id="查找最后一个等于给定元素的值-右边界"><a href="#查找最后一个等于给定元素的值-右边界" class="headerlink" title="查找最后一个等于给定元素的值(右边界)"></a>查找最后一个等于给定元素的值(右边界)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> right = nums.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right + left) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">            right = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><h4 id="为什么最后返回-left-1-而不像左侧边界的函数，返回-left？而且我觉得这里既然是搜索右侧边界，应该返回-right-才对。"><a href="#为什么最后返回-left-1-而不像左侧边界的函数，返回-left？而且我觉得这里既然是搜索右侧边界，应该返回-right-才对。" class="headerlink" title="为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。"></a>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。</h4><p>首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。</p><p>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target</p></li></ul><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>二分查找对于有序数组的查询效率非常高，但是对于边界问题处理上十分棘手，考察细节一不小心就会导致死循环，而且不易查找错误。</p><p>有效的理解是确定每次的搜索范围以及循环中止条件。对于每次修改搜索范围的原则是，关注mid有没有被搜索过。在此基础上+1或者-1。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://leetcode-cn.com/problems/two-sum/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external">leetcode精选解题</a></p></li><li><p><a href="https://time.geekbang.org/column/article/42733" target="_blank" rel="external">极客时间   二分查找</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/08/12/binary-search/binary-logo.png&quot; alt=&quot;binary-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;二分查找（Binary Search）算法，也叫折半查找算法。在给顺序表结构中（也就是数组）快速查找某一个值或者某个区间。二分查找的时间复杂度是O(logn)。虽然二分查找看起来很简单，实现出来的代码不够寥寥十几行，但是就是会出错，要么漏个等号，要么少加1。也就是&lt;strong&gt;思路很简单，细节是魔鬼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文均抄自Leetcode精选解题，本文原作者是labuladong&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="https://mah93.github.io/2019/08/08/string-matching/"/>
    <id>https://mah93.github.io/2019/08/08/string-matching/</id>
    <published>2019-08-08T04:59:26.000Z</published>
    <updated>2019-08-08T05:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/08/string-matching/string-logo.png" alt="string-logo.png" title=""><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。</p><a id="more"></a> <img src="/2019/08/08/string-matching/BF.jpg" alt="BF.jpg" title=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BF</span>(<span class="params">haystack, needle</span>) </span>&#123;       </div><div class="line">    <span class="keyword">let</span> j=<span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</div><div class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                re = i;</div><div class="line">            &#125;</div><div class="line">            j = j+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(j == needle.length) &#123;</div><div class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(j !== <span class="number">0</span>)&#123;</div><div class="line">                i=i-j;</div><div class="line">            &#125;</div><div class="line">            j=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>RK算法在BF基础上，引入哈希算法。通过字符串的哈希值的比较替换掉字符串之间的比较，从而降低算法的时间复杂度。RK算法整体的时间复杂度为O(n)。其中 n 为原字符串长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成hash值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">string</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</div><div class="line">        hash += <span class="number">26</span> * hash + string[i].charCodeAt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 比较两个字符串是否相等</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span> (<span class="params">str, dest</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str.length !== dest.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (str[i] !== dest[i]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RK</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> needleHash = hash(needle);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=(haystack.length - needle.length); i++)&#123;</div><div class="line">        <span class="keyword">let</span> subStr = haystack.substr(i, needle.length);</div><div class="line">        <span class="keyword">if</span> (hash(subStr) === needleHash &amp;&amp; isMatch(subStr, needle)) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>BM算法的核心思想是通过将模式串沿着主串大踏步的向后滑动，从而大大减少比较次数，降低时间复杂度。而算法的关键在于如何兼顾步子迈得足够大与无遗漏，同时要尽量提高执行效率。这就需要模式串在向后滑动时，遵守坏字符规则与好后缀规则，同时采用一些技巧。</p><h3 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h3><p>坏字符规则：从后往前逐位比较模式串与主串的字符，当找到不匹配的坏字符时，记录模式串的下标值si，并找到坏字符在模式串中，位于下标si前的最近位置xi（若无则记为-1），si-xi即为向后滑动距离。（PS：我觉得加上xi必须在si前面，也就是比si小的条件，就不用担心计算出的距离为负了）。但是坏字符规则向后滑动的步幅还不够大，于是需要好后缀规则。</p><h3 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h3><p>好后缀规则：从后往前逐位比较模式串与主串的字符，当出现坏字符时停止。若存在已匹配成功的子串｛u｝，那么在模式串的｛u｝前面找到最近的｛u｝，记作｛u’｝。再将模式串后移，使得模式串的｛u’｝与主串的｛u｝重叠。若不存在｛u’｝，则直接把模式串移到主串的｛u｝后面。为了没有遗漏，需要找到最长的、能够跟模式串的前缀子串匹配的，好后缀的后缀子串（同时也是模式串的后缀子串）。然后把模式串向右移到其左边界，与这个好后缀的后缀子串在主串中的左边界对齐。</p><p>何时使用坏字符规则和好后缀规则呢？首先在每次匹配过程中，一旦发现坏字符，先执行坏字符规则，如果发现存在好后缀，还要执行好后缀规则，并从两者中选择后移距离最大的方案执行。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>1.通过散列表实现，坏字符在模式串中下标位置的快速查询。<br>2.每次执行好后缀原则时，都会计算多次能够与模式串前缀子串相匹配的好后缀的最长后缀子串。为了提高效率，可以预先计算模式串的所有后缀子串，在模式串中与之匹配的另一个子串的位置。同时预计算模式串中（同长度的）后缀子串与前缀子串是否匹配并记录。在具体操作中直接使用，大大提高效率。<br>3.如何快速记录模式串后缀子串匹配的另一个子串位置，以及模式串（相同长度）前缀与后缀子串石否匹配呢？先用一个suffix数组，下标值k为后缀子串的长度，从模式串下标为i（0~m-2）的字符为最后一个字符，查找这个子串是否与后缀子串匹配，若匹配则将子串起始位置的下标值j赋给suffix[k]。若j为0，说明这个匹配子串的起始位置为模式串的起始位置，则用一个数组prefix，将prefix[k]设为true，否则设为false。k从0到m（模式串的长度）于是就得到了模式串所有前缀与后缀子串的匹配情况。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>仅有坏字符规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 本例只实现从'a'-'z'的字符串匹配</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> hash = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</div><div class="line">      hash[i] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</div><div class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      hash[ascii] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> hash = hashMap(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</div><div class="line">      <span class="keyword">let</span> bad = <span class="number">-1</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</div><div class="line">              bad = j;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(bad === <span class="number">-1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      i = i + (bad - hash[ascii]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>坏字符规则在某些场景下会使si-xi为负值，导致无限循环。如在“aaaaaaa”中匹配”baaaa”。</p><p>下面讲好后缀原则加入，完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">suffixAndPrefix</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line">  <span class="keyword">let</span> suffix = [];</div><div class="line">  <span class="keyword">let</span> prefix = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</div><div class="line">    suffix[i] = <span class="number">-1</span>;</div><div class="line">    prefix[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++)&#123;</div><div class="line">    <span class="keyword">let</span> j=i;</div><div class="line">    <span class="keyword">let</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; needle[j] === needle[m<span class="number">-1</span>-k]) &#123;</div><div class="line">      j--;</div><div class="line">      k++;</div><div class="line">      suffix[k] = j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j===<span class="number">-1</span>)&#123;</div><div class="line">      prefix[k]=<span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> [suffix, prefix];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveByGoodFix</span>(<span class="params">j, m, suffix, prefix</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> k = m - <span class="number">1</span> - j;</div><div class="line">  <span class="keyword">if</span>(suffix[k] !== <span class="number">-1</span>) <span class="keyword">return</span> j - suffix[k] + <span class="number">1</span>; <span class="comment">// 如果存在匹配的好后缀子集，滑动到坏字符的下一位</span></div><div class="line">  <span class="comment">// TODO 为什么要寻找？</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=j+<span class="number">2</span>; i&lt;=m<span class="number">-1</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(prefix[m-i] === <span class="literal">true</span>) &#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashMap</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> hash = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</div><div class="line">      hash[i] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对于存在多个xi，则取靠后的那个下标，防止滑动过多</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;needle.length; i++)&#123;</div><div class="line">      <span class="keyword">let</span> ascii = needle[i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      hash[ascii] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BM</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> [ suffix, prefix ] = suffixAndPrefix(needle);</div><div class="line">  <span class="keyword">let</span> hash = hashMap(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= n-m) &#123;</div><div class="line">      <span class="keyword">let</span> bad = <span class="number">-1</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">          <span class="keyword">if</span>(haystack[i+j] !== needle[j])&#123;</div><div class="line">              bad = j;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(bad === <span class="number">-1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">let</span> ascii = haystack[bad+i].charCodeAt() - <span class="number">97</span>;</div><div class="line">      <span class="keyword">let</span> badChar = bad - hash[ascii];</div><div class="line">      <span class="keyword">let</span> goodFix = <span class="number">0</span>;</div><div class="line">      <span class="comment">// 判断是否有好后缀</span></div><div class="line">      <span class="keyword">if</span>(bad&lt;m<span class="number">-1</span>)&#123;</div><div class="line">        goodFix = moveByGoodFix(bad, m, suffix, prefix);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      i = i + <span class="built_in">Math</span>.max(badChar, goodFix);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="PMT数组"><a href="#PMT数组" class="headerlink" title="PMT数组"></a>PMT数组</h3><p>KMP算法的核心，是一个被称为部分匹配表(Partial Match Table)的数组。</p><img src="/2019/08/08/string-matching/PMT.jpg" alt="PMT.jpg" title=""><p><strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。</p><h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。</p><img src="/2019/08/08/string-matching/next.jpg" alt="next.jpg" title=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> res = [];</div><div class="line">  res[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> k = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.length; i++) &#123;</div><div class="line">      <span class="keyword">while</span> (k != <span class="number">-1</span> &amp;&amp; needle[i] != needle[k+<span class="number">1</span>]) &#123;</div><div class="line">          k = res[k]; <span class="comment">// 当不匹配的时候，回溯寻找次长串</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (needle[i] === needle[k+<span class="number">1</span>]) &#123;</div><div class="line">          k++;</div><div class="line">      &#125;</div><div class="line">      res[i] = k;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">haystack, needle</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = haystack.length;</div><div class="line">  <span class="keyword">let</span> m = needle.length;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> nextArray = next(needle);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] !== needle[j])&#123;</div><div class="line">      j = nextArray[j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(haystack[i] == needle[j]) &#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j == m)&#123;</div><div class="line">      <span class="keyword">return</span> i-m+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">最差时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">BF算法</td><td style="text-align:center">T(1)</td><td style="text-align:center">O(nm)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">RK算法</td><td style="text-align:center">T(1)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">BM算法</td><td style="text-align:center">T(2m)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(nm)</td></tr><tr><td style="text-align:center">KMP算法</td><td style="text-align:center">T(m)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(nm)</td></tr></tbody></table><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>BF算法是最容易想到的算法，只需要逐个字符去比较，遇到不匹配的字符只需要将主串字符向后移动一位，重复比较即可。</p><p>RK算法在BF的基础上，引入了hash值。核心理念是：hash值不相同的两个字符串一定不想等，hash相等的字符串才有可能相等。通过hash值的运算大大降低了字符比较的次数。</p><p>BM算法提出坏字符和好后缀的规则，从字符串的尾部开始比较。遇到坏字符则大幅度向后滑动，好后缀规则是记录模式串中前后是否有相同的部分。两个规则中移动距离比较远的，则成为下一次循环比较的开始。</p><p>KMP算法在BM算法的基础上，直接先计算模式串的“重复度”即模式串的前后字符是否有相同的部分，匹配到不等的字符就可以把之前比较相等的部分跳过。</p><p>BM和KMP都是处理模式串本身，与主串无关。都是为了在下一次比较的时候能够大幅度的向后移动，以提高字符串匹配的速度。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/article/71187" target="_blank" rel="external">数据结构与算法之美</a></li><li><a href="https://juejin.im/post/5d38fcfcf265da1bcb4f6fce" target="_blank" rel="external">JavaScript 字符串匹配算法</a></li><li><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/08/08/string-matching/string-logo.png&quot; alt=&quot;string-logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;BF（Brute Force），暴力检索法是最好想到的算法，也最好实现。首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。 时间复杂度：O(nm)。其中 n 为原字符串长度，m 为子串长度。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>js单链表实现</title>
    <link href="https://mah93.github.io/2019/07/19/js-linked/"/>
    <id>https://mah93.github.io/2019/07/19/js-linked/</id>
    <published>2019-07-19T09:17:28.000Z</published>
    <updated>2019-08-08T05:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/19/js-linked/js_linked_logo.jpg" alt="js_linked_logo.jpg" title=""><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><h2 id="与数组的区别"><a href="#与数组的区别" class="headerlink" title="与数组的区别"></a>与数组的区别</h2><p>​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><a id="more"></a> <h2 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>链表的基本存储结构就是一个个的节点，首先先创建一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// val表示该节点上存储的值</span></div><div class="line"><span class="comment">// next表示该节点的下一个节点</span></div><div class="line"><span class="comment">// 一般的单向链表的尾节点指向null</span></div></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>一般链表的第一个节点为head，用来表示这是一个链表存储，在创建链表的时候我们为链表的第一个节点默认设置为head</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们就实现了一个最简单的链表。仿照数组的操作，之后我们为链表添加上基本的增删改查功能。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>为了方便链表操作，首先要记录一下链表的长度。在操作链表的时候记得相应的增减。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">+    <span class="keyword">this</span>.length = <span class="number">0</span>; <span class="comment">// 链表默认的长度为0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><p>在操作链表之前，先能看到链表的样子，方便后续的测试。只需要遍历一下链表，按照自己喜欢的格式打印出链表即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ok～现在已经得到了一个链表了，现在测试一下这个链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line">testLink.display();  <span class="comment">// 打印这个链表</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;tail<br>链表长度为：0</p></blockquote><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>向链表的尾部添加一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">+    <span class="keyword">this</span>.add = add; <span class="comment">// 添加节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++; <span class="comment">// 链表变长了1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3</p></blockquote><h3 id="查找指定节点"><a href="#查找指定节点" class="headerlink" title="查找指定节点"></a>查找指定节点</h3><p>查找指定节点所在链表中的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// // 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div></pre></td></tr></table></figure><blockquote><p>apple是该链表的第2个节点<br>该链表中不存在这个节点</p></blockquote><h3 id="向指定节点后添加一个节点"><a href="#向指定节点后添加一个节点" class="headerlink" title="向指定节点后添加一个节点"></a>向指定节点后添加一个节点</h3><p>首先先要找到指定的节点，若没有查找这个节点则插入失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div></pre></td></tr></table></figure><blockquote><p>插入成功<br>该链表中不存在这个节点<br>插入失败：不存在该节点</p></blockquote><h3 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">    </div><div class="line">+    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length --; <span class="comment">// 链表变短了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div><div class="line"></div><div class="line"><span class="comment">// 删除一个节点</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><blockquote><p>head-&gt;first-&gt;apple-&gt;ball-&gt;tail<br>链表长度为：3<br>head-&gt;first-&gt;ball-&gt;tail<br>链表长度为：2</p></blockquote><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表node节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = node;</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">'head'</span>);     <span class="comment">//头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find;                   <span class="comment">//查找节点</span></div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">    <span class="keyword">this</span>.insert = insert;               <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.remove = remove;               <span class="comment">//删除节点</span></div><div class="line">    <span class="keyword">this</span>.display = display;             <span class="comment">//显示链表</span></div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向链表添加一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    currNode.next = <span class="keyword">new</span> LinkedNode(item);</div><div class="line">    <span class="keyword">this</span>.length ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找给定节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (currNode.val != item)&#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"该链表中不存在这个节点"</span>)</div><div class="line">            <span class="keyword">return</span> currNode;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next;</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>是该链表的第<span class="subst">$&#123;index&#125;</span>个节点`</span>);</div><div class="line">    <span class="keyword">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">let</span> linkString = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span> (currNode != <span class="literal">null</span>)&#123;</div><div class="line">        linkString = linkString + currNode.val + <span class="string">'-&gt;'</span>;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(linkString + <span class="string">'tail'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode(newElement);</div><div class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.find(item);</div><div class="line">    <span class="keyword">if</span>(currNode.next == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"插入失败：不存在该节点"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    newNode.next = currNode.next;</div><div class="line">    currNode.next = newNode;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"插入成功"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</div><div class="line">    <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(currNode.next.val == item) &#123;</div><div class="line">            currNode.next = currNode.next.next;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        currNode = currNode.next</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> testLink = <span class="keyword">new</span> LinkedList();</div><div class="line"><span class="comment">// 链表添加元素</span></div><div class="line">testLink.add(<span class="string">'first'</span>);</div><div class="line">testLink.add(<span class="string">'apple'</span>);</div><div class="line">testLink.add(<span class="string">'ball'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 查找链表</span></div><div class="line">testLink.find(<span class="string">'apple'</span>);</div><div class="line">testLink.find(<span class="string">'second'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 插入</span></div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'first'</span>);</div><div class="line">testLink.insert(<span class="string">'second'</span>, <span class="string">'ccc'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 删除</span></div><div class="line">testLink.remove(<span class="string">'apple'</span>);</div><div class="line"></div><div class="line">testLink.display();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'链表长度为：'</span> + testLink.length);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="[https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8](https://baike.baidu.com/item/链表">百度百科-链表</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/19/js-linked/js_linked_logo.jpg&quot; alt=&quot;js_linked_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。&lt;/p&gt;
&lt;h2 id=&quot;与数组的区别&quot;&gt;&lt;a href=&quot;#与数组的区别&quot; class=&quot;headerlink&quot; title=&quot;与数组的区别&quot;&gt;&lt;/a&gt;与数组的区别&lt;/h2&gt;&lt;p&gt;​    使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="算法与数据结构" scheme="https://mah93.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript接口与泛型</title>
    <link href="https://mah93.github.io/2019/07/05/typescript-g/"/>
    <id>https://mah93.github.io/2019/07/05/typescript-g/</id>
    <published>2019-07-05T08:23:13.000Z</published>
    <updated>2020-07-09T02:29:06.128Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/05/typescript-g/typescript_var_logo.png" alt="typescript_var_logo.png" title=""><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义方法中参数的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">label: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(<span class="string">"sss"</span>);</div></pre></td></tr></table></figure><p>自定义方法传入参数对json的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelInfo: &#123; label: <span class="built_in">string</span> &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printLabel(&#123; label: <span class="string">"ssss"</span> &#125;);</div></pre></td></tr></table></figure><a id="more"></a> <p>接口：行为和动作的规范，对批量方法进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义接口</span></div><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现接口</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="可选属性接口"><a href="#可选属性接口" class="headerlink" title="可选属性接口"></a>可选属性接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> FullName &#123;</div><div class="line">firstName: <span class="built_in">string</span>;</div><div class="line">secondName: <span class="built_in">string</span>;</div><div class="line">age?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name: FullName</span>) </span>&#123;</div><div class="line"><span class="comment">// 必须传入对象包含关键字</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><p>加密的函数类型接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> encrypt &#123;</div><div class="line">(key: <span class="built_in">string</span>, value: <span class="built_in">string</span>): <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> md5:encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> key + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">md5(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</div></pre></td></tr></table></figure><h2 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h2><p>对数组的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserArray &#123;</div><div class="line">[index: <span class="built_in">number</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserArray = [<span class="string">"111"</span>, <span class="string">"222"</span>]</div></pre></td></tr></table></figure><p>对对象的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UserObj &#123;</div><div class="line">[index: <span class="built_in">string</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr: UserObj = &#123;name: <span class="string">"20"</span>&#125;</div></pre></td></tr></table></figure><p>对类的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">eat(str: <span class="built_in">string</span>): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"小黑"</span>)</div><div class="line">dog.eat();</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> Animal&#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">eat(food: <span class="built_in">string</span>) &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"小花"</span>)</div><div class="line">cat.eat(<span class="string">"猫粮"</span>);</div></pre></td></tr></table></figure><h2 id="接口的继承与拓展"><a href="#接口的继承与拓展" class="headerlink" title="接口的继承与拓展"></a>接口的继承与拓展</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">eat(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</div><div class="line">work(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Programmer &#123;</div><div class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">coding(code: <span class="built_in">string</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  Web类继承Programmer类并且实现Person接口</span></div><div class="line"><span class="keyword">class</span> Web <span class="keyword">extends</span> Programmer <span class="keyword">implements</span> Person &#123;</div><div class="line"><span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line"><span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">work() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"work"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>接受string类型的参数，并且返回string类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是要同时返回时string和number，就造成了代码冗余</p><p>使用any类型解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是any放弃了类型检查，会丢失掉参数类型。实际的需求时，传入什么类型的数据，就要返回什么类型的数据。</p><p>泛型：可以支持不确定的数据类型，要求：传入的参数和返回的类型一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="number">123</span>); <span class="comment">// error</span></div></pre></td></tr></table></figure><blockquote><p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 <code>T</code>、<code>U</code>、<code>V</code> 表示。如果在你的参数里，不止拥有一个泛型，你应该使用一个更语义化名称，如 <code>TKey</code> 和 <code>TValue</code> （通常情况下，以 <code>T</code> 做为泛型前缀也在如 C++ 的其他语言里做为模版。）</p></blockquote><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>返回数组中最小的值，同时支持number类型以及string类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MinClass&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span> list: T[] = [];</div><div class="line">add(value: T): <span class="built_in">void</span> &#123;</div><div class="line"><span class="keyword">this</span>.list.push(value);</div><div class="line">&#125;</div><div class="line">min(): T &#123;</div><div class="line"><span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</div><div class="line"><span class="keyword">if</span>(minNum &gt; <span class="keyword">this</span>.list[i]) &#123;</div><div class="line">minNum = <span class="keyword">this</span>.list[i];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> minNum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;(); <span class="comment">// 实例化并且指定泛型T</span></div><div class="line"></div><div class="line">m.add(<span class="number">2</span>);</div><div class="line">m.add(<span class="number">22</span>);</div><div class="line">m.add(<span class="number">13</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(m.min());</div></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>第一种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&#123;</div><div class="line">&lt;T&gt;(value: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getData: Config = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">"张三"</span>);</div></pre></td></tr></table></figure><p>第二种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Config&lt;T&gt;&#123;</div><div class="line">(value: T): T</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>):<span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myGetData: Config&lt;sting&gt; = getData;</div><div class="line">myGetData(<span class="string">'20'</span>)</div></pre></td></tr></table></figure><p>类当作参数验证</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MysqlDb&lt;T&gt; &#123;</div><div class="line">add(info:T): <span class="built_in">boolean</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(info);</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ArticleCate &#123;</div><div class="line">title: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">desc: <span class="built_in">string</span> | <span class="literal">undefined</span>;</div><div class="line">status: <span class="built_in">number</span> | <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">constructor</span>(<span class="params">params: &#123;</span></div><div class="line"><span class="params">title: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      desc: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></div><div class="line"><span class="params">      status: <span class="built_in">number</span> | <span class="literal">undefined</span></span></div><div class="line"><span class="params">&#125;</span>) &#123;</div><div class="line"><span class="keyword">this</span>.title = params.title;</div><div class="line"><span class="keyword">this</span>.desc = params.desc;</div><div class="line"><span class="keyword">this</span>.status = params.status;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ArticleCate(&#123;</div><div class="line">title: <span class="string">"genli"</span>,</div><div class="line">desc: <span class="string">"111"</span>,</div><div class="line">status: <span class="number">1</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> Db = <span class="keyword">new</span> MysqlDb&lt;ArticleCate&gt;();</div><div class="line">Db.add(a);</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/av54470911/?p=1" target="_blank" rel="external">6小时快速上手typescript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/07/05/typescript-g/typescript_var_logo.png&quot; alt=&quot;typescript_var_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;定义方法中参数的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&lt;span class=&quot;string&quot;&gt;&quot;sss&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自定义方法传入参数对json的约束&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printLabel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;labelInfo: &amp;#123; label: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &amp;#125;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;printLabel(&amp;#123; label: &lt;span class=&quot;string&quot;&gt;&quot;ssss&quot;&lt;/span&gt; &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="学习笔记" scheme="https://mah93.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（一）</title>
    <link href="https://mah93.github.io/2019/06/17/golang-study-1/"/>
    <id>https://mah93.github.io/2019/06/17/golang-study-1/</id>
    <published>2019-06-17T09:19:51.000Z</published>
    <updated>2019-06-17T09:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/17/golang-study-1/go_log.png" alt="go_log.png" title=""><h2 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h2><p>安装包下载地址为：<a href="https://golang.org/dl/。" target="_blank" rel="external">https://golang.org/dl/。</a></p><p>如果打不开可以使用这个地址：<a href="https://golang.google.cn/dl/。" target="_blank" rel="external">https://golang.google.cn/dl/。</a></p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a> <h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，<code>testing</code>框架和其他语言中的测试框架类似。</p><p>Go中的单元测试有以下几个要求</p><ul><li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li><li>你必须import <code>testing</code>这个包</li><li>所有的测试用例函数必须是<code>Test</code>开头</li></ul><p>通过<code>go test</code>来执行改目录下所有的单元测试，或者是通过<code>go test -v</code>来输出测试代码中的详细信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> test或者是<span class="keyword">go</span> test -v</div></pre></td></tr></table></figure><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>在go中通过var关键字创建变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 类型声明在变量后面, go可以类型推断</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">2</span></div><div class="line"><span class="comment">// 或者是</span></div><div class="line"><span class="keyword">var</span>(</div><div class="line">  a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">  b <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">)</div><div class="line"><span class="comment">// 或者是</span></div><div class="line">a: = <span class="number">1</span></div><div class="line">b: = <span class="number">1</span></div></pre></td></tr></table></figure><p>在go中内置了很多的方法，比如变量数值的交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a,b = b,a</div></pre></td></tr></table></figure><h3 id="常量的初始化"><a href="#常量的初始化" class="headerlink" title="常量的初始化"></a>常量的初始化</h3><p>常量的初始化可以通过自增来简化代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Monday = <span class="literal">iota</span> + <span class="number">1</span></div><div class="line">Tuesday</div><div class="line">Wdnesday</div><div class="line">)</div></pre></td></tr></table></figure><p>或者是通过位移操作符，区分常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">Readable = <span class="number">1</span>&lt;&lt;<span class="literal">iota</span></div><div class="line">Writeable </div><div class="line">Executable</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>go中包含了基础的数据类型，如<code>int</code> 、<code>string</code>等</p><ul><li>go语言中不允许隐式类型转换</li><li>即便是别名的隐式类型转换，也是不被允许的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=a</div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">b=(<span class="keyword">int64</span>)a</div><div class="line"></div><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = b</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> c MyInt</div><div class="line"><span class="keyword">var</span> b <span class="keyword">int64</span></div><div class="line">c = MyInt(b)</div></pre></td></tr></table></figure><h3 id="内置数值"><a href="#内置数值" class="headerlink" title="内置数值"></a>内置数值</h3><ul><li>math.MaxInt64</li><li>math.MaxFloat64</li><li>math.MaxUnit32</li></ul><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><ul><li>不支持指针运算</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>go中没有前置++</p><p>在数组的比较中，go的<code>==</code>会比较数组的值</p><h3 id="amp-按位置零"><a href="#amp-按位置零" class="headerlink" title="&amp;^按位置零"></a>&amp;^按位置零</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">0</span> -- <span class="number">1</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">1 </span>&amp;^ <span class="number">1</span> -- <span class="number">0</span></div><div class="line"><span class="symbol">0 </span>&amp;^ <span class="number">0</span> -- <span class="number">0</span></div></pre></td></tr></table></figure><p>右边的数值为1则整个为0，右边数值为0的时候，取左边的值</p><h2 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>go语言仅仅支持循环关键字<code>for</code></p><p>实现while条件循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无限循环</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> a := <span class="number">1</span> == <span class="number">1</span>; a &#123;</div><div class="line"><span class="comment">// 初始赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="switch条件"><a href="#switch条件" class="headerlink" title="switch条件"></a>switch条件</h3><p>在go中不需要加break</p><p>可以在<code>case</code>中命中多个条件</p><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a [<span class="number">3</span>]<span class="built_in">int</span> <span class="comment">//声明并初始化为默认值</span></div><div class="line">a[<span class="number">0</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">b := [<span class="number">3</span>]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">c := [<span class="number">2</span>][<span class="number">2</span>]<span class="built_in">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</div><div class="line">可以通过[...]省略数组长度</div><div class="line"></div><div class="line">d := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>通过for循环访问数组下标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</div><div class="line">t.Log(arr1[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过for-in循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> arr1&#123;</div><div class="line">t.Log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>_</code>表示占位，并不关心该数组的<code>index</code>值</p><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>数组的快速截取，即数组[开始的索引位置，结束的索引位置]</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">a[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">//2</span></div><div class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//2,3</span></div><div class="line">a[<span class="number">1</span>:len(a)] <span class="comment">// 2,3,4,5</span></div><div class="line">a[<span class="number">1</span>:]<span class="comment">// 2,3,4,5</span></div><div class="line">a[:<span class="number">3</span>]<span class="comment">// 1,2,3</span></div></pre></td></tr></table></figure><blockquote><p>go语言不支持负数截取</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><img src="/2019/06/17/golang-study-1/go_slice@2x.png" alt="go_slice@2x.png" title=""><p>其中，ptr指向一片连续的存储空间，len表示改切片存储的元素个数，cap表示改切片的容量。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s0 []<span class="built_in">int</span></div><div class="line">s0 = append(s0, <span class="number">1</span>)</div><div class="line"></div><div class="line">s := []<span class="built_in">int</span>&#123;&#125;</div><div class="line">s1 := []&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line"></div><div class="line">s2 := make([]<span class="built_in">int</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// make函数表示声明一个切片，切片默认声明2个元素为初始零值，改切片的容量为4</span></div><div class="line"><span class="comment">// 未初始化的元素不可访问</span></div></pre></td></tr></table></figure><blockquote><p>切片的容量成倍增长</p><p>切片容量是在增长的，扩容时存储空间不够时会创建一片新的内存空间。所以切片的append操作会重新返回一个新的切片</p></blockquote><h3 id="切片共享存储空间"><a href="#切片共享存储空间" class="headerlink" title="切片共享存储空间"></a>切片共享存储空间</h3><img src="/2019/06/17/golang-study-1/go_slice_mer@2x.png" alt="go_slice_mer@2x.png" title=""><p>对于从同一个切片中截取的切片而言，他们共用同一片内存空间！他们的容量从起始位指向原切片的末尾。</p><blockquote><p>对于切片而言不可以通过<code>==</code>进行比较</p></blockquote><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ul><li><a href="https://time.geekbang.org/course/intro/160" target="_blank" rel="external">Go语言从入门到实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/17/golang-study-1/go_log.png&quot; alt=&quot;go_log.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;安装下载&quot;&gt;&lt;a href=&quot;#安装下载&quot; class=&quot;headerlink&quot; title=&quot;安装下载&quot;&gt;&lt;/a&gt;安装下载&lt;/h2&gt;&lt;p&gt;安装包下载地址为：&lt;a href=&quot;https://golang.org/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.org/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果打不开可以使用这个地址：&lt;a href=&quot;https://golang.google.cn/dl/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://golang.google.cn/dl/。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="https://mah93.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mah93.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>TypeSript简介</title>
    <link href="https://mah93.github.io/2019/05/30/typescript-mooc/"/>
    <id>https://mah93.github.io/2019/05/30/typescript-mooc/</id>
    <published>2019-05-30T03:48:30.000Z</published>
    <updated>2019-07-05T08:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/30/typescript-mooc/typescript_intro.jpeg" alt="typescript_intro.jpeg" title=""><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>可以在变量的后面用冒号来指定该参数的类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> myname: string = <span class="string">"hello"</span></div><div class="line">myname = <span class="number">0</span> <span class="comment">// 提示类型错误</span></div><div class="line"></div><div class="line"><span class="comment">// typescript有类型推断</span></div><div class="line"><span class="selector-tag">var</span> myage = <span class="string">"xixi"</span></div><div class="line">myage = <span class="number">13</span> <span class="comment">// 提示类型错误</span></div></pre></td></tr></table></figure><a id="more"></a> <p>不仅可以在变量后面指定类型，还可以在方法后以及方法需要的参数后面</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(name: string)</span>: string </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在类中定义参数类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span> &#123;</div><div class="line"><span class="attribute">name</span>: string;</div><div class="line"><span class="attribute">age</span>: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>给参数一个默认值</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname: <span class="keyword">string</span> = <span class="string">"hello world"</span></div></pre></td></tr></table></figure><p>给方法中的参数指定一个默认值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test(<span class="selector-tag">a</span>: string, <span class="selector-tag">b</span>: string = <span class="string">"jojo"</span>) &#123;</div><div class="line"><span class="comment">// 可以只传a值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>带默认值的参数要放到函数的最后面</p></blockquote><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p> 通过问号为函数指定一个可选参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">test</span><span class="params">(a: <span class="built_in">string</span>, b?: <span class="built_in">string</span>, c: <span class="built_in">string</span> = <span class="string">"jojo"</span>)</span> </span>&#123;</div><div class="line"><span class="comment">// </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>可选参数必须放在必传参数后面</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="拓展参数"><a href="#拓展参数" class="headerlink" title="拓展参数"></a>拓展参数</h3><p>通过拓展运算符为函数添加一个参数集</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">args.forEach()</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>该函数可以接受任意数量的参数</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="built_in">console</span>.log(c)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">test(...list);</div><div class="line"><span class="comment">// 只会输出1，2，3</span></div><div class="line"><span class="comment">// 因为test方法只能接受三个参数</span></div></pre></td></tr></table></figure><h3 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h3><p>通过*来声明一个generator函数</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function * doSomething() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">'start'</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">yield<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'finish'</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">doSomething</span><span class="params">()</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">start</span></span></div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">next</span><span class="params">()</span>; //  输出<span class="title">finish</span></span></div></pre></td></tr></table></figure><blockquote><p>在每次调用next()方法后，程序执行到yield就停止</p></blockquote><h3 id="析构表达式"><a href="#析构表达式" class="headerlink" title="析构表达式"></a>析构表达式</h3><p>通过表达式将对象或数组拆解成任意数量的变量</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getStock() &#123;</div><div class="line">return &#123;</div><div class="line"><span class="selector-tag">code</span>: <span class="string">'IBM'</span>,</div><div class="line">price: <span class="number">100</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">var</span> &#123;<span class="selector-tag">code</span>, price&#125; = getStock()</div></pre></td></tr></table></figure><blockquote><p>变量名称需要一一对应</p><p>可以通过冒号给对象里面的修改名称</p><p>var {code: codex, price} = getStock()</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">array</span>1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">var [a, b] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2</span></div><div class="line">var [ , , , d] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// d = 4</span></div><div class="line">var [a, b, ...others] = <span class="built_in">array</span>1;</div><div class="line"><span class="comment">// a = 1, b = 2, others = [3, 4]</span></div></pre></td></tr></table></figure><h2 id="表达式以及循环"><a href="#表达式以及循环" class="headerlink" title="表达式以及循环"></a>表达式以及循环</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4, 5]</div><div class="line">array.filter(value =&gt; value%2 == 0)</div></pre></td></tr></table></figure><h3 id="forEach-、for-in-和-for-of"><a href="#forEach-、for-in-和-for-of" class="headerlink" title="forEach()、for in 和 for of"></a>forEach()、for in 和 for of</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4];</div><div class="line">array.desc = <span class="string">"array"</span>;</div><div class="line"></div><div class="line">array.forEach(value = &gt; console.log(value));</div><div class="line">// 不允许break，循环对象的值</div><div class="line">// 1， 2， 3， 4</div><div class="line"></div><div class="line">for(var n in array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 循环对象属性名称</div><div class="line">// 1， 2， 3， 4， array</div><div class="line"></div><div class="line">for(var n of array) &#123;</div><div class="line">console.log(n);</div><div class="line">&#125;</div><div class="line">// 忽略属性，可以通过break跳出循环</div><div class="line">// 1， 2， 3， 4</div></pre></td></tr></table></figure><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>访问控制符</p><p>public共有的，在类内部外部均可以使用，默认</p><p>private私有的，在类的内部使用</p><p>protected保护的，类以及其子类中可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">name;</div><div class="line">eat() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"eat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">"batman"</span>;</div><div class="line">p1.eat();</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">p2.name = <span class="string">"superman"</span>;</div><div class="line">p2.eat();</div></pre></td></tr></table></figure><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>通过super关键字调用父类的方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">constructor() &#123;</div><div class="line"><span class="keyword">super</span>(); <span class="comment">// 调用父类的构造函数</span></div><div class="line">console.log(<span class="string">"new"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>通过&lt;&gt;来指定数据结构存储的内容类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> work: <span class="keyword">Array</span>&lt;Person&gt; = [];</div></pre></td></tr></table></figure><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>用来建立某种代码约定，使得其他开发者在调用某个方法或者创建新的类时必须遵循接口所定义的代码约定</p><p>通过interface关键字声明一个接口<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> IPerson &#123;</div><div class="line">name: <span class="built_in">string</span>;</div><div class="line">age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person() &#123;</div><div class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> config: IPerson</span>) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过implements关键字使类实现接口中的方法</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat();</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat grass"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Animal</span> &#123;</span></div><div class="line">eat() &#123;</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"eat meat"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型定义文件（-d-ts）"><a href="#类型定义文件（-d-ts）" class="headerlink" title="类型定义文件（*.d.ts）"></a>类型定义文件（*.d.ts）</h3><p>通过该文件类型，可以与js其他的模块协同工作</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.imooc.com/learn/763" target="_blank" rel="external">TypeScript入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/05/30/typescript-mooc/typescript_intro.jpeg&quot; alt=&quot;typescript_intro.jpeg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;h3 id=&quot;参数类型&quot;&gt;&lt;a href=&quot;#参数类型&quot; class=&quot;headerlink&quot; title=&quot;参数类型&quot;&gt;&lt;/a&gt;参数类型&lt;/h3&gt;&lt;p&gt;可以在变量的后面用冒号来指定该参数的类型&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myname: string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myname = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// typescript有类型推断&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; myage = &lt;span class=&quot;string&quot;&gt;&quot;xixi&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myage = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 提示类型错误&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="typescript" scheme="https://mah93.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Flutter简介以及环境配置</title>
    <link href="https://mah93.github.io/2019/04/03/flutter-introduce/"/>
    <id>https://mah93.github.io/2019/04/03/flutter-introduce/</id>
    <published>2019-04-03T03:17:04.000Z</published>
    <updated>2019-04-03T03:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/03/flutter-introduce/flutter_intro.png" alt="flutter_intro.png" title=""><h2 id="App跨平台方案"><a href="#App跨平台方案" class="headerlink" title="App跨平台方案"></a>App跨平台方案</h2><h3 id="Hybrid框架"><a href="#Hybrid框架" class="headerlink" title="Hybrid框架"></a>Hybrid框架</h3><p>Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。</p><p>由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：</p><img src="/2019/04/03/flutter-introduce/flutter_hybrid.png" alt="flutter_hybrid.png" title=""><a id="more"></a> <h3 id="响应式视图"><a href="#响应式视图" class="headerlink" title="响应式视图"></a>响应式视图</h3><p>像ReactJS或其他的响应式编程框架已经变得很流行了，主要是因为他们通过使用从响应式编程中借用的编程模式来简化 Web 视图的创建过程。2015 年， React Native 将响应式视图的许多优势带给了移动应用程序。React Native 是非常受欢迎的（这是它应得的），但是因为 JavaScript 访问了原生 UI 组件，所以它也必须经过这些“桥接器”，界面上的 UI 控件通常被频繁地访问（在动画、转化或者用户用手指“滑动”屏幕上的某些东西时，每秒被访问高达 60 次），因此这很可能会导致性能问题。</p><img src="/2019/04/03/flutter-introduce/flutter_react.png" alt="flutter_react.png" title=""><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>和 React Native 一样，Flutter 也提供响应式的视图，Flutter 采用不同的方法避免由 JavaScript 桥接器引起的性能问题，即用名为 Dart 的程序语言来编译。Dart 是用预编译的方式编译多个平台的原生代码，这允许 Flutter 直接与平台通信，而不需要通过执行上下文切换的 JavaScript 桥接器。编译为原生代码也可以加快应用程序的启动时间。</p><img src="/2019/04/03/flutter-introduce/flutter_frame.png" alt="flutter_frame.png" title=""><h2 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的<strong>原生用户</strong>界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。简单来说，Flutter是一款移动应用程序SDK，包含框架、控件和一些工具，可以用一套代码同时构建Android和iOS应用，并且性能可以达到原生应用一样的性能。详情请参考<a href="https://flutter.io/" target="_blank" rel="external">Flutter简介</a> 。</p><ul><li>快速开发：毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</li><li>富有表现力和灵活的UI：快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</li><li>原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里仅以在Mac下搭建为例，在其它系统上配置环境请参考<a href="https://flutter.dev/docs/get-started/install" target="_blank" rel="external">flutter 官网</a></p><h3 id="获取Flutter-SDK"><a href="#获取Flutter-SDK" class="headerlink" title="获取Flutter SDK"></a>获取Flutter SDK</h3><ol><li><p>去flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#macos" target="_blank" rel="external">转到下载页</a> 。</p><p>注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="external">转到下载页</a> 。</p></li><li><p>解压安装包到你想安装的目录，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/development</div><div class="line">unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</div></pre></td></tr></table></figure></li><li><p>添加<code>flutter</code>相关工具到path中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=`pwd`/flutter/bin:$PATH</div></pre></td></tr></table></figure></li></ol><blockquote><p> 由于一些<code>flutter</code>命令需要联网获取数据，如果您是在国内访问，直接访问很可能不会成功。可以使用以下镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">PUB_HOSTED_URL</span>=https://pub.flutter-io.cn</div><div class="line">&gt; <span class="builtin-name">export</span> <span class="attribute">FLUTTER_STORAGE_BASE_URL</span>=https://storage.flutter-io.cn</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>注意：</strong> 此镜像为临时镜像，并不能保证一直可用，可以参考详情请参考 <a href="https://github.com/flutter/flutter/wiki/Using-Flutter-in-China" target="_blank" rel="external">Using Flutter in China</a> 以获得有关镜像服务器的最新动态。</p></blockquote><h3 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h3><p>您在命令行只能更新当前会话的PATH变量，如<a href="https://flutterchina.club/setup-macos/#clone-the-repo" target="_blank" rel="external">Clone Flutter repo</a>所示。 但是，您可能需要的是永久更新此变量，以便您可以运行<code>flutter</code>命令在任何终端会话中。</p><p>对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如</p><ol><li>确定您Flutter SDK的目录，您将在步骤3中用到。</li><li>打开(或创建) <code>$HOME/.bash_profile</code>. 文件路径和文件名可能在您的机器上不同.</li><li>添加以下行并更改<code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code>为克隆Flutter的git repo的路径:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置</div><div class="line">export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH</div></pre></td></tr></table></figure><blockquote><p>注意：<code>PATH_TO_FLUTTER_GIT_DIRECTORY</code> 为你flutter的路径，比如“~/document/code”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=~/document/code/flutter/bin:$PATH</div></pre></td></tr></table></figure><ol><li>运行 <code>source $HOME/.bash_profile</code> 刷新当前终端窗口.</li></ol><blockquote><p><strong>注意:</strong> 如果你使用的是zsh，终端启动时 <code>~/.bash_profile</code> 将不会被加载，解决办法就是修改 <code>~/.zshrc</code> ，在其中添加：source ~/.bash_profile</p></blockquote><ol><li>通过运行<code>flutter/bin</code>命令验证目录是否在已经在PATH中:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div></pre></td></tr></table></figure><h3 id="安装iOS环境以及Android环境"><a href="#安装iOS环境以及Android环境" class="headerlink" title="安装iOS环境以及Android环境"></a>安装iOS环境以及Android环境</h3><p>安装Xcode以及Android Studio，详情参考<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="external">平台配置</a></p><h3 id="检查flutter环境"><a href="#检查flutter环境" class="headerlink" title="检查flutter环境"></a>检查flutter环境</h3><p>以上步骤完成之后，运行<code>flutter doctor</code>检查环境是否配置成功</p><img src="/2019/04/03/flutter-introduce/flutter_doctor.png" alt="flutter_doctor.png" title=""><p>遇到任何的错误，请按照命令行提示执行</p><h3 id="运行flutter"><a href="#运行flutter" class="headerlink" title="运行flutter"></a>运行flutter</h3><p>通过<code>flutter create myapp</code>命令创建一个flutter 初始项目，通过命令行进入该项目<code>cd myapp</code>，连接好手机设备之后，通过<code>flutter run</code>命令运行app</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">flutter</span> <span class="string">create myapp</span></div><div class="line"><span class="attr">cd</span> <span class="string">myapp</span></div><div class="line"><span class="attr">flutter</span> <span class="string">run</span></div></pre></td></tr></table></figure><p>运行成功之后，可以在app中看到如下页面，通过修改<code>lib/main.dart</code>文件来创建自己的应用</p><img src="/2019/04/03/flutter-introduce/flutter_hello.gif" alt="flutter_hello.gif" title=""><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flutterchina.club/" target="_blank" rel="external">Flutter中文网</a></li><li><a href="https://www.infoq.cn/article/why-is-flutter-revolutionary" target="_blank" rel="external">为什么说 Flutter 是革命性的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_intro.png&quot; alt=&quot;flutter_intro.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;App跨平台方案&quot;&gt;&lt;a href=&quot;#App跨平台方案&quot; class=&quot;headerlink&quot; title=&quot;App跨平台方案&quot;&gt;&lt;/a&gt;App跨平台方案&lt;/h2&gt;&lt;h3 id=&quot;Hybrid框架&quot;&gt;&lt;a href=&quot;#Hybrid框架&quot; class=&quot;headerlink&quot; title=&quot;Hybrid框架&quot;&gt;&lt;/a&gt;Hybrid框架&lt;/h3&gt;&lt;p&gt;Hybrid App，其实就是原生应用和Web应用相结合，一般做法就是项目中的某一部分是原生界面，一部分是Web页面，通过原生平台的WebView去调用Web页面。&lt;/p&gt;
&lt;p&gt;由于原生WebView存在一定的局限性，和Web交互起来有些问题不好处理，于是出现了一些基于原生WebView封装的Hybrid框架，这些框架有一个共同特点：封装了移动端设备上最常用的本地API调用，然后以统一的Javascript API形式提供给Web开发者调用。这样一来原生不能解决的问题可以用Web去处理，同时你也可以自己封装原生API，做成一些插件使用。比较热门的Hybrid框架有Ionic、Cordova、DCloud：&lt;/p&gt;
&lt;img src=&quot;/2019/04/03/flutter-introduce/flutter_hybrid.png&quot; alt=&quot;flutter_hybrid.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://mah93.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://mah93.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks小笔记</title>
    <link href="https://mah93.github.io/2019/03/26/react-hooks/"/>
    <id>https://mah93.github.io/2019/03/26/react-hooks/</id>
    <published>2019-03-26T04:43:55.000Z</published>
    <updated>2019-03-26T04:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/26/react-hooks/react-hook.png" alt="react-hook.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，它主要目的是为了解决<strong>状态共享</strong>的问题。是继 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html" target="_blank" rel="external">render-props</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html" target="_blank" rel="external">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p><ol><li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li><li>Hooks 可以引用其他 Hooks。</li><li>更容易将组件的 UI 与状态分离。</li></ol><blockquote><p> 在react-native的0.59.0中，即可支持react hooks的写法。</p></blockquote><a id="more"></a> <h2 id="使用react-hooks创建组件"><a href="#使用react-hooks创建组件" class="headerlink" title="使用react hooks创建组件"></a>使用react hooks创建组件</h2><p>在react native中创建一个组件大概如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      number: <span class="number">0</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">componentDidMount() &#123;</div><div class="line"><span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnMount() &#123;</div><div class="line"> <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentWillReceiveProps(nextProps: <span class="type">Props</span>) &#123;</div><div class="line"><span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">    &lt;<span class="type">View</span>&gt;</div><div class="line">    &lt;<span class="type">Text</span> onPress=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; numer: <span class="keyword">this</span>.state.number + <span class="number">1</span> &#125;)&#125;&gt;</div><div class="line">        &#123;<span class="keyword">this</span>.state.number&#125;</div><div class="line">    &lt;/<span class="type">Text</span>&gt;</div><div class="line">    &lt;/<span class="type">View</span>&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而使用react hooks</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面渲染之后执行</span></div><div class="line">doSomethingA();</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 页面卸载时执行</span></div><div class="line">   doSomethingB();</div><div class="line">&#125;</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 页面接收到新参数</span></div><div class="line">    doSomethingC();</div><div class="line">&#125;, [number]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; setNumber(number + <span class="number">1</span>)&#125;&gt;</div><div class="line">      &#123;number&#125;</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由上述例子可见，使用了react hooks之后，组件由class变成了function。变得更加的轻量级，尤其是在创建无状态组件的时候，使用hooks更加具有优势，代码量减少。</p><h2 id="Hooks-API-Reference"><a href="#Hooks-API-Reference" class="headerlink" title="Hooks API Reference"></a>Hooks API Reference</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; useState &#125; <span class="keyword">from</span> 'react';</div><div class="line">const [<span class="keyword">state</span>, <span class="built_in">set</span>State] = useState(initialState);</div></pre></td></tr></table></figure><p>useState是可以看作是state与setState的替换，它返回有状态值，以及更新它的函数。在初始渲染期间，返回的状态（状态）与作为第一个参数（initialState）传递的值相同。而setState函数用于更新状态。 它接受一个新的状态值并将组件重新渲染。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setState(<span class="keyword">new</span><span class="type">State</span>);</div></pre></td></tr></table></figure><p>在后续重新渲染期间，useState返回的第一个值将始终是应用更新后的最新状态。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line">useEffect(didUpdate);</div></pre></td></tr></table></figure><p>useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。那么他就可以用来代替componentDidMount、componentWillReceiveProps以及componentWillUnmount三个生命周期。而且还支持第二个值来指定某些值作为useEffect的触发条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Clean up the subscription</span></div><div class="line">    subscription.unsubscribe();</div><div class="line">  &#125;;</div><div class="line">&#125;, []);</div></pre></td></tr></table></figure><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">value</span> = useContext(MyContext);</div></pre></td></tr></table></figure><p>接受上下文对象（从React.createContext返回的值）并返回该上下文的当前上下文值。 当前上下文值由树中调用组件上方最近的<mycontext.provider>的值prop确定。</mycontext.provider></p><p>当组件上方最近的<mycontext.provider>更新时，此Hook将触发重新呈现，并将最新的上下文值传递给该MyContext提供程序。</mycontext.provider></p><blockquote><p>useContext的参数必须是上下文对象本身</p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>可以使用这个hook来实现一个redux机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</div><div class="line">      <span class="keyword">return</span> init(action.payload);</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(</div><div class="line">    reducer,</div><div class="line">    &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">      &lt;Text&gt;Count: &#123;state.count&#125;&lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/</span>Text&gt;</div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">      &lt;Text onPress=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: <span class="number">0</span>&#125;)&#125;&gt;</div><div class="line">        Reset</div><div class="line">      &lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>View&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="其它Hooks"><a href="#其它Hooks" class="headerlink" title="其它Hooks"></a>其它Hooks</h3><p>除了以上提及的hooks，react还内置了其它的hooks，详情请参考<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="external">精读《React Hooks》</a></p></li><li><p><a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="external">Hooks API Reference</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/26/react-hooks/react-hook.png&quot; alt=&quot;react-hook.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;React Hooks 是 React &lt;code&gt;16.7.0-alpha&lt;/code&gt; 版本推出的新特性，它主要目的是为了解决&lt;strong&gt;状态共享&lt;/strong&gt;的问题。是继 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;render-props&lt;/a&gt; 和 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;higher-order components&lt;/a&gt; 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。&lt;/p&gt;
&lt;p&gt;React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。&lt;/li&gt;
&lt;li&gt;Hooks 可以引用其他 Hooks。&lt;/li&gt;
&lt;li&gt;更容易将组件的 UI 与状态分离。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt; 在react-native的0.59.0中，即可支持react hooks的写法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-native模版</title>
    <link href="https://mah93.github.io/2019/03/19/react-native-template/"/>
    <id>https://mah93.github.io/2019/03/19/react-native-template/</id>
    <published>2019-03-19T11:45:18.000Z</published>
    <updated>2019-03-19T11:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版</p><p>hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。</p><h3 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h3><p>通过如下命令创建模版工程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template AAA</div></pre></td></tr></table></figure><p>其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"react-native-template-AAA"</span>,<span class="comment">//上传 NPM 仓库的名称</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.0.2"</span><span class="comment">//版本号，同一仓库不可以上传两次同版本号的内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后就可以上传至<a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>上。注册完账号之后在命令行中登录</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><p>之后进入你的模版工程目录发布即可</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm publish --<span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npmjs.org</div></pre></td></tr></table></figure><a id="more"></a> <h3 id="react-native-template-mah简介"><a href="#react-native-template-mah简介" class="headerlink" title="react-native-template-mah简介"></a>react-native-template-mah简介</h3><p>这是一个关于react-native的模版，用于新项目的初始化或者是作为RN的练习项目</p><p>该模版集成了RN常用的第三方组件，如react-navigation、netinfo等，采用mobx作为数据管理。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>新建项目的时候使用如下命令</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> XXX --template mah</div></pre></td></tr></table></figure><p>其中XXX为项目的名称可以随便填写，后面mah即指定为以<code>react-native-template-mah</code>为模版新建项目。命令执行完成之后，进入项目根目录</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd XXX</div><div class="line"><span class="built_in">npm</span> install</div><div class="line">react-<span class="keyword">native</span> run-ios &amp;&amp; react-<span class="keyword">native</span> run-android</div></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── src</div><div class="line">|   ├── app.js         <span class="string">//</span> app 配置文件</div><div class="line">|   ├── compenents     <span class="string">//</span> 组件</div><div class="line">|   ├── constant       <span class="string">//</span> 常量</div><div class="line">|   ├── image          <span class="string">//</span> 图片资源</div><div class="line">|   ├── mobx           <span class="string">//</span> mobx逻辑处理</div><div class="line">|   ├── pages          <span class="string">//</span> 页面文件</div><div class="line">|   └── untils         <span class="string">//</span> 常用工具</div><div class="line">├── index.js           <span class="string">//</span> app 入口文件</div><div class="line">├── <span class="string">.eslintrc.js</span>       <span class="string">//</span> eslint配置文件</div><div class="line">├── <span class="string">.prettierrc.js</span>     <span class="string">//</span> prettier配置文件</div><div class="line">└── <span class="string">.flowconfig.js</span>     <span class="string">//</span> flow配置文件</div></pre></td></tr></table></figure><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p>该模版采用mobx作为数据管理工具，在App.js中提供了Provider方法以方便子组件通过inject的方式注入。inject的方式一般用于注入配置之类的数据，对于具体每个页面中的store还是推荐import引入并初始化的方式。一个页面对应一个store管理，对于页面来说需要有一个类似container的父组件调节组件与数据之间的关系，而其子组件使用纯函数创建以确保组件的复用性。</p><p>关于mobx的具体的使用方法请参照<a href="https://cn.mobx.js.org/" target="_blank" rel="external">mobx官网</a></p><h4 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h4><p>react-navigation 3.x与之前的版本有些许不同，但常用的方法依旧是StackNavigation和TabNavigation。通过react-navigation组织页面关系，将所有的跳转配置以及页面配置都在app_router.js下。这种集中的处理方式，为后续维护带来很大的便利。</p><blockquote><p>在自己的项目中引入react-navigation，如果报错的话请查看是否已经安装react-native-gesture-handler</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; npm install --save react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt; react-<span class="keyword">native</span> link react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>模版中采用了axios作为请求工具，具体方法可查看<a href="https://github.com/axios/axios" target="_blank" rel="external">axios的github</a>。在untils/request.js中简单的封装了post和get请求，通过Promise的方式返回数据。</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul><li><p>引入了eslint和prettier作为代码规范的检查</p></li><li><p>引入flow做参数类型检查</p></li><li>实现了换肤功能，为了展示inject的用法</li><li>定义了一些简单的常量，如屏幕宽高</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/b11c134cfa6f" target="_blank" rel="external">《React Native高效开发》之 template</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/a&gt;模版&lt;/h3&gt;&lt;p&gt;项目模版就是在项目创建之后，默认带的一些文件。比如用react-native-cli创建的项目，运行之后就会看到react-native为你预设的模版&lt;/p&gt;
&lt;p&gt;hello world。这里就介绍一下如何创建自己的模版工程，将一些常用的功能放入模版之中，以后再新建项目不必从头开始配置了。&lt;/p&gt;
&lt;h3 id=&quot;创建模版&quot;&gt;&lt;a href=&quot;#创建模版&quot; class=&quot;headerlink&quot; title=&quot;创建模版&quot;&gt;&lt;/a&gt;创建模版&lt;/h3&gt;&lt;p&gt;通过如下命令创建模版工程&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;react-&lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; XXX --template AAA&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中AAA是你的模版在npm上的名称，可以供别人使用。新建完工程之后，它和普通的项目没有区别。可以在上面加入你需要的功能。完成之后在package.json中修改你的模版名称以及版本号&lt;/p&gt;
&lt;figure class=&quot;highlight 1c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;react-native-template-AAA&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//上传 NPM 仓库的名称&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;0.0.2&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//版本号，同一仓库不可以上传两次同版本号的内容&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后就可以上传至&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm官网&lt;/a&gt;上。注册完账号之后在命令行中登录&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm adduser --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后进入你的模版工程目录发布即可&lt;/p&gt;
&lt;figure class=&quot;highlight tcl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm publish --&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://&lt;span class=&quot;keyword&quot;&gt;registry&lt;/span&gt;.npmjs.org&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Redux初体验</title>
    <link href="https://mah93.github.io/2019/03/13/redux-learning/"/>
    <id>https://mah93.github.io/2019/03/13/redux-learning/</id>
    <published>2019-03-13T11:29:01.000Z</published>
    <updated>2019-03-13T11:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/13/redux-learning/redux-logo.png" alt="redux-logo.png" title=""><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。</p><h3 id="为什么要用状态管理"><a href="#为什么要用状态管理" class="headerlink" title="为什么要用状态管理"></a>为什么要用状态管理</h3><p>在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。</p><p>setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？</p><a id="more"></a> <p>首先，setState并不能保证是一个同步的方法，有可能是同步的，也有可能是异步的。它是一个合成法方法，后续会调用一系列的方法来完成组件重新渲染，关于setState的问题详情可以看<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">这里</a>。总之，state的状态并不是可以预测的。其次，在实际的生产中，复杂的页面会导致render下的DOM结构非常复杂，会包含一百到几百行的JSX代码。假如这个时候去改变其中某一个button的选中状态，本意是只改动button这个组件，其他的组件保持当前状态不动。当调用setState的时候，它并不会智能的仅仅改变button的状态，而是重新渲染整个庞大的DOM树。虽然React在Virtual DOM做了优化，但这种大规模的无用渲染仍然会影响应用性能。当然有解决的方法，就是将大组件拆分，分成很多的小组件，然后在shouldComponentUpdate中去做优化。关于shouldComponentUpdate相关优化问题可以参考<a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">这里</a>。还有的话就是，state数据与JSX混杂在同一个页面，耦合高十分不方便维护。一般来说页面的UI、逻辑、网络请求分开来写，既方便维护，代码逻辑也很清楚。</p><p>上述的问题只是本人在React-Native上实践遇到的，如果有任何错误，请及时通知我。</p><h3 id="Redux思想"><a href="#Redux思想" class="headerlink" title="Redux思想"></a>Redux思想</h3><p>既然在state以及setState实践上遇到了问题，那么Redux是如何解决这些问题的呢？先来看看Redux的核心概念：Action、Reducer和Store。Store中存储了数据state，state这个对象就像 “Model”，区别是它并没有 setter（修改器方法），因此其它的代码不能随意修改它，造成难以复现的 bug。Action 就是一个普通 JavaScript 对象它是用来描述发生了什么。为了把 action 和 state 串起来，开发一些函数，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 以上差不多就是Redux的全部思想了，Store、Action、Reducer各司其职配合工作。</p><p>在这里还要强调Redux中的三个原则：单一数据源、State 是只读的、使用纯函数来执行修改。</p><ol><li>单一数据源：<strong>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</strong></li><li>State 是只读的：<strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></li><li>使用纯函数来执行修改：<strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></li></ol><h3 id="在React-Native中使用"><a href="#在React-Native中使用" class="headerlink" title="在React-Native中使用"></a>在React-Native中使用</h3><p>既然已经了解了Redux的基础概念，那么就在React-Native中使用它，才能进一步理解Redux是如何运作的。使用Redux实现一个简单的计数器。</p><img src="/2019/03/13/redux-learning/redux-count.png" alt="redux-count.png" title=""><p>就是这样的一个简单的例子，点击➕号数字加一，点击➖数字减一。当然在这里是可以用setState来实现的，为了学习Redux还是将它按照Redux的规范来编写。</p><p>首先要先引入redux，在项目的根目录执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux</span></div></pre></td></tr></table></figure><h4 id="构建UI"><a href="#构建UI" class="headerlink" title="构建UI"></a>构建UI</h4><p>首先我们先构建出这个UI页面，只要是接触过React-Native。那么是很容易实现的，大致的代码是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export default class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, addNumber, inNumber &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;0&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 加一&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UI出现了，那么就差点击事件的处理了。</p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>这里我们需要发起一个事件，在这里点击的时候要让数字加一，所以首先要构建一个Action描述一个这个事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// action</div><div class="line">export const addNumber = number =&gt; (&#123;</div><div class="line">  type: &apos;INCREMENT&apos;,</div><div class="line">  number</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>type相当于key，作为Action的一个标识，注意这里的type是不可以有重复的，保证其唯一性。还接受了一个参数number，就是点击的时候，要在当前的number基础上加一。</p><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>上面的Action仅仅表示了要发生的事情，并没有描述这个事情该怎么做。Reducer的功能就是去具体的实现state的变化，在这里就是承担了加一这个事情。记住，Reducer是一个纯函数，它接收state和action作为参数，并且返回一个新的state。也即是(state, action) =&gt; newState。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// reducer</div><div class="line">export default function changeNumber(state=0, action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">    case &apos;INCREMENT&apos;:</div><div class="line">      return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">        number: action.number + 1</div><div class="line">      &#125;);</div><div class="line">  default:</div><div class="line">  return state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还记得之前的Action设置的type吗？在Reducer中它作为区分不同的Action的一个标识，Reduce通过不同的type可以处理很多的Action。注意到Reducer返回了一个新的对象，虽然只改变了state中的一个字段。这里是通过Object.assign方法来实现的，也可以使用ES6中的{..state, number: action.number + 1}来完成这一操作。</p><p>现在完成了➕事件的处理，就差把onPress事件和Action连接起来了。</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>在一个应用中只存在一个store，为了方便所有子组件访问该store，一般来说会在顶层组件中提供Provider组件，以便于子组件可以通过props的方式访问到store，可以自己实现一个Provider，一般的情况使用的是第三方组件react-redux。在项目的根目录中引用该组件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save react-redux</span></div></pre></td></tr></table></figure><p>在项目的入口文件中，用Provider将UI组件包裹起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Provider&gt;</div><div class="line">&lt;Count /&gt;</div><div class="line">&lt;/Provider&gt;</div></pre></td></tr></table></figure><p>这里还有没将store传入Provider中，首先要创建一个store，通过Redux提供的createStore方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line">import rootReducer from &apos;./src/reducers/index&apos;;</div><div class="line"></div><div class="line">export default class App extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const store = createStore(rootReducer);</div><div class="line">    return (</div><div class="line">      &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Count /&gt;</div><div class="line">      &lt;/Provider&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>createStore方法接受一个Reducer，将刚才写的Reducer传入其中即可完成一个store创建。下面就是将store与UI关联起来。在最开始写完的UI页面中加入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</div><div class="line">import &#123; addNumber &#125; from &apos;./actions/countAction&apos;</div><div class="line"></div><div class="line">type Props = &#123;&#125;;</div><div class="line">class Count extends Component&lt;Props&gt; &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; number, plus &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;&#123;number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; plus(number)&#125;&gt;+&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;() =&gt; 减一&#125;&gt;-&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapStateToProps(state)&#123;</div><div class="line">return &#123;</div><div class="line">number: state.number,</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapDispatchToProps(dispatch)&#123;</div><div class="line">  return &#123;</div><div class="line">    plus: id =&gt; &#123;</div><div class="line">      dispatch(addNumber(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(mapStateToProps,mapDispatchToProps)(Count);</div></pre></td></tr></table></figure><p>主要是通过connect这个方法将store中的state以及action都传递给UI页面，可以通过props的方式访问store。在mapStateToProps以及mapDispatchToProps中定义参数名称以方便使用。完成以上所有代码之后，即可尝试运行代码，点击➕是否可以正常显示，减法和加法是同样的流程，这里并不做说明。</p><p>到这里就完成了一个由Redux构建的应用，可以看到为了实现一个方法的调用，做了很多的工作，从Action到Reducer再到state然后在渲染页面。可以说Redux的实现十分的繁琐，所以在具体的生产环节中，一定要思考清楚到底需不需要Redux，这里也有<a href="https://www.redux.org.cn/docs/faq/General.html" target="_blank" rel="external">何时使用Redux</a>的说明以供参考。</p><h4 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h4><p>关于Redux的中间件了解的并不多，这里只做简单的介绍。中间件实现的即是在Action与Reducer中间做一些操作的功能。比如，需要一个异步请求、需要调试每一次Actions执行的时候打印日志。这些都可以使用中间件完成。比如常用的redux-thunk、redux-logger等等。如果还是不知道中间件是做什么的，那么在项目中引用redux-logger</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save redux-logger</span></div></pre></td></tr></table></figure><p>完成之后，在创建store的时候将中间件添加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import logger from &apos;redux-logger&apos;;</div><div class="line">const store = createStore(rootReducer, applyMiddleware(logger));</div></pre></td></tr></table></figure><p>之后打开React-Native的调试页面，点击➕即可发现，控制台会自动的打印出相关的state信息，并不需要在代码中添加console.log操作，确实是极大的方便了调试。</p><img src="/2019/03/13/redux-learning/redux-logger.png" alt="redux-logger.png" title=""><p>redux-thunk主要是用来实现异步操作，比如网络请求之类的场景这里就不一一做尝试了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于Redux我了解也不是很多，只能做一些简单的demo。在上述例子中并没有介绍Redux其他的应用技巧，在后续的学习中，逐步了解这些技巧的原理后再做记录。Redux确实在开发流程上做出了很多的规范，无论它是否真的适合生产中应用，都是只得学习它的思想的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.redux.org.cn" target="_blank" rel="external">redux中文网</a></p></li><li><p><a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="external">你真的理解setState吗？</a></p></li><li><a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="external">React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/03/13/redux-learning/redux-logo.png&quot; alt=&quot;redux-logo.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux可以作为任何UI层的store，所以它可以运行在Angular、Angular 2、 Vue、React甚至React-Native中。Redux 提供的订阅机制，可以与任何代码集成。这里仅仅记录一些Redux在React-Native中的实现。&lt;/p&gt;
&lt;h3 id=&quot;为什么要用状态管理&quot;&gt;&lt;a href=&quot;#为什么要用状态管理&quot; class=&quot;headerlink&quot; title=&quot;为什么要用状态管理&quot;&gt;&lt;/a&gt;为什么要用状态管理&lt;/h3&gt;&lt;p&gt;在React中已经提供了state以及setState来实现页面的改动，那么为什么需要状态管理呢？无论是Mobx还是Redux都作为setState的替代品。那么state以及setState有什么缺陷，必须通过这种第三方的状态管理的介入去构建应用。&lt;/p&gt;
&lt;p&gt;setState方法在React中是一个很重要的方法，每当调用setState的时候React会重新渲染render方法，其中调用state的值就会相应发生改变，也就完成了一次页面响应。在React的教程中，也大多是这种介绍。那么问题在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="https://mah93.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>flow笔记</title>
    <link href="https://mah93.github.io/2019/01/04/flow-note/"/>
    <id>https://mah93.github.io/2019/01/04/flow-note/</id>
    <published>2019-01-04T04:41:21.000Z</published>
    <updated>2019-01-04T04:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/04/flow-note/flow-main.png" alt="flow-main.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JavaScript作为一种脚本语言是没有参数类型这个概念的，所以在编写代码的时候可以给参数赋予任何类型的值。在写JS的时候不用考虑参数类型、参数定义等等概念。当项目逐渐变大，人员逐渐变动的时候，没有任何参数类型再加上代码命名不规范，代码将变得十分难以维护。面对一个参数变量不知道它是用来做什么的。可能会有如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">main = () =&gt; &#123;</div><div class="line">   <span class="comment">//fn1函数获取了一个数据</span></div><div class="line">   <span class="keyword">var</span> <span class="class"><span class="keyword">object</span> </span>= fn1()</div><div class="line">   <span class="comment">//fn2根据获数据，产生一个结果</span></div><div class="line">   <span class="keyword">var</span> result = fn2(<span class="class"><span class="keyword">object</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">   <span class="title">return</span> <span class="title">result</span></span></div><div class="line"><span class="class">&#125;</span></div></pre></td></tr></table></figure><p>Flow是个JavaScript的静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写强类型语言相近的体验。</p><blockquote><p>由于之前是写Objective-C的，对于类型检查还是比较能接受的。虽然在编写代码的时候会繁琐一些，但是由于提前声明了参数的类型，使用起来会更加的“放心”。</p></blockquote><a id="more"></a> <hr><p>以下代码实践均在<code>react native</code>项目中实践</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> flow-bin</div></pre></td></tr></table></figure><p>创建配置文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">touch</span> <span class="selector-class">.flowconfig</span></div></pre></td></tr></table></figure><p>先不管空白的<em>.flowconfig</em>配置文件。在<em>package.json</em>文件里flow脚本。<br><strong>your project/package.json</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"flow"</span>: <span class="string">"flow; test <span class="variable">$?</span> -eq 0 -o <span class="variable">$?</span> -eq 2"</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>然后给需要flow检查的文件里加上<code>//@flow</code>或者<code>/*@flow*/</code>。然后就可以检查了。（也可以在命令中加上–all， 这样就会检查所有文件）。</p><p>在根目录下运行命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> flow</span></div></pre></td></tr></table></figure><p>以上就配置好了flow</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Flow最重要的功能就是允许在参数前添加类型注释，即规定该参数的数据类型。Flow内置了很多的数据类型，有些是给原生类型用的，像 <code>number</code> 和 <code>string</code>。 <code>any</code> 和 <code>mixed</code> 比较宽松，没有把值的类型限定死，而其他字面类型则描述某一种类型。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Flow中常用的基本数据类型有<code>number</code>、<code>string</code>、<code>boolean</code></p><blockquote><p>注意，这里的类型都是小写开头的</p></blockquote><p>他们的用法大致相同。都是在参数中声明该参数的类型，下面是一个使用<code>number</code>的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// js</div><div class="line">plus = (x, y) =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125; </div><div class="line"></div><div class="line">// @flow</div><div class="line">plus = (x: number, y: number) : number =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">plus(1, 2); // 正常返回3</div><div class="line">plus(&apos;1&apos;, 2); // 报错：Cannot call `plus` with `&apos;1&apos;` bound to `x` because string [1] is incompatible with number [2].</div><div class="line"></div><div class="line">// 可以看到使用了Flow之后，当传入了不符合预先声明的类型时Flow就会报错，当然这些错误并不影响代码的运行。</div><div class="line">// 不仅可以在定义函数的时候使用，而且可以在初始化变量的时候，就指定这个参数的类型，这和强类型语言的体验相似</div><div class="line">let number1: number = 5;</div><div class="line">let number2: number = &apos;5&apos;; // 报错</div></pre></td></tr></table></figure><h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><p>Flow中也内置了相关的复合数据类型，如<code>Array</code>、<code>Object</code>、<code>Function</code></p><blockquote><p>注意，这里的类型都是大写开头的</p></blockquote><p>他们的使用方式和基础数据类型差不多，不过<code>Array</code>在声明的时候，不仅可以声明这个参数是数组类型，还可以声明这个数组里面的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">let List1: Array&lt;number&gt; = [1];</div><div class="line">let List2: Array&lt;string&gt; = [&apos;21&apos;, &apos;22&apos;];</div><div class="line">let List3: Array&lt;boolean&gt; = [false];</div><div class="line"></div><div class="line">getFirst = (list: Array&lt;number&gt;) : number =&gt; &#123;</div><div class="line">    return list[0];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="任何数据类型"><a href="#任何数据类型" class="headerlink" title="任何数据类型"></a>任何数据类型</h4><p>当不确定一个参数的类型时，可以使用<code>mixed</code>来声明该参数，但是在使用的时候必须要判断这个参数的类型，否则Flow会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">plus = (y: mixed) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// mixed是混合类型的意思</div></pre></td></tr></table></figure><p>如果不希望这个参数被Flow检查，可以使用<code>any</code>即任意类型。如果频繁使用<code>any</code>来声明参数类型，那么Flow就没有任何意义了，尽量还是避免使用<code>any</code>。</p><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>Flow支持自定义的一些参数类型，不仅仅局限于它内置的几个。可以使用Flow轻松的实现一个枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">type myType = &apos;A&apos; | &apos;B&apos; | &apos;C&apos;;</div><div class="line">let testType: myType = &apos;A&apos;;</div><div class="line">// 定一个枚举，声明的参数如果是该枚举类型，那么它的值一定是在枚举类型中。</div></pre></td></tr></table></figure><h4 id="可选的参数类型"><a href="#可选的参数类型" class="headerlink" title="可选的参数类型"></a>可选的参数类型</h4><p>当一个参数不确定是什么类型的时候，上述的<code>mixed</code>可以实现但是并不常用，通常使用的是<code>|</code>来声明多个参数类型，或者使用<code>?</code>来代替<code>mixed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">plus = (y: ?number) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 这个?和mixed是一样的，意思是这个参数可能是number类型，当然也有可能是其他的类型。那么在使用的时候就需要对参数的类型判断</div><div class="line">// 如果参数的类型有两个，也就是说可能是number类型也可能是string类型，可以使用|来将所有的可能的参数类型列举出来</div><div class="line">plus = (y: number | string) : number =&gt; &#123;</div><div class="line">    if (typeof y === &apos;number&apos;) &#123;</div><div class="line">        return y;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 和上述的一样，使用之前都需要判断参数的类型才能使用</div></pre></td></tr></table></figure><h4 id="关于-的使用"><a href="#关于-的使用" class="headerlink" title="关于?的使用"></a>关于<code>?</code>的使用</h4><p>Flow中的<code>?</code>有两种使用方法，一个是在参数前表明这个参数是可选的，另一个是在数据类型前表示可能是这个参数类型，也可能是其他的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">let number2: ?number = 43; // 意思是这个参数有可能是number类型</div><div class="line">let string2: ?string = &apos;12&apos;; </div><div class="line"></div><div class="line">plus = (x?: number, y: number) : number =&gt; &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">// 这里的?意思是这个x参数可能不存在</div></pre></td></tr></table></figure><h3 id="在React-Native中使用"><a href="#在React-Native中使用" class="headerlink" title="在React Native中使用"></a>在React Native中使用</h3><p>在React Native自定义组件的时候，Flow可以用来声明其需要的属性，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// @flow</div><div class="line">// 该组件的属性</div><div class="line">type Props = &#123;</div><div class="line">  text?: string,</div><div class="line">  pointerEvents?: boolean,</div><div class="line">  timeout?: number,</div><div class="line">  onLoadingTimeout?: Function,</div><div class="line">  offsetY?: number,</div><div class="line">&#125;;  </div><div class="line">// 组件</div><div class="line">export default class Loading extends React.Component&lt;Props&gt; &#123;</div><div class="line">  static defaultProps = &#123;</div><div class="line">    pointerEvents: false,</div><div class="line">    timeout: 0,</div><div class="line">    offsetY: 0,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在自定义组件中不仅可以定义从父组件传递的参数，还可以定义默认属性。其他的用法和上述用法是相同的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flow本质上也只是个检查工具，它并不会自动修正代码中的错误，也不会强制说你没按照它的警告消息修正，就不会让你运行程序。当然，并没有要求什么时候一定要用这类的工具，只是这种作法可以让你的代码更具强健性与提高阅读性，也可以直接避去很多不必要的数据类型使用上的问题，这种开发方式目前在许多框架与函数库项目，或是以JavaScript应用为主的开发团队中都已经都是必用工具，在React、Vue源码中均在使用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="http://www.imooc.com/article/15855" target="_blank" rel="external">Flow - JS静态类型检查工具</a></p></li><li><p><a href="https://segmentfault.com/a/1190000006983211" target="_blank" rel="external">用flow.js提升前端开发的体验</a></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-flow" target="_blank" rel="external">认识Flow</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/04/flow-note/flow-main.png&quot; alt=&quot;flow-main.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;JavaScript作为一种脚本语言是没有参数类型这个概念的，所以在编写代码的时候可以给参数赋予任何类型的值。在写JS的时候不用考虑参数类型、参数定义等等概念。当项目逐渐变大，人员逐渐变动的时候，没有任何参数类型再加上代码命名不规范，代码将变得十分难以维护。面对一个参数变量不知道它是用来做什么的。可能会有如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;main = () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//fn1函数获取了一个数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;/span&gt;= fn1()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//fn2根据获数据，产生一个结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = fn2(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;   &lt;span class=&quot;title&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;result&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Flow是个JavaScript的静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写强类型语言相近的体验。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于之前是写Objective-C的，对于类型检查还是比较能接受的。虽然在编写代码的时候会繁琐一些，但是由于提前声明了参数的类型，使用起来会更加的“放心”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>init new project</title>
    <link href="https://mah93.github.io/2019/01/02/new-project/"/>
    <id>https://mah93.github.io/2019/01/02/new-project/</id>
    <published>2019-01-02T03:39:46.000Z</published>
    <updated>2019-01-02T08:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/02/new-project/new-project.png" alt="new-project.png" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近要开始写一个新的项目，算是将之前的项目做个总结。把有缺陷的地方进行修改，没有引入的组件引入，算是做一个提炼总结，把之前没有办法修改的问题一一修正。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>我这里使用的是官方提供的<code>react-native-cli</code>即</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init newProject --version <span class="number">0.57</span><span class="number">.0</span></div></pre></td></tr></table></figure><p>新项目当然是使用最新版本了，react-native从低版本向上升级真的是痛苦。</p><p>创建完新的项目之后当然是建立目录结构，目录结构确实是对项目有很大的影响。总之结合之前的项目经验，构建了如下的目录结构，当然其他的也没有问题，这里打算使用Mobx，所以将相关Mobx逻辑代码直接命名了Mobx文件夹。</p><a id="more"></a> <img src="/2019/01/02/new-project/new-file-menu.png" alt="new-file-menu.png" title=""><p>可以是很基础的目录结构，看文件夹名字就可以知道它的功能了。</p><p>在正式开始敲代码前还需要做以下准备工作。</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>eslint是airbnb公司推出的代码规范插件，为编写代码提供标准</p><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="built_in">export</span> PKG=eslint-config-airbnb;</div><div class="line">  npm info <span class="string">"<span class="variable">$PKG</span>@latest"</span> peerDependencies --json | <span class="built_in">command</span> sed <span class="string">'s/[\&#123;\&#125;,]//g ; s/: /@/g'</span> | xargs npm install --save-dev <span class="string">"<span class="variable">$PKG</span>@latest"</span></div><div class="line"></div><div class="line">)</div></pre></td></tr></table></figure><p>还需要安装babel-eslint</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install </span><span class="keyword">babel-eslint </span>--save-dev</div></pre></td></tr></table></figure><p>创建.eslintrc文件，可以将你需要的规则写在这个文件当中。</p><p>之后在package.json中的scripts中添加eslint执行命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint"</span>: <span class="string">"eslint --ext .js src/"</span></div></pre></td></tr></table></figure><blockquote><p>这个命令即为检查src文件夹下所有的js文件，eslint的命令行参数有很多，具体可以查看<a href="https://cn.eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="external">eslint配置</a></p><p>执行npm run lint即可验证该命令是否已经正确配置，如果有任何不符合eslint的规范的地方会在命令行中提示。也可以在上述的.eslintrc文件中修改eslint内置的规则，以符合具体的场景需求。</p><p>如果希望在src文件夹内，有些文件跳过这些规则的检查，可以在根目录下创建.eslintignore文件，将路径写入其中，eslint就会自动跳过这些文件。</p></blockquote><p>至此eslint的添加、引用以及配置都已经设置完毕，配合使用的编辑器中的插件会在日常输入代码的时候提示开发者符合eslint的规范。但是各个编译器的插件功能不同，有时并不会很准确的提示。所以在命令行中执行eslint的命令才能的到真正的检查结果。</p><p>为了避免忘记执行该命令，将不规范的代码提交到远程仓库，我们引入git的hook，它会在每次commit前调用配置中的命令，利用这个hook我们在每次提交前都执行一次eslint命令确保每次提交代码的规范性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> pre-<span class="keyword">commit</span> <span class="comment">--save-dev</span></div></pre></td></tr></table></figure><blockquote><p>如果你不希望此次提交被检查，可以使用-n来跳过hook</p></blockquote><p>并在package.json中加入</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pre-commit"</span>:[</div><div class="line"><span class="string">"eslint"</span></div><div class="line">]</div></pre></td></tr></table></figure><h3 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h3><p>flow是JavaScript 代码的静态类型检查工具，它能够捕获 JavaScript 代码中的常见问题，如静态类型转换不匹配、空指针引用等问题。同时，Flow 还为 JavaScript 新增了类型语法，如类型别名。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> flow-bin</div></pre></td></tr></table></figure><p>创建配置文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">touch</span> <span class="selector-class">.flowconfig</span></div></pre></td></tr></table></figure><p>先不管空白的<em>.flowconfig</em>配置文件。在<em>package.json</em>文件里flow脚本。<br><strong>your project/package.json</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"flow"</span>: <span class="string">"flow; test <span class="variable">$?</span> -eq 0 -o <span class="variable">$?</span> -eq 2"</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>然后给需要flow检查的文件里加上<code>//@flow</code>或者<code>/*@flow*/</code>。然后就可以检查了。（也可以在命令中加上–all， 这样就会检查所有文件）。</p><p>在根目录下运行命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> flow</span></div></pre></td></tr></table></figure><p>以上就配置好了flow，下面写一个简单的小例子来说明flow是如何运行的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> plus = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">plus(<span class="number">10</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure><p>其实也就是和平常写法没什么区别，只是在定义参数的时候要添加该参数的数据类型。如果传入非法的数据类型，flow则会报错。flow在多人开发中还是十分有效果的，如果不想使用typescript，那么js+flow也是不错的选择。flow当然还有很多其他的用法，这里就不一一介绍了。</p><h3 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h3><p>上一个项目中使用的就是mobx，总体来说使用起来十分简单。对于App的流畅性也有很大的提升。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>需要的依赖关系：mobx和mobx-react</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="selector-tag">i</span> mobx mobx-react --save</div></pre></td></tr></table></figure><p>我们还需要安装一个babel插件，以便我们可以使用ES7装饰器：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="selector-tag">i</span> babel-plugin-<span class="attribute">transform</span>-decorators-legacy --save-dev</div></pre></td></tr></table></figure><p>现在，让我们创建一个.babelrc文件来配置我们的插件：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [<span class="string">"react-native"</span>],</div><div class="line">  // 主要这两句话</div><div class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>自RN 0.56版本之后，react-native默认支持bable7，之前的写法都不对了。</p><p>首先，需要安装下面的4个babel库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/core</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/plugin-proposal-decorators</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/plugin-transform-runtime</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> @babel/runtime</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>将.babelrn修改为如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   <span class="string">"presets"</span>: [<span class="string">"module:metro-react-native-babel-preset"</span>],</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   <span class="string">"plugins"</span>: [</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     [<span class="string">"@babel/transform-runtime"</span>, &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">       <span class="string">"helpers"</span>: <span class="literal">true</span>,</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">       <span class="string">"regenerator"</span>: <span class="literal">false</span></span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     &#125;]</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">   ]</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h3><p>react-navigation 3.x与之前版本有较大区别</p><h4 id="安装react-navigation"><a href="#安装react-navigation" class="headerlink" title="安装react-navigation"></a>安装react-navigation</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react-navigation --save</div></pre></td></tr></table></figure><p>在新版本中新增了一个原生库<code>react-native-gesture-handler</code>如果没有安装，按如下方式安装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span> <span class="comment">--save</span></div><div class="line">react-<span class="keyword">native</span> <span class="keyword">link</span> react-<span class="keyword">native</span>-gesture-<span class="keyword">handler</span></div></pre></td></tr></table></figure><h4 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h4><p>之前使用的是<code>StackNavigator</code>来创建路由，在3.x中使用<code>createStackNavigator</code>并且需要由<code>createAppContainer</code>包裹起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">`react-navigation 1.x`</div><div class="line">const Navigator = StackNavigator(&#123;</div><div class="line">    Home: &#123;screen: Home&#125;</div><div class="line">&#125;,&#123;</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">export default Navigator;</div><div class="line"></div><div class="line">`react-navigation 3.x`</div><div class="line">const Navigator = createStackNavigator(&#123;</div><div class="line">    Home: &#123;screen: Home&#125;</div><div class="line">&#125;,&#123;</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">export default createAppContainer(Navigator);</div></pre></td></tr></table></figure><p>以上，同理<code>TabNavigator</code>修改为<code>createBottomTabNavigator</code></p><p>总之react-navigation 3.x与之前版本有较大出入，更多详情请看<a href="https://reactnavigation.org/" target="_blank" rel="external">react-navigation官网</a></p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>react-native中自带了<code>fetch</code>请求API，由于<code>fetch</code>中有很多功能不好实现，就选择<code>axios</code>做为网络请求库。<code>axios</code>起码可以设置请求超时时间，<code>fetch</code>的话只能使用<code>promise.race()</code>间接实现请求超时的功能。</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> axios</div></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>axios</code>和<code>fetch</code>在使用起来没有什么差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">`get请求`</div><div class="line">axios.get(&apos;/user&apos;, &#123;</div><div class="line">    params: &#123;</div><div class="line">      ID: 12345</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">`post请求`</div><div class="line">axios.post(&apos;/user&apos;, &#123;</div><div class="line">    firstName: &apos;Fred&apos;,</div><div class="line">    lastName: &apos;Flintstone&apos;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>当然<code>axios</code>还有很多配置选项，比如请求超时时间、设置请求头、配置代理、配置相应头等等，这些都可以在<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">axios中文文档</a>中查看</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新建一个项目需要多方面的考虑，这里只是写出我习惯用到的一些框架。后续肯定还有别的需求添加，但是大体上都是一些UI方面的功能性的东西，总体的项目框架已经搭建好了。这个也算是之前项目的一个总结吧。</p><p>以上</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.jianshu.com/p/dc9df5826651" target="_blank" rel="external">react-navigation使用技巧（再进阶）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/02/new-project/new-project.png&quot; alt=&quot;new-project.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近要开始写一个新的项目，算是将之前的项目做个总结。把有缺陷的地方进行修改，没有引入的组件引入，算是做一个提炼总结，把之前没有办法修改的问题一一修正。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h3&gt;&lt;p&gt;我这里使用的是官方提供的&lt;code&gt;react-native-cli&lt;/code&gt;即&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;react-native init newProject --version &lt;span class=&quot;number&quot;&gt;0.57&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新项目当然是使用最新版本了，react-native从低版本向上升级真的是痛苦。&lt;/p&gt;
&lt;p&gt;创建完新的项目之后当然是建立目录结构，目录结构确实是对项目有很大的影响。总之结合之前的项目经验，构建了如下的目录结构，当然其他的也没有问题，这里打算使用Mobx，所以将相关Mobx逻辑代码直接命名了Mobx文件夹。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>动手实现Promise</title>
    <link href="https://mah93.github.io/2018/12/24/my-promise/"/>
    <id>https://mah93.github.io/2018/12/24/my-promise/</id>
    <published>2018-12-24T08:08:35.000Z</published>
    <updated>2018-12-25T04:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/24/my-promise/promise2.jpg" alt="promise2.jpg" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">if(/* 一般是异步操作 */) &#123;</div><div class="line">        resolve(&apos;回调&apos;);</div><div class="line">&#125; else &#123;</div><div class="line">        reject(&apos;error&apos;);</div><div class="line">&#125; </div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((error) =&gt; &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面尝试一下自己去实现Promise的功能。</p><a id="more"></a> <h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 定一个构造函数</div><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    thenFunc = call;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    thenFunc &amp;&amp; thenFunc(value);</div><div class="line">    thenFunc = null;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>定义一个构造函数，将初始化的异步方法传入其中。在函数内部定一个变量来存储promise实例传递进来的then方法，当异步方法开始执行的时候就会在函数内部调用这个变量存储的函数，从将参数回调至promise实例中。</p><p>初始化的异步方法中，resolve参数其实是一个函数，对应到自定义的函数中就是thenCall方法，然后当resolve调用的时候，就是函数内部的用来存储then的变量执行的时候。</p><h4 id="初始化的方法不是异步的"><a href="#初始化的方法不是异步的" class="headerlink" title="初始化的方法不是异步的"></a>初始化的方法不是异步的</h4><p>如果在初始化的时候，传入的不是一个异步的函数，比如下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">resolve(&apos;ssss&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>由于执行顺序的问题，并不会回调到then方法中。可以想办法让then方法先执行，之后再执行resolve，利用Js的循环机制以及setTimeout，将resolve放入栈底执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">        thenFunc &amp;&amp; thenFunc(value);</div><div class="line">        thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>如果对于Js的循环机制和setTimeout不是很了解的话可以<a href="https://blog.csdn.net/u014346301/article/details/53897358" target="_blank" rel="external">参考这篇</a></p></blockquote><p> 这样就可以确保在有then的情况下，resolve在后面执行。</p><h4 id="promise调用时间很晚"><a href="#promise调用时间很晚" class="headerlink" title="promise调用时间很晚"></a>promise调用时间很晚</h4><p>如果初始化Promise实例之后，并没有立即使用它，而是间隔了一段时间再去调用promise的then方法，那么由于resolve已经执行完毕，所以即使是调用过了then方法也不会正确的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    promise.then((data) =&gt; &#123;</div><div class="line">    console.log(data);</div><div class="line">    &#125;).catch((err) =&gt; &#123;</div><div class="line">    console.log(&apos;error&apos; + err);</div><div class="line">    &#125;);  </div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>之前就已经介绍过了，Promise是有三种状态的：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。而且只能从<code>pending</code>转换为另外两种状态，而且是不可逆转的。可以借用Promise的这三种状态，让自己的Promise记住自己当前的状态。</p><p>添加一个记录Promise状态的变量，添加一个存储参数的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125;</div><div class="line">    call(callValue);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 在Promise初始化的时候，Promise的初始状态为<code>pending</code>，执行过thenCall方法后，改变自身状态为<code>fulfilled</code>，并且将传递的参数暂时保存到callValue中。过一段时间后，then执行的时候，由于状态已经改变，则会直接执行then中传递的回调函数，并将callValue作为回调参数。</p><h4 id="添加reject状态"><a href="#添加reject状态" class="headerlink" title="添加reject状态"></a>添加reject状态</h4><p>上述的方法都是只有resolve一个状态，其实reject与resolve相同，仅仅是执行了不同的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  this.catch = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      catchFunc = call;</div><div class="line">    &#125; else if (status === &apos;rejected&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const catchCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      catchFunc &amp;&amp; catchFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;rejected&apos;;</div><div class="line">      catchFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">        reject(&apos;ssss&apos;);</div><div class="line">&#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>关于return this，其实是将对象本身返回以供后续的catch或者其他操作，如果没有那么会报错说没有then方法或者没有catch方法。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><h4 id="自身调用"><a href="#自身调用" class="headerlink" title="自身调用"></a>自身调用</h4><p>Promise可以通过不停地返回Promise对象从而实现链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then().then().then().....</div></pre></td></tr></table></figure><p>由于MyPromise内部是由一个变量来保存的回调函数，只能保存最新的then方法，要是想实现自身的链式调用，那么就需要将其修改为数组，把每一个then传入的回调函数保存起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: Array&lt;Function&gt; = [];</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc.push(call);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc.forEach((fun) =&gt; &#123;</div><div class="line">        fun &amp;&amp; fun(value);</div><div class="line">      &#125;);</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">....</div><div class="line">....</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="串行promise"><a href="#串行promise" class="headerlink" title="串行promise"></a>串行promise</h4><p>更加常见的需求是不同的Promise类型需要在同一个方法中链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 100);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">    console.log(&apos;11&apos; + data);</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;dddd&apos;);</div><div class="line">        &#125;, 100);  </div><div class="line">    &#125;);</div><div class="line">&#125;).then((data) =&gt; &#123;</div><div class="line">console.log(&apos;22&apos; + data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);  </div><div class="line"></div><div class="line">// 控制台输入的结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 并不是预期的</div><div class="line">// 11ssss</div><div class="line">// 22dddd</div></pre></td></tr></table></figure><p>那么如何让后续的then方法，返回的是最新初始化的promise呢？首先考虑的位置就是MyPromise中的then方法。因为返回了一个新的promise，而不是像之前的返回this，所以就没有办法处理新的promise里面的内容。那么就应该区分出来，then方法里是否返回了一个新的promise。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">// 返回了一个新的promise</div><div class="line">    &#125; else &#123;</div><div class="line">        // 正常处理</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在then方法中，首先让传入的回调方法执行，观察它的返回值是否是一个对象并且里面包含着then方法。如果有的话，该回调函数就返回了一个新的pormise。</p><p>上述的方法确实可以判断出来是否传入了新的promise，但是要明确的一点是，then方法中并不是回调函数执行的时候，回调函数是否执行是由thenCall控制。以上的逻辑判断，需要传入thenFunc数组中存储起来，在thenCall中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, value) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((data) =&gt; &#123;</div><div class="line">            call(data);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">        thenFunc.push((value) =&gt; &#123; handlePromise(call, value); &#125;);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">        call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;;</div><div class="line">`将handlePromise传入thenFunc数组中，当其执行的时候，会判断then传入回调函数的返回值。如果是一个promise对象，那么就执行该promise的then函数`</div><div class="line">// 控制台输出结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 11dddd</div></pre></td></tr></table></figure><p>控制台输出并不是预期的结果，但是好消息是出现第二个promise的数据。那么问题在哪里呢，为什么会输出三个结果？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 当第一个then执行的时候,执行到</div><div class="line">const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">// 因为调用了call(value);</div><div class="line">// 在控制台打印了11ssss</div><div class="line">// 之后判断出返回了一个promise对象，执行到</div><div class="line">ret.then((data) =&gt; &#123;</div><div class="line">    call(data);</div><div class="line">&#125;)</div><div class="line">// 这里会执行第二个promise的异步函数</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;dddd&apos;);</div><div class="line">&#125;, 100);  </div><div class="line">// 即在100ms后，回调dddd，注意这里面仍然是在第一个then中回调！</div><div class="line">// 执行到这里的时候控制台并没有输出11dddd，而是先输出了22ssss</div><div class="line">// 因为是一个100ms延迟的异步函数，在调用的时候会直接执行第二个then</div><div class="line">// 此时MyPromise中的value值仍然是ssss，所以会直接输出22ssss</div><div class="line">// 100ms后输出11dddd</div></pre></td></tr></table></figure><p>到了第二次then方法的时候，仍然是第一个值，原因就是return this。仍然返回了本身的promise，而不是第二个promise中的内容。那么可以考虑在then中每次都返回一个新的promise，用来接收新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, resolve: Function) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((value) =&gt; &#123;</div><div class="line">            resolve(value);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        resolve(ret);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        if (status === &apos;pending&apos;) &#123;</div><div class="line">            thenFunc.push(() =&gt; &#123; handlePromise(call, resolve); &#125;);</div><div class="line">        &#125; else if (status === &apos;fulfilled&apos;) </div><div class="line">            call(callValue);</div><div class="line">    &#125;    </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>由于在then中构建了一个新的promise，在每次then中都会调用resolve来改变MyPromise中value的值，确保在下一次的then中获取到新的值。</p><p>以上即可在promise中实现链式调用。</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race()"></a>promise.race()</h4><p>Promise的race方法其实是将几个promise一起执行，首先回调的promise会做为race方法的回调值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.race = (raceList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let count = 0;</div><div class="line">    for (let i = 0; i &lt; raceList.length; i++) &#123;</div><div class="line">      raceList[i].then((value) =&gt; &#123;</div><div class="line">        if (count === 0) &#123;</div><div class="line">          count++;</div><div class="line">          resolve(value);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h4><p>Promise的all方法是将几个promise一起执行，当每个promise返回成功的时候，才会将所有的结果组合成一个数组返回到结果中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.all = (allList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let dataList = [];</div><div class="line">    for (let i = 0; i &lt; allList.length; i++) &#123;</div><div class="line">      allList[i].then((value) =&gt; &#123;</div><div class="line">        dataList.push(value);</div><div class="line">        if (dataList.length == allList.length) &#123;</div><div class="line">          resolve(dataList);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是全部关于自己实现promise的内容，仅仅实现了promise的一部分内容。实现起来还是有一点吃力的，尤其是关于链式调用的实现，更加能理解关于函数编程的思想，总体来说实现的比较乱。网上其他大神都是用es5写的，和es6写法还是有一点出入的。使用es6实现还是比较简洁的，如果有任何问题请不吝赐教。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/yangzhou33/p/9992588.html" target="_blank" rel="external">实现简易promise</a></p></li><li><p><a href="https://www.cnblogs.com/huansky/p/6064402.html" target="_blank" rel="external">手把手教你实现一个完整的 Promise</a></p></li><li><p><a href="https://blog.csdn.net/yibingxiong1/article/details/68075416" target="_blank" rel="external">实现一个自己的promise</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/24/my-promise/promise2.jpg&quot; alt=&quot;promise2.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;const promise = new Promise((resolve, reject) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if(/* 一般是异步操作 */) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        resolve(&amp;apos;回调&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        reject(&amp;apos;error&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;promise.then((data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch((error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面尝试一下自己去实现Promise的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://mah93.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello Promise</title>
    <link href="https://mah93.github.io/2018/12/18/hello-promise/"/>
    <id>https://mah93.github.io/2018/12/18/hello-promise/</id>
    <published>2018-12-18T11:56:03.000Z</published>
    <updated>2018-12-25T04:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/18/hello-promise/promises-methods.png" alt="promises-methods.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>Promise</strong>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<strong>Promise</strong> 是一个对象，从它可以获取异步操作的消息。<strong>Promise</strong> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><strong>Promise</strong>有三种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p><p><strong>Promise</strong>对象初始化时状态为：<code>pending</code>（进行中）</p><p>调用resolve方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>fulfilled</code></p><p>调用rejected方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>rejected</code></p><blockquote><p>1、 <strong>Promise</strong>对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。</p><p>2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。<strong>Promise</strong>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</p></blockquote><a id="more"></a> <h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>简单的初始化一个<strong>Promise</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面初始化了一个<strong>Promise</strong>对象，并创建了一个异步操作：在两秒后调用resolve方法。这里仅仅是初始化了这个对象，并没有调用。继续调用这个promise对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>当执行代码的时候，控制台在两秒钟后打印出了“延迟2s回调”，也就是说在上面初始化<strong>Promise</strong>的resolve里面的参数回调到了下面then方法中的data参数中。简单来说就是then里面的函数，会传递到<strong>Promise</strong>中并由resolve来控制这个函数的执行时间以及执行所需要的参数并回调。</p><p>上述代码的执行过程就是<strong>Promise</strong>内部状态由<code>pending</code>变为<code>fulfilled</code>。</p><p><strong>Promise</strong>还有从<code>pending</code>变为<code>rejected</code>的过程。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        let number = getRandomNumber();</div><div class="line">        <span class="keyword">if</span>(number &gt; <span class="number">5</span>) &#123;</div><div class="line">            resolve(<span class="string">'大于5'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reject(<span class="string">'不大于5'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'then'</span>);</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'catch'</span>);</div><div class="line"><span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>在<strong>Promise</strong>中初始化了一个简单逻辑，两秒之后获得一个随机数字，该数字大于5的时候调用resolve方法，反之则调用reject方法。由上面的例子可以得知，当数字大于5的时候会在then中打印。那么当数字小于5的时候，则会在catch中打印改数字。</p><p><strong>简单总结下来，resolve方法回调至then中，reject方法回调至catch中。</strong></p><p>那么可以借用<strong>Promise</strong>的特点，简单的封装一个网络请求。使用<code>resolve</code>和<code>reject</code>分别包装正常返回和异常返回的值和信息。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">            fetch(url)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span> =&gt;</span> &#123;</div><div class="line">                    <span class="keyword">return</span> response.json();</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(responseData)</span> =&gt;</span> &#123;</div><div class="line">                    resolve(responseData);</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">catch</span>(function (error) &#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求返回的数据</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求报错</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>通过上面的例子<strong>Promise</strong>可以理解为是一个类似延迟加载的异步回调函数，那么其实也可以用普通的方法实现<strong>Promise</strong>的功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">myPromise</span> = <span class="params">(callback)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</div><div class="line">        callback(<span class="string">'随便什么数据'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">myPromise(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>它也会和<strong>Promise</strong>拥有同样的效果。那<strong>Promise</strong>到底能实现什么不可替代的功能呢？</p><p>假如有许多的异步操作需要执行，比如连续的三个请求，每一次请求都需要从前一个请求中获取参数，那么它的写法如下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetch(url1).<span class="keyword">then</span>(<span class="function"><span class="params">(data1)</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (data1 == <span class="number">200</span>) &#123;</div><div class="line">        fetch(url2).<span class="keyword">then</span>(<span class="function"><span class="params">(data2)</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span>(data2 == <span class="number">200</span>) &#123;</div><div class="line">                fetch(url3) ....</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>虽然可以实现需求，然是代码看起来并不那么友好，它庞大的层级结构使之无法轻易被修改。如果要是需要在第二个请求和第三个请求中再加入一些异步操作，那么将是不可修改的，这被称为回调地狱(Callback hell)。</p><p>使用<strong>Promise</strong>即可解决上述问题，<strong>Promise</strong>的优势在于，可以在then方法中继续写<strong>Promise</strong>对象并返回，然后继续调用then来进行回调操作。也就是说可以一直return一个<strong>Promise</strong>对象，可以一直在在后面调用then方法。如果使用<strong>Promise</strong>后上述的需求可以写为</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 分别将三个请求包装为函数</div><div class="line"><span class="function"><span class="title">request1</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url1);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request2</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request3</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url3);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 调用时</div><div class="line">request1().<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span>=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> request2();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> request3();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;).<span class="keyword">catch</span>();</div></pre></td></tr></table></figure><p>只需要在then中调用下一个<strong>Promise</strong>，上一个<strong>Promise</strong>中回调的数据即可传递下去。</p><blockquote><p>关于回调地狱(Callback hell)的问题也可以使用async/await解决，类似的代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> task() async &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    try&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String id = await request1();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String userInfo = await request2();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     await request3();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //执行接下来的操作   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125; catch(e)&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //错误处理   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(e);   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125;  </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p><strong>Promise.all</strong>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.all([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p><code>p</code>的状态由<code>promise1</code>、<code>promise2</code>、<code>promise3</code>决定，分成两种情况。</p><p>（1）只有<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>promise1</code>、<code>promise2</code>、<code>promise3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><blockquote><p>注意，如果作为参数的 promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p></blockquote><h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p><strong>Promise.race</strong>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.race([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p>上面代码中，只要有任何一个promise改变状态，那么p的状态也会跟着改变。也就是说最快改变状态的promise会让其他promise不会回调。</p><p>可以通过这个方法来完成一个请求超时功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([</div><div class="line">  fetch(url),</div><div class="line">  <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> Error(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">  &#125;)</div><div class="line">]);</div><div class="line"></div><div class="line">p</div><div class="line">.<span class="keyword">then</span>(<span class="built_in">console</span>.log)</div><div class="line">.<span class="keyword">catch</span>(<span class="built_in">console</span>.error);</div></pre></td></tr></table></figure><p>即当5s内请求没有返回结果，就返回请求超时。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">ES6标准入门（阮一峰）</a></p></li><li><p><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="external">大白话讲解Promise（一）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/18/hello-promise/promises-methods.png&quot; alt=&quot;promises-methods.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，&lt;strong&gt;Promise&lt;/strong&gt; 是一个对象，从它可以获取异步操作的消息。&lt;strong&gt;Promise&lt;/strong&gt; 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;有三种状态：&lt;code&gt;pending&lt;/code&gt;、&lt;code&gt;fulfilled&lt;/code&gt;、&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;对象初始化时状态为：&lt;code&gt;pending&lt;/code&gt;（进行中）&lt;/p&gt;
&lt;p&gt;调用resolve方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用rejected方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、 &lt;strong&gt;Promise&lt;/strong&gt;对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;strong&gt;Promise&lt;/strong&gt;对象的状态改变，只有两种可能：从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;和从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://mah93.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://mah93.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Masonry笔记</title>
    <link href="https://mah93.github.io/2018/12/07/masonry/"/>
    <id>https://mah93.github.io/2018/12/07/masonry/</id>
    <published>2018-12-07T09:21:26.000Z</published>
    <updated>2018-12-25T04:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。</p><p>Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂</p><p>Masonry属性与NSLayoutAttrubute的对照表如下</p><table><thead><tr><th>Masonry</th><th>NSLayoutAttrubute</th><th>说明</th></tr></thead><tbody><tr><td>left</td><td>NSLayoutAttrubuteLeft</td><td>左侧</td></tr><tr><td>top</td><td>NSLayoutAttrubuteTop</td><td>上侧</td></tr><tr><td>right</td><td>NSLayoutAttrubuteRight</td><td>右侧</td></tr><tr><td>bottom</td><td>NSLayoutAttrubuteBottom</td><td>下侧</td></tr><tr><td>leading</td><td>NSLayoutAttrubuteLeading</td><td>首部</td></tr><tr><td>trailing</td><td>NSLayoutAttrubuteTrailing</td><td>尾部</td></tr><tr><td>width</td><td>NSLayoutAttrubuteWidth</td><td>宽度</td></tr><tr><td>height</td><td>NSLayoutAttrubuteHeight</td><td>高度</td></tr><tr><td>centerX</td><td>NSLayoutAttrubuteCenterX</td><td>水平中心</td></tr><tr><td>centerY</td><td>NSLayoutAttrubuteCenterY</td><td>竖直中心</td></tr><tr><td>baseline</td><td>NSLayoutAttrubuteBaseline</td><td>文本基线</td></tr></tbody></table><a id="more"></a> <h3 id="NSLayoutAttrubute"><a href="#NSLayoutAttrubute" class="headerlink" title="NSLayoutAttrubute"></a>NSLayoutAttrubute</h3><p>下面是用NSLayoutAttrubute，约束一个子视图，使之每个边与其父视图间距为10</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="string">UIView</span> <span class="meta">*superview</span> <span class="string">=</span> <span class="string">self.view;</span></div><div class="line"></div><div class="line"><span class="string">UIView</span> <span class="meta">*view1</span> <span class="string">=</span> <span class="string">[[UIView</span> <span class="string">alloc]</span> <span class="string">init];</span></div><div class="line"><span class="string">view1.translatesAutoresizingMaskIntoConstraints</span> <span class="string">=</span> <span class="literal">NO</span><span class="string">;</span></div><div class="line"><span class="string">view1.backgroundColor</span> <span class="string">=</span> <span class="string">[UIColor</span> <span class="string">greenColor];</span></div><div class="line"><span class="string">[superview</span> <span class="attr">addSubview:view1];</span></div><div class="line"></div><div class="line"><span class="string">UIEdgeInsets</span> <span class="string">padding</span> <span class="string">=</span> <span class="string">UIEdgeInsetsMake(10,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">);</span></div><div class="line"></div><div class="line"><span class="string">[superview</span> <span class="attr">addConstraints:@[</span></div><div class="line"></div><div class="line">    <span class="string">//view1</span> <span class="string">constraints</span></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.top],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.left],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.bottom],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.right],</span></div><div class="line"></div><div class="line"> <span class="string">]];</span></div></pre></td></tr></table></figure><p>而使用了Masonry实现相同的约束，仅仅需要几行代码</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="name">view</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</div><div class="line">    make.edges.insets(<span class="name">UIEdgeInsetsMake</span>(<span class="name">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>))<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>Masonry支持CocoaPods，可以直接通过podfile文件进行集成，要在CocoaPods中添加下面代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod</span> <span class="string">'Masonry'</span></div><div class="line">pod install</div></pre></td></tr></table></figure><p>之后直接在项目中引用即可，详情请参考<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">github</a></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>首先是约束的相关api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">/*</div><div class="line">mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class="line">mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class="line">mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class="line">*/</div></pre></td></tr></table></figure><blockquote><p> 在使用Masonry的约束之前，首先要将view添加到superview上</p><p>之后调用mas_makeConstraints添加相应的约束</p></blockquote><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.centerX.equalTo(subView.mas_centerX); // 水平</div><div class="line">    make.centerY.equalTo(subView.mas_centerY); // 竖直</div><div class="line">    make.size.mas_equalTo(CGSizeMake(100, 100));</div><div class="line">&#125;];</div></pre></td></tr></table></figure><table><thead><tr><th>水平居中</th><th style="text-align:center"><img src="/2018/12/07/masonry/center_v.png" alt="center_v.png" title=""></th></tr></thead><tbody><tr><td><strong>竖直居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center_h.png" alt="center_h.png" title=""></td></tr><tr><td><strong>居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center.png" alt="center.png" title=""></td></tr></tbody></table><h3 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 添加一个与父视图上下左右都相距<span class="number">20</span>的view</div><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.insets(UIEdgeInsetsMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>));</div><div class="line"></div><div class="line">    /*  </div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">    */</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/insets.png" alt="insets.png" title=""><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图水平排列，之间的间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(subView.mas_left).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(view2.mas_left).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view2);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(view1.mas_right).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(subView.mas_right).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition.png" alt="apposition.png" title=""><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图竖直并列，之间间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(subView.mas_top).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(view2.mas_top).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view2);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(view1.mas_bottom).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(subView.mas_bottom).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_v.png" alt="apposition_v.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//  上层左右并列，并与下层对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view3.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view3.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.mas_equalTo(view1.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view1.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.height.equalTo(view1);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_2.png" alt="apposition_2.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  右侧上下并列，并与左侧对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerY.equalTo(subView.mas_centerY);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view2.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view3.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view3);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view2.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_3.png" alt="apposition_3.png" title=""><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上仅仅是最最基础的布局，在实际的生产过程中要复杂许多。但是Masonry的确简化了NSLayoutConstraint的写法，使之更加语义化。虽然写法更加的复杂，对于团队开发也是一种规范。写下本笔记主要是为了记载自己学习Masonry的过程，暂时不能投入生产中，也无法更加熟练深刻的运用，仅记之以供后日查阅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。&lt;/p&gt;
&lt;p&gt;Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂&lt;/p&gt;
&lt;p&gt;Masonry属性与NSLayoutAttrubute的对照表如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Masonry&lt;/th&gt;
&lt;th&gt;NSLayoutAttrubute&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;left&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeft&lt;/td&gt;
&lt;td&gt;左侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTop&lt;/td&gt;
&lt;td&gt;上侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;right&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteRight&lt;/td&gt;
&lt;td&gt;右侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bottom&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBottom&lt;/td&gt;
&lt;td&gt;下侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leading&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeading&lt;/td&gt;
&lt;td&gt;首部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTrailing&lt;/td&gt;
&lt;td&gt;尾部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteWidth&lt;/td&gt;
&lt;td&gt;宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteHeight&lt;/td&gt;
&lt;td&gt;高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerX&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterX&lt;/td&gt;
&lt;td&gt;水平中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerY&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterY&lt;/td&gt;
&lt;td&gt;竖直中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;baseline&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBaseline&lt;/td&gt;
&lt;td&gt;文本基线&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://mah93.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
