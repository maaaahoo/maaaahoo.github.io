<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mah93</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mah93.github.io/"/>
  <updated>2018-12-25T04:09:58.725Z</updated>
  <id>https://mah93.github.io/</id>
  
  <author>
    <name>mah93</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动手实现Promise</title>
    <link href="https://mah93.github.io/2018/12/24/my-promise/"/>
    <id>https://mah93.github.io/2018/12/24/my-promise/</id>
    <published>2018-12-24T08:08:35.000Z</published>
    <updated>2018-12-25T04:09:58.725Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/24/my-promise/promise2.jpg" alt="promise2.jpg" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">if(/* 一般是异步操作 */) &#123;</div><div class="line">        resolve(&apos;回调&apos;);</div><div class="line">&#125; else &#123;</div><div class="line">        reject(&apos;error&apos;);</div><div class="line">&#125; </div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((error) =&gt; &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面尝试一下自己去实现Promise的功能。</p><a id="more"></a> <h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 定一个构造函数</div><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    thenFunc = call;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    thenFunc &amp;&amp; thenFunc(value);</div><div class="line">    thenFunc = null;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>定义一个构造函数，将初始化的异步方法传入其中。在函数内部定一个变量来存储promise实例传递进来的then方法，当异步方法开始执行的时候就会在函数内部调用这个变量存储的函数，从将参数回调至promise实例中。</p><p>初始化的异步方法中，resolve参数其实是一个函数，对应到自定义的函数中就是thenCall方法，然后当resolve调用的时候，就是函数内部的用来存储then的变量执行的时候。</p><h4 id="初始化的方法不是异步的"><a href="#初始化的方法不是异步的" class="headerlink" title="初始化的方法不是异步的"></a>初始化的方法不是异步的</h4><p>如果在初始化的时候，传入的不是一个异步的函数，比如下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve) =&gt; &#123;</div><div class="line">resolve(&apos;ssss&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>由于执行顺序的问题，并不会回调到then方法中。可以想办法让then方法先执行，之后再执行resolve，利用Js的循环机制以及setTimeout，将resolve放入栈底执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">        thenFunc &amp;&amp; thenFunc(value);</div><div class="line">        thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>如果对于Js的循环机制和setTimeout不是很了解的话可以<a href="https://blog.csdn.net/u014346301/article/details/53897358" target="_blank" rel="external">参考这篇</a></p></blockquote><p> 这样就可以确保在有then的情况下，resolve在后面执行。</p><h4 id="promise调用时间很晚"><a href="#promise调用时间很晚" class="headerlink" title="promise调用时间很晚"></a>promise调用时间很晚</h4><p>如果初始化Promise实例之后，并没有立即使用它，而是间隔了一段时间再去调用promise的then方法，那么由于resolve已经执行完毕，所以即使是调用过了then方法也不会正确的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    promise.then((data) =&gt; &#123;</div><div class="line">    console.log(data);</div><div class="line">    &#125;).catch((err) =&gt; &#123;</div><div class="line">    console.log(&apos;error&apos; + err);</div><div class="line">    &#125;);  </div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>之前就已经介绍过了，Promise是有三种状态的：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。而且只能从<code>pending</code>转换为另外两种状态，而且是不可逆转的。可以借用Promise的这三种状态，让自己的Promise记住自己当前的状态。</p><p>添加一个记录Promise状态的变量，添加一个存储参数的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125;</div><div class="line">    call(callValue);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 在Promise初始化的时候，Promise的初始状态为<code>pending</code>，执行过thenCall方法后，改变自身状态为<code>fulfilled</code>，并且将传递的参数暂时保存到callValue中。过一段时间后，then执行的时候，由于状态已经改变，则会直接执行then中传递的回调函数，并将callValue作为回调参数。</p><h4 id="添加reject状态"><a href="#添加reject状态" class="headerlink" title="添加reject状态"></a>添加reject状态</h4><p>上述的方法都是只有resolve一个状态，其实reject与resolve相同，仅仅是执行了不同的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: ?Function = null;</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc = call;</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  this.catch = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      catchFunc = call;</div><div class="line">    &#125; else if (status === &apos;rejected&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      thenFunc &amp;&amp; thenFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const catchCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      catchFunc &amp;&amp; catchFunc(value);</div><div class="line">      callValue = value;</div><div class="line">      status = &apos;rejected&apos;;</div><div class="line">      catchFunc = null;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">        reject(&apos;ssss&apos;);</div><div class="line">&#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>关于return this，其实是将对象本身返回以供后续的catch或者其他操作，如果没有那么会报错说没有then方法或者没有catch方法。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><h4 id="自身调用"><a href="#自身调用" class="headerlink" title="自身调用"></a>自身调用</h4><p>Promise可以通过不停地返回Promise对象从而实现链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then().then().then().....</div></pre></td></tr></table></figure><p>由于MyPromise内部是由一个变量来保存的回调函数，只能保存最新的then方法，要是想实现自身的链式调用，那么就需要将其修改为数组，把每一个then传入的回调函数保存起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function MyPromise(callBack: Function) &#123;</div><div class="line">  let thenFunc: Array&lt;Function&gt; = [];</div><div class="line">  let catchFunc: ?Function = null;</div><div class="line">  let status: string = &apos;pending&apos;;</div><div class="line">  let callValue: any = null;</div><div class="line"></div><div class="line">  this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">      thenFunc.push(call);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">      call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const thenCall = (value) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;    </div><div class="line">      callValue = value;</div><div class="line">      status = &apos;fulfilled&apos;;</div><div class="line">      thenFunc.forEach((fun) =&gt; &#123;</div><div class="line">        fun &amp;&amp; fun(value);</div><div class="line">      &#125;);</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">....</div><div class="line">....</div><div class="line"></div><div class="line">  callBack(thenCall, catchCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="串行promise"><a href="#串行promise" class="headerlink" title="串行promise"></a>串行promise</h4><p>更加常见的需求是不同的Promise类型需要在同一个方法中链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;ssss&apos;);</div><div class="line">    &#125;, 100);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then((data) =&gt; &#123;</div><div class="line">    console.log(&apos;11&apos; + data);</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&apos;dddd&apos;);</div><div class="line">        &#125;, 100);  </div><div class="line">    &#125;);</div><div class="line">&#125;).then((data) =&gt; &#123;</div><div class="line">console.log(&apos;22&apos; + data);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">console.log(&apos;error&apos; + err);</div><div class="line">&#125;);  </div><div class="line"></div><div class="line">// 控制台输入的结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 并不是预期的</div><div class="line">// 11ssss</div><div class="line">// 22dddd</div></pre></td></tr></table></figure><p>那么如何让后续的then方法，返回的是最新初始化的promise呢？首先考虑的位置就是MyPromise中的then方法。因为返回了一个新的promise，而不是像之前的返回this，所以就没有办法处理新的promise里面的内容。那么就应该区分出来，then方法里是否返回了一个新的promise。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">// 返回了一个新的promise</div><div class="line">    &#125; else &#123;</div><div class="line">        // 正常处理</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在then方法中，首先让传入的回调方法执行，观察它的返回值是否是一个对象并且里面包含着then方法。如果有的话，该回调函数就返回了一个新的pormise。</p><p>上述的方法确实可以判断出来是否传入了新的promise，但是要明确的一点是，then方法中并不是回调函数执行的时候，回调函数是否执行是由thenCall控制。以上的逻辑判断，需要传入thenFunc数组中存储起来，在thenCall中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, value) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((data) =&gt; &#123;</div><div class="line">            call(data);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    if (status === &apos;pending&apos;) &#123;</div><div class="line">        thenFunc.push((value) =&gt; &#123; handlePromise(call, value); &#125;);</div><div class="line">    &#125; else if (status === &apos;fulfilled&apos;) &#123;</div><div class="line">        call(callValue);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;;</div><div class="line">`将handlePromise传入thenFunc数组中，当其执行的时候，会判断then传入回调函数的返回值。如果是一个promise对象，那么就执行该promise的then函数`</div><div class="line">// 控制台输出结果为</div><div class="line">// 11ssss</div><div class="line">// 22ssss</div><div class="line">// 11dddd</div></pre></td></tr></table></figure><p>控制台输出并不是预期的结果，但是好消息是出现第二个promise的数据。那么问题在哪里呢，为什么会输出三个结果？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 当第一个then执行的时候,执行到</div><div class="line">const ret = typeof call === &apos;function&apos; &amp;&amp; call(value);</div><div class="line">// 因为调用了call(value);</div><div class="line">// 在控制台打印了11ssss</div><div class="line">// 之后判断出返回了一个promise对象，执行到</div><div class="line">ret.then((data) =&gt; &#123;</div><div class="line">    call(data);</div><div class="line">&#125;)</div><div class="line">// 这里会执行第二个promise的异步函数</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    resolve(&apos;dddd&apos;);</div><div class="line">&#125;, 100);  </div><div class="line">// 即在100ms后，回调dddd，注意这里面仍然是在第一个then中回调！</div><div class="line">// 执行到这里的时候控制台并没有输出11dddd，而是先输出了22ssss</div><div class="line">// 因为是一个100ms延迟的异步函数，在调用的时候会直接执行第二个then</div><div class="line">// 此时MyPromise中的value值仍然是ssss，所以会直接输出22ssss</div><div class="line">// 100ms后输出11dddd</div></pre></td></tr></table></figure><p>到了第二次then方法的时候，仍然是第一个值，原因就是return this。仍然返回了本身的promise，而不是第二个promise中的内容。那么可以考虑在then中每次都返回一个新的promise，用来接收新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const handlePromise = (call: Function, resolve: Function) =&gt; &#123;</div><div class="line">    const ret = typeof call === &apos;function&apos; &amp;&amp; call(callValue);</div><div class="line">    if (ret &amp;&amp; ret.then &amp;&amp; typeof ret.then === &apos;function&apos;) &#123;</div><div class="line">        ret.then((value) =&gt; &#123;</div><div class="line">            resolve(value);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        resolve(ret);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.then = (call) =&gt; &#123;</div><div class="line">    return new MyPromise((resolve) =&gt; &#123;</div><div class="line">        if (status === &apos;pending&apos;) &#123;</div><div class="line">            thenFunc.push(() =&gt; &#123; handlePromise(call, resolve); &#125;);</div><div class="line">        &#125; else if (status === &apos;fulfilled&apos;) </div><div class="line">            call(callValue);</div><div class="line">    &#125;    </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>由于在then中构建了一个新的promise，在每次then中都会调用resolve来改变MyPromise中value的值，确保在下一次的then中获取到新的值。</p><p>以上即可在promise中实现链式调用。</p><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race()"></a>promise.race()</h4><p>Promise的race方法其实是将几个promise一起执行，首先回调的promise会做为race方法的回调值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.race = (raceList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let count = 0;</div><div class="line">    for (let i = 0; i &lt; raceList.length; i++) &#123;</div><div class="line">      raceList[i].then((value) =&gt; &#123;</div><div class="line">        if (count === 0) &#123;</div><div class="line">          count++;</div><div class="line">          resolve(value);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h4><p>Promise的all方法是将几个promise一起执行，当每个promise返回成功的时候，才会将所有的结果组合成一个数组返回到结果中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyPromise.all = (allList: Array&lt;MyPromise&gt;) =&gt; &#123;</div><div class="line">  return new MyPromise((resolve) =&gt; &#123;</div><div class="line">    let dataList = [];</div><div class="line">    for (let i = 0; i &lt; allList.length; i++) &#123;</div><div class="line">      allList[i].then((value) =&gt; &#123;</div><div class="line">        dataList.push(value);</div><div class="line">        if (dataList.length == allList.length) &#123;</div><div class="line">          resolve(dataList);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上是全部关于自己实现promise的内容，仅仅实现了promise的一部分内容。实现起来还是有一点吃力的，尤其是关于链式调用的实现，更加能理解关于函数编程的思想，总体来说实现的比较乱。网上其他大神都是用es5写的，和es6写法还是有一点出入的。使用es6实现还是比较简洁的，如果有任何问题请不吝赐教。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/yangzhou33/p/9992588.html" target="_blank" rel="external">实现简易promise</a></p></li><li><p><a href="https://www.cnblogs.com/huansky/p/6064402.html" target="_blank" rel="external">手把手教你实现一个完整的 Promise</a></p></li><li><p><a href="https://blog.csdn.net/yibingxiong1/article/details/68075416" target="_blank" rel="external">实现一个自己的promise</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/24/my-promise/promise2.jpg&quot; alt=&quot;promise2.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前已经学习过了Promise的相关知识，Promise其实就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一般的Promise长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;const promise = new Promise((resolve, reject) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if(/* 一般是异步操作 */) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        resolve(&amp;apos;回调&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        reject(&amp;apos;error&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;promise.then((data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch((error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面尝试一下自己去实现Promise的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://mah93.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Hello Promise</title>
    <link href="https://mah93.github.io/2018/12/18/hello-promise/"/>
    <id>https://mah93.github.io/2018/12/18/hello-promise/</id>
    <published>2018-12-18T11:56:03.000Z</published>
    <updated>2018-12-25T04:09:42.705Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/18/hello-promise/promises-methods.png" alt="promises-methods.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>Promise</strong>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<strong>Promise</strong> 是一个对象，从它可以获取异步操作的消息。<strong>Promise</strong> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><strong>Promise</strong>有三种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p><p><strong>Promise</strong>对象初始化时状态为：<code>pending</code>（进行中）</p><p>调用resolve方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>fulfilled</code></p><p>调用rejected方法时，<strong>Promise</strong>的状态由<code>pending</code>变为<code>rejected</code></p><blockquote><p>1、 <strong>Promise</strong>对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。</p><p>2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。<strong>Promise</strong>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</p></blockquote><a id="more"></a> <h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>简单的初始化一个<strong>Promise</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面初始化了一个<strong>Promise</strong>对象，并创建了一个异步操作：在两秒后调用resolve方法。这里仅仅是初始化了这个对象，并没有调用。继续调用这个promise对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'延迟2s回调'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>当执行代码的时候，控制台在两秒钟后打印出了“延迟2s回调”，也就是说在上面初始化<strong>Promise</strong>的resolve里面的参数回调到了下面then方法中的data参数中。简单来说就是then里面的函数，会传递到<strong>Promise</strong>中并由resolve来控制这个函数的执行时间以及执行所需要的参数并回调。</p><p>上述代码的执行过程就是<strong>Promise</strong>内部状态由<code>pending</code>变为<code>fulfilled</code>。</p><p><strong>Promise</strong>还有从<code>pending</code>变为<code>rejected</code>的过程。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        let number = getRandomNumber();</div><div class="line">        <span class="keyword">if</span>(number &gt; <span class="number">5</span>) &#123;</div><div class="line">            resolve(<span class="string">'大于5'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reject(<span class="string">'不大于5'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'then'</span>);</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'catch'</span>);</div><div class="line"><span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>在<strong>Promise</strong>中初始化了一个简单逻辑，两秒之后获得一个随机数字，该数字大于5的时候调用resolve方法，反之则调用reject方法。由上面的例子可以得知，当数字大于5的时候会在then中打印。那么当数字小于5的时候，则会在catch中打印改数字。</p><p><strong>简单总结下来，resolve方法回调至then中，reject方法回调至catch中。</strong></p><p>那么可以借用<strong>Promise</strong>的特点，简单的封装一个网络请求。使用<code>resolve</code>和<code>reject</code>分别包装正常返回和异常返回的值和信息。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">            fetch(url)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span> =&gt;</span> &#123;</div><div class="line">                    <span class="keyword">return</span> response.json();</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">then</span>(<span class="function"><span class="params">(responseData)</span> =&gt;</span> &#123;</div><div class="line">                    resolve(responseData);</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">catch</span>(function (error) &#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求返回的数据</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> 请求报错</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>通过上面的例子<strong>Promise</strong>可以理解为是一个类似延迟加载的异步回调函数，那么其实也可以用普通的方法实现<strong>Promise</strong>的功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">myPromise</span> = <span class="params">(callback)</span> =&gt;</span> &#123;</div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</div><div class="line">        callback(<span class="string">'随便什么数据'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">myPromise(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>它也会和<strong>Promise</strong>拥有同样的效果。那<strong>Promise</strong>到底能实现什么不可替代的功能呢？</p><p>假如有许多的异步操作需要执行，比如连续的三个请求，每一次请求都需要从前一个请求中获取参数，那么它的写法如下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetch(url1).<span class="keyword">then</span>(<span class="function"><span class="params">(data1)</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (data1 == <span class="number">200</span>) &#123;</div><div class="line">        fetch(url2).<span class="keyword">then</span>(<span class="function"><span class="params">(data2)</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span>(data2 == <span class="number">200</span>) &#123;</div><div class="line">                fetch(url3) ....</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>虽然可以实现需求，然是代码看起来并不那么友好，它庞大的层级结构使之无法轻易被修改。如果要是需要在第二个请求和第三个请求中再加入一些异步操作，那么将是不可修改的，这被称为回调地狱(Callback hell)。</p><p>使用<strong>Promise</strong>即可解决上述问题，<strong>Promise</strong>的优势在于，可以在then方法中继续写<strong>Promise</strong>对象并返回，然后继续调用then来进行回调操作。也就是说可以一直return一个<strong>Promise</strong>对象，可以一直在在后面调用then方法。如果使用<strong>Promise</strong>后上述的需求可以写为</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 分别将三个请求包装为函数</div><div class="line"><span class="function"><span class="title">request1</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url1);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request2</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">request3</span> = <span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(url3);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 调用时</div><div class="line">request1().<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span>=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> request2();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> request3();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;).<span class="keyword">catch</span>();</div></pre></td></tr></table></figure><p>只需要在then中调用下一个<strong>Promise</strong>，上一个<strong>Promise</strong>中回调的数据即可传递下去。</p><blockquote><p>关于回调地狱(Callback hell)的问题也可以使用async/await解决，类似的代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> task() async &#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    try&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String id = await request1();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     String userInfo = await request2();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     await request3();</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //执行接下来的操作   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125; catch(e)&#123;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     //错误处理   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(e);   </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">    &#125;  </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p><strong>Promise.all</strong>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.all([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p><code>p</code>的状态由<code>promise1</code>、<code>promise2</code>、<code>promise3</code>决定，分成两种情况。</p><p>（1）只有<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>promise1</code>、<code>promise2</code>、<code>promise3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>promise1</code>、<code>promise2</code>、<code>promise3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><blockquote><p>注意，如果作为参数的 promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p></blockquote><h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p><strong>Promise.race</strong>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const p</span> = Promise.race([promise1, promise2, promise3]);</div></pre></td></tr></table></figure><p>上面代码中，只要有任何一个promise改变状态，那么p的状态也会跟着改变。也就是说最快改变状态的promise会让其他promise不会回调。</p><p>可以通过这个方法来完成一个请求超时功能</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([</div><div class="line">  fetch(url),</div><div class="line">  <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> Error(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">  &#125;)</div><div class="line">]);</div><div class="line"></div><div class="line">p</div><div class="line">.<span class="keyword">then</span>(<span class="built_in">console</span>.log)</div><div class="line">.<span class="keyword">catch</span>(<span class="built_in">console</span>.error);</div></pre></td></tr></table></figure><p>即当5s内请求没有返回结果，就返回请求超时。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">ES6标准入门（阮一峰）</a></p></li><li><p><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="external">大白话讲解Promise（一）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/18/hello-promise/promises-methods.png&quot; alt=&quot;promises-methods.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，&lt;strong&gt;Promise&lt;/strong&gt; 是一个对象，从它可以获取异步操作的消息。&lt;strong&gt;Promise&lt;/strong&gt; 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;有三种状态：&lt;code&gt;pending&lt;/code&gt;、&lt;code&gt;fulfilled&lt;/code&gt;、&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;对象初始化时状态为：&lt;code&gt;pending&lt;/code&gt;（进行中）&lt;/p&gt;
&lt;p&gt;调用resolve方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用rejected方法时，&lt;strong&gt;Promise&lt;/strong&gt;的状态由&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、 &lt;strong&gt;Promise&lt;/strong&gt;对象的状态不受外界影响，只有异步操作的结果可以决定当前时哪一种状态，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;2、 一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;strong&gt;Promise&lt;/strong&gt;对象的状态改变，只有两种可能：从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;和从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://mah93.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Masonry笔记</title>
    <link href="https://mah93.github.io/2018/12/07/masonry/"/>
    <id>https://mah93.github.io/2018/12/07/masonry/</id>
    <published>2018-12-07T09:21:26.000Z</published>
    <updated>2018-12-07T09:36:46.490Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。</p><p>Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂</p><p>Masonry属性与NSLayoutAttrubute的对照表如下</p><table><thead><tr><th>Masonry</th><th>NSLayoutAttrubute</th><th>说明</th></tr></thead><tbody><tr><td>left</td><td>NSLayoutAttrubuteLeft</td><td>左侧</td></tr><tr><td>top</td><td>NSLayoutAttrubuteTop</td><td>上侧</td></tr><tr><td>right</td><td>NSLayoutAttrubuteRight</td><td>右侧</td></tr><tr><td>bottom</td><td>NSLayoutAttrubuteBottom</td><td>下侧</td></tr><tr><td>leading</td><td>NSLayoutAttrubuteLeading</td><td>首部</td></tr><tr><td>trailing</td><td>NSLayoutAttrubuteTrailing</td><td>尾部</td></tr><tr><td>width</td><td>NSLayoutAttrubuteWidth</td><td>宽度</td></tr><tr><td>height</td><td>NSLayoutAttrubuteHeight</td><td>高度</td></tr><tr><td>centerX</td><td>NSLayoutAttrubuteCenterX</td><td>水平中心</td></tr><tr><td>centerY</td><td>NSLayoutAttrubuteCenterY</td><td>竖直中心</td></tr><tr><td>baseline</td><td>NSLayoutAttrubuteBaseline</td><td>文本基线</td></tr></tbody></table><a id="more"></a> <h3 id="NSLayoutAttrubute"><a href="#NSLayoutAttrubute" class="headerlink" title="NSLayoutAttrubute"></a>NSLayoutAttrubute</h3><p>下面是用NSLayoutAttrubute，约束一个子视图，使之每个边与其父视图间距为10</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="string">UIView</span> <span class="meta">*superview</span> <span class="string">=</span> <span class="string">self.view;</span></div><div class="line"></div><div class="line"><span class="string">UIView</span> <span class="meta">*view1</span> <span class="string">=</span> <span class="string">[[UIView</span> <span class="string">alloc]</span> <span class="string">init];</span></div><div class="line"><span class="string">view1.translatesAutoresizingMaskIntoConstraints</span> <span class="string">=</span> <span class="literal">NO</span><span class="string">;</span></div><div class="line"><span class="string">view1.backgroundColor</span> <span class="string">=</span> <span class="string">[UIColor</span> <span class="string">greenColor];</span></div><div class="line"><span class="string">[superview</span> <span class="attr">addSubview:view1];</span></div><div class="line"></div><div class="line"><span class="string">UIEdgeInsets</span> <span class="string">padding</span> <span class="string">=</span> <span class="string">UIEdgeInsetsMake(10,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">,</span> <span class="number">10</span><span class="string">);</span></div><div class="line"></div><div class="line"><span class="string">[superview</span> <span class="attr">addConstraints:@[</span></div><div class="line"></div><div class="line">    <span class="string">//view1</span> <span class="string">constraints</span></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeTop</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.top],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeLeft</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="string">padding.left],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeBottom</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1.0</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.bottom],</span></div><div class="line"></div><div class="line">    <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:view1</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                 relatedBy:</span><span class="string">NSLayoutRelationEqual</span></div><div class="line"><span class="attr">                                    toItem:</span><span class="string">superview</span></div><div class="line"><span class="attr">                                 attribute:</span><span class="string">NSLayoutAttributeRight</span></div><div class="line"><span class="attr">                                multiplier:</span><span class="number">1</span></div><div class="line"><span class="attr">                                  constant:</span><span class="bullet">-padding.right],</span></div><div class="line"></div><div class="line"> <span class="string">]];</span></div></pre></td></tr></table></figure><p>而使用了Masonry实现相同的约束，仅仅需要几行代码</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="name">view</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</div><div class="line">    make.edges.insets(<span class="name">UIEdgeInsetsMake</span>(<span class="name">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>))<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>Masonry支持CocoaPods，可以直接通过podfile文件进行集成，要在CocoaPods中添加下面代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod</span> <span class="string">'Masonry'</span></div><div class="line">pod install</div></pre></td></tr></table></figure><p>之后直接在项目中引用即可，详情请参考<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">github</a></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>首先是约束的相关api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;</div><div class="line">/*</div><div class="line">mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class="line">mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class="line">mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class="line">*/</div></pre></td></tr></table></figure><blockquote><p> 在使用Masonry的约束之前，首先要将view添加到superview上</p><p>之后调用mas_makeConstraints添加相应的约束</p></blockquote><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.centerX.equalTo(subView.mas_centerX); // 水平</div><div class="line">    make.centerY.equalTo(subView.mas_centerY); // 竖直</div><div class="line">    make.size.mas_equalTo(CGSizeMake(100, 100));</div><div class="line">&#125;];</div></pre></td></tr></table></figure><table><thead><tr><th>水平居中</th><th style="text-align:center"><img src="/2018/12/07/masonry/center_v.png" alt="center_v.png" title=""></th></tr></thead><tbody><tr><td><strong>竖直居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center_h.png" alt="center_h.png" title=""></td></tr><tr><td><strong>居中</strong></td><td style="text-align:center"><img src="/2018/12/07/masonry/center.png" alt="center.png" title=""></td></tr></tbody></table><h3 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 添加一个与父视图上下左右都相距<span class="number">20</span>的view</div><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.insets(UIEdgeInsetsMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>));</div><div class="line"></div><div class="line">    /*  </div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">    */</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/insets.png" alt="insets.png" title=""><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图水平排列，之间的间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(subView.mas_left).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(view2.mas_left).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view2);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerY.equalTo(subView.mas_centerY);</div><div class="line">    <span class="built_in">make</span>.left.equalTo(view1.mas_right).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.right.equalTo(subView.mas_right).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.height.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.width.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition.png" alt="apposition.png" title=""><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个子视图竖直并列，之间间距为20</span></div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(subView.mas_top).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(view2.mas_top).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view2);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</div><div class="line">    <span class="built_in">make</span>.centerX.equalTo(subView.mas_centerX);</div><div class="line">    <span class="built_in">make</span>.top.equalTo(view1.mas_bottom).with.offset(<span class="number">20</span>);</div><div class="line">    <span class="built_in">make</span>.bottom.equalTo(subView.mas_bottom).with.offset(<span class="number">-20</span>);</div><div class="line">    <span class="built_in">make</span>.width.mas_equalTo(@<span class="number">150</span>);</div><div class="line">    <span class="built_in">make</span>.height.equalTo(view1);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_v.png" alt="apposition_v.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//  上层左右并列，并与下层对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view3.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view3.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view2.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.mas_equalTo(view1.mas_width);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(subView.mas_centerX);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view1.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.height.equalTo(view1);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_2.png" alt="apposition_2.png" title=""><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  右侧上下并列，并与左侧对其</div><div class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerY.equalTo(subView.mas_centerY);</div><div class="line">        make.<span class="built_in">left</span>.equalTo(subView.mas_left).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(view2.mas_left).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view2);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(subView.mas_top).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(view3.mas_top).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view3);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [view3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.<span class="built_in">left</span>.equalTo(view1.mas_right).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">right</span>.equalTo(subView.mas_right).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.<span class="built_in">top</span>.equalTo(view2.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">20</span>);</div><div class="line">        make.<span class="built_in">bottom</span>.equalTo(subView.mas_bottom).<span class="built_in">with</span>.offset(<span class="number">-20</span>);</div><div class="line">        make.width.equalTo(view1);</div><div class="line">        make.height.equalTo(view2);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><img src="/2018/12/07/masonry/apposition_3.png" alt="apposition_3.png" title=""><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上仅仅是最最基础的布局，在实际的生产过程中要复杂许多。但是Masonry的确简化了NSLayoutConstraint的写法，使之更加语义化。虽然写法更加的复杂，对于团队开发也是一种规范。写下本笔记主要是为了记载自己学习Masonry的过程，暂时不能投入生产中，也无法更加熟练深刻的运用，仅记之以供后日查阅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。&lt;/p&gt;
&lt;p&gt;Masonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。系统AutoLayout支持的操作，Masonry都支持，相比系统API功能来说，Masonry是有过之而无不及。也就是说Masonry就是NSLayoutConstraint，只不过是提供了更加简单的书写方法。如果你对NSLayoutConstraint有所了解，那么Masonry可以说是简单易懂&lt;/p&gt;
&lt;p&gt;Masonry属性与NSLayoutAttrubute的对照表如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Masonry&lt;/th&gt;
&lt;th&gt;NSLayoutAttrubute&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;left&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeft&lt;/td&gt;
&lt;td&gt;左侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTop&lt;/td&gt;
&lt;td&gt;上侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;right&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteRight&lt;/td&gt;
&lt;td&gt;右侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bottom&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBottom&lt;/td&gt;
&lt;td&gt;下侧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leading&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteLeading&lt;/td&gt;
&lt;td&gt;首部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteTrailing&lt;/td&gt;
&lt;td&gt;尾部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteWidth&lt;/td&gt;
&lt;td&gt;宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteHeight&lt;/td&gt;
&lt;td&gt;高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerX&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterX&lt;/td&gt;
&lt;td&gt;水平中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;centerY&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteCenterY&lt;/td&gt;
&lt;td&gt;竖直中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;baseline&lt;/td&gt;
&lt;td&gt;NSLayoutAttrubuteBaseline&lt;/td&gt;
&lt;td&gt;文本基线&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://mah93.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Charles学习</title>
    <link href="https://mah93.github.io/2018/06/28/charles-learn/"/>
    <id>https://mah93.github.io/2018/06/28/charles-learn/</id>
    <published>2018-06-28T04:14:48.000Z</published>
    <updated>2018-06-28T04:21:39.855Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/06/28/charles-learn/charles-logo.png" alt="charles-logo.png" title=""><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器.它允许一个开发者查看所有连接互联网的HTTP通信.这些包括request,response现HTTP headers (包含cookies与caching信息).</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。可以在<a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles官网</a>下载（该软件为付费软件，试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时）</p><a id="more"></a> <h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><p>在安装的过程中，Charles会请求系统代理的权限。如果在安装的过程中，没有设置或者跳过，可以在主页面中重新设置代理权限。</p><img src="/2018/06/28/charles-learn/charles-setting.png" alt="charles-setting.png" title=""><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>Charles的主界面如下图所示，左半边是发出去的请求URL以及URL过滤器，右半边是请求的相关信息，头部是相应的请求工具，如断点、重发等等</p><img src="/2018/06/28/charles-learn/charles-main.png" alt="charles-main.png" title=""><h3 id="截取模拟器的请求"><a href="#截取模拟器的请求" class="headerlink" title="截取模拟器的请求"></a>截取模拟器的请求</h3><p>在Proxy 菜单，选中Proxy Settings ,打开对话框，设置端口号（默认是8888，也可以自定义），并选中 Enable transparent Http proxying 选项，如下图所示：</p><img src="/2018/06/28/charles-learn/charles-proxy.png" alt="charles-proxy.png" title=""><p>当在iOS模拟器做HTTP请求时，左边会相应出现请求的URL。</p><h3 id="抓取HTTPS报文"><a href="#抓取HTTPS报文" class="headerlink" title="抓取HTTPS报文"></a>抓取HTTPS报文</h3><p>Charles不仅能够抓取http协议的包，也能抓取https协议的包，但是由于https是经过加密的，因为抓取的包中的内容是以密文方式展现的，通过配置Charles的SSL可以方便的以明文查看https协议传输的内容</p><ul><li><h4 id="电脑上配置证书"><a href="#电脑上配置证书" class="headerlink" title="电脑上配置证书"></a>电脑上配置证书</h4></li></ul><p>选中Charles，在“Help”菜单中选择—&gt;“SSL Proxying”—&gt;“Install Charles Root Certificate”，会自动打开钥匙串访问。<br><img src="/2018/06/28/charles-learn/charles-cer.png" alt="charles-cer.png" title=""></p><p>但是默认是不被信任的状态，右键该证书，选择显示简介，将证书设置为完全信任状态。</p><img src="/2018/06/28/charles-learn/charles-confi.png" alt="charles-confi.png" title=""><ul><li><h4 id="移动设备上配置证书"><a href="#移动设备上配置证书" class="headerlink" title="移动设备上配置证书"></a>移动设备上配置证书</h4></li></ul><p>一般情况下我们会使用安卓或者苹果设备进行抓包，无论是哪种设备，下述流程大体一致：</p><ol><li>将移动设备与开启Charles的电脑设备设置在同一Wi-Fi下，并且将移动设备的HTTP代理改成电脑的IP。</li></ol><p>以苹果设备为例：打开设置—&gt;无线局域网—&gt;选择网络—&gt;点击网络名称旁边的感叹号—&gt;将配置HTTP代理设置为手动模式—&gt;输入电脑IP，端口号为8888</p><img src="/2018/06/28/charles-learn/charles-iphone-setting.jpg" alt="charles-iphone-setting.jpg" title=""><ol><li>打开移动设备的浏览器，访问<strong>chls.pro/ssl</strong>会提示下载一个描述文件，下载安装即可。</li><li>打开移动设备，将该证书设置为信任状态。</li></ol><p>以苹果设备为例：打开设置—&gt;通用—&gt;关于本机—&gt;证书信任设置—&gt;将证书设置为信任状态。</p><ul><li><h4 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h4></li></ul><p>选中Charles，在“Proxy”菜单中选择—&gt;“SSL Proxying Settings ”，在弹出的页面中勾选Enable SSL Proxying。并在下方添加需要抓取的URL，端口号为443<br><img src="/2018/06/28/charles-learn/charles-ssl.png" alt="charles-ssl.png" title=""></p><p>之后在移动端操作，即可看到相应的请求信息。</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><h4 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h4></li></ul><p>Charles可以对某一接口进行重发，以尝试重放交易服务器响应。</p><p>右键单击URL选择<strong>Repeat</strong>，Charles会自动将该URL以及URL包含的内容原封不动的再次提交至服务器。</p><p>右键单击URL选择<strong>Repeat Advanced</strong>，在弹出框中设置重复次数、并发数以及延时等。对服务器进行简单的性能测试。</p><img src="/2018/06/28/charles-learn/charles-repeat.png" alt="charles-repeat.png" title=""><ul><li><h4 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h4></li></ul><p>Charles可以在请求发出前，或者是请求返回至设备前将请求拦截并篡改。</p><p>右键单击URL选择<strong>Breakpoints</strong>，然后在该请求再次发起的时候，会被拦截下来。选择<strong>Edit Request</strong>可以进行修改请求信息，修改完成后点击<strong>Execute</strong>该请求会继续发出。</p><ul><li><h4 id="模拟慢速网络"><a href="#模拟慢速网络" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h4></li></ul><p>有时候开发中需要测试用户在网络情况比较的差的时候应用的表现情况，可以使用Charles限流设置，”Proxy” -&gt; “Thorttle Settings” 中设置如下：</p><img src="/2018/06/28/charles-learn/charles-lowNet.png" alt="charles-lowNet.png" title="">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/06/28/charles-learn/charles-logo.png&quot; alt=&quot;charles-logo.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器.它允许一个开发者查看所有连接互联网的HTTP通信.这些包括request,response现HTTP headers (包含cookies与caching信息).&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。可以在&lt;a href=&quot;http://www.charlesproxy.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Charles官网&lt;/a&gt;下载（该软件为付费软件，试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React-Native代码规范</title>
    <link href="https://mah93.github.io/2018/05/07/code-standard/"/>
    <id>https://mah93.github.io/2018/05/07/code-standard/</id>
    <published>2018-05-07T04:22:40.000Z</published>
    <updated>2018-05-07T04:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/07/code-standard/code-standard.jpg" alt="code-standard.jpg" title=""><blockquote><p>代码规范只是让代码更容易被理解，让多人开发时代码也能保持内部一致性。</p><p>制定代码规范的标准因团队而异，可以根据多数人的开发习惯或者是参考别人的规范</p><p>实现代码规范的方法有很多种，在React-Native中可以使用ESLint配合编译器进行代码规范审核</p><p>不必矫枉过正</p></blockquote><a id="more"></a> <h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><h4 id="变量规范"><a href="#变量规范" class="headerlink" title="变量规范"></a>变量规范</h4><ul><li>代码中变量的命名均不能以下划线或符号开始，也不能以下划线或符号为结束</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">错误：_<span class="built_in">title</span> / $<span class="built_in">title</span> / title_ / <span class="built_in">title</span>$</div></pre></td></tr></table></figure><ul><li>变量命名采用lowerCamelCase驼峰命名的方式，第一个字母必须小写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：myName / birthDay</div></pre></td></tr></table></figure><ul><li>命名严禁使用拼音或者是拼音与英文混合的方式，正确的英文拼写和语法可以让阅读者易于理解，避免歧义</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：shengchan / fenshu / <span class="keyword">bigshan</span></div><div class="line"><span class="keyword">正确：production </span>／ grade ／ <span class="keyword">bigMountain</span></div></pre></td></tr></table></figure><ul><li>常用的单词，在不引起歧义的情况下可以缩写</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：<span class="keyword">user</span>Msg 等价于 <span class="keyword">user</span>Messaage</div></pre></td></tr></table></figure><ul><li>数组或者对象变量，需明确指出其类型</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确： studentList / <span class="keyword">user</span>Object</div></pre></td></tr></table></figure><ul><li>常量的命名全部采用大写，单词与单词之间采用下划线进行分割。力求保证见文知意，不要害怕变量过长</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：<span class="keyword">MaxValue</span> / <span class="keyword">MAXVALUE</span></div><div class="line">正确：MAX_STUDENT_GRADE</div></pre></td></tr></table></figure><ul><li>对所有的变量，对象的引用，请使用const</li></ul><h4 id="函数规范"><a href="#函数规范" class="headerlink" title="函数规范"></a>函数规范</h4><ul><li>方法、函数一律使用ES6中箭头函数的声明方式</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">     test() &#123;&#125;</div><div class="line">正确：test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure><ul><li>方法名、函数名一律采用lowerCamelCase驼峰命名的方式，第一个字母必须小写</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：getAllUserInformation = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure><ul><li>类名使用UpperCamelCase驼峰命名的方式，第一个字母必须大写</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：<span class="builtin-name">export</span><span class="built_in"> default </span>class StringUtil &#123;&#125;</div></pre></td></tr></table></figure><h4 id="组件规范"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范</h4><ul><li>JSX中的方法，超过一行必须写成一个新的函数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正确：<span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">onPress</span>=<span class="string">&#123;this.doSomething&#125;</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>组件嵌套时，子组件与父组件要有2个空格的缩进</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;Father&gt;</span></div><div class="line">  <span class="section">&lt;Children /&gt;</span></div><div class="line"><span class="section">&lt;/Father&gt;</span></div></pre></td></tr></table></figure><ul><li>组件需要设置样式的时候，如果只有一个样式可以用内联的方式写在JSX内，如果两个以上必须使用StyleSheet创建样式</li><li>当一个组件有多个属性需要配置的时候，务必多行书写</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">TouchableOpacity</span></span></span></div><div class="line"><span class="xml">  onPress=</span><span class="template-variable">&#123;() =&gt; &#123;&#125;</span><span class="xml">&#125;</span></div><div class="line"><span class="xml">  style=</span><span class="template-variable">&#123;&#125;</span><span class="xml"></span></div><div class="line"><span class="xml">&gt;</span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></div></pre></td></tr></table></figure><ul><li>自定义组件命名的时候，用UpperCamelCase命名。</li><li>自定义组件，要详细写出属性列表，并解释每个属性的意思。为每个属性初始化一个默认值</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="module-access"><span class="module"><span class="identifier">FlexButton</span>.</span></span>propTypes = &#123;</div><div class="line">  press: <span class="module-access"><span class="module"><span class="identifier">PropTypes</span>.</span></span>func,</div><div class="line">  top: <span class="module-access"><span class="module"><span class="identifier">PropTypes</span>.</span></span>number.isRequired,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="module-access"><span class="module"><span class="identifier">FlexButton</span>.</span></span>defaultProps = &#123;</div><div class="line">  press:<span class="function"> <span class="params">()</span> =&gt;</span> &#123;&#125;,</div><div class="line">  top: <span class="number">0</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>无状态的组件，即不涉及组件内部数据、UI变化的组件。请继承自PureComponent而不是Component</li></ul><h4 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h4><ul><li>关键字左右需加空格，如if/for/else等关键字</li></ul><ul><li>任何运算符左右必须都有一个空格，包括赋值、逻辑运算符、加减乘除等</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">错误：grade=<span class="number">20</span></div><div class="line">正确：grade = <span class="number">20</span></div></pre></td></tr></table></figure><ul><li>大括号使用约定。如果大括号内为空，则写成{}即可，不需要换行。如果是非空代码块则左边括号空一格，右边闭括号需要换行，与方法名对其</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">例如：const getTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li>单行字符数不超过120个（可在eslint中设置）超过的字符需要换行。单页代码不超过300行，超过的需要重构代码。</li><li>方法参数在传入的时候，多个参数逗号前必须加括号</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">onMsgCallBack</span> = <span class="params">(msg, title, name)</span> =&gt;</span> &#123;</div><div class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>合理使用空格，将不同功能或者是不同业务逻辑的方法分开。</li></ul><h4 id="条件语句规范"><a href="#条件语句规范" class="headerlink" title="条件语句规范"></a>条件语句规范</h4><ul><li>简单的if/else逻辑判断，请使用三目运算符。逻辑判断请勿超过三层，如果超过了请重新思考代码逻辑。或者使用switch</li><li>在一个 switch 块内，每个case要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止;在一个 switch 块内，都必须包含一个default 语句并且 放在最后，即使它什么代码也没有。</li></ul><h4 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h4><ul><li>变量或者是属性，可以在后面使用单行注释来说明这个变量或者属性的用途</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> userName = <span class="string">'Jace'</span>; <span class="comment">// 用户姓名</span></div></pre></td></tr></table></figure><ul><li>类、类方法的注释不得使用//单行注释，必须使用/**/的多行注释。方法中如果需要传入参数，或者是有返回值。请在注释中详细写出。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 获取所有信息</span></div><div class="line"><span class="comment"> * param: name 获取信息人姓名</span></div><div class="line"><span class="comment"> * param: number 获取信息人编号</span></div><div class="line"><span class="comment"> * return: msg 返回用户信息</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> fetchAllMsg = <span class="function">(<span class="params">name, <span class="built_in">number</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// doFetch</span></div><div class="line">    <span class="keyword">return</span> msg</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>逻辑代码中需要注释出逻辑流程</li><li>注释掉的代码，如果不再使用请尽快删除，以免给后续维护人员带来麻烦。如果只是暂时注释，请说明注释原因</li></ul><h3 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h3><ul><li>确定好项目的文件目录结构，要求文件层次清晰，功能划分明确</li></ul><ul><li>文件命名遵循lowerCamelCase方式命名。如果是某一个平台特有的文件，可以加上ios或者android的后缀作为区分</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：index<span class="selector-class">.ios</span><span class="selector-class">.js</span> / index<span class="selector-class">.android</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure><ul><li>文件开头需写明该文件作用、作者以及创建时间</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 登录页面</div><div class="line"> * <span class="keyword">by</span> XXX <span class="keyword">at</span> <span class="number">2018</span><span class="number">-2</span><span class="number">-10</span></div><div class="line"> */</div></pre></td></tr></table></figure><h3 id="ESLint安装指南"><a href="#ESLint安装指南" class="headerlink" title="ESLint安装指南"></a>ESLint安装指南</h3><p>在项目的根目录中运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="built_in">export</span> PKG=eslint-config-airbnb;</div><div class="line">  npm info <span class="string">"<span class="variable">$PKG</span>@latest"</span> peerDependencies --json | <span class="built_in">command</span> sed <span class="string">'s/[\&#123;\&#125;,]//g ; s/: /@/g'</span> | xargs npm install --save-dev <span class="string">"<span class="variable">$PKG</span>@latest"</span></div><div class="line">)</div></pre></td></tr></table></figure><p>之后需要安装babel-eslint，并创建.eslintrc。可以在里面写入自己的代码规则，类似于下方</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</div><div class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</div><div class="line">  <span class="string">"rules"</span>: &#123;</div><div class="line">  // 你的规则</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"parserOptions"</span>: &#123;</div><div class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</div><div class="line">      <span class="string">"experimentalObjectRestSpread"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所有的规则可以在<a href="https://cn.eslint.org/docs/rules/" target="_blank" rel="external">ESLint规则</a>中查看，然后根据你的要求写到rules下</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"rules"</span>: &#123;</div><div class="line"><span class="string">"no-bitwise"</span>: <span class="string">[0]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li><li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li><li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/07/code-standard/code-standard.jpg&quot; alt=&quot;code-standard.jpg&quot; title=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;代码规范只是让代码更容易被理解，让多人开发时代码也能保持内部一致性。&lt;/p&gt;
&lt;p&gt;制定代码规范的标准因团队而异，可以根据多数人的开发习惯或者是参考别人的规范&lt;/p&gt;
&lt;p&gt;实现代码规范的方法有很多种，在React-Native中可以使用ESLint配合编译器进行代码规范审核&lt;/p&gt;
&lt;p&gt;不必矫枉过正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发指北</title>
    <link href="https://mah93.github.io/2018/04/27/react-native-develop-guide/"/>
    <id>https://mah93.github.io/2018/04/27/react-native-develop-guide/</id>
    <published>2018-04-27T09:31:47.000Z</published>
    <updated>2018-04-27T09:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/27/react-native-develop-guide/react-native-develop-north.jpg" alt="react-native-develop-north.jpg" title=""><h3 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h3><ul><li>搭建开发环境</li></ul><p>根据自身的硬件环境，分别安装不同的环境，具体请看官网的教程。<a href="https://reactnative.cn/docs/0.44/getting-started.html#content" target="_blank" rel="external">#搭建开发环境</a></p><ul><li>关于node</li></ul><p>开发RN项目之前，需要熟悉几个npm命令。例如</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure><p>安装该项目中所有依赖包，一般写在package.json中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> XXX <span class="comment">--save</span></div></pre></td></tr></table></figure><p>为你的项目中添加某个依赖包</p><p>等等。。</p><a id="more"></a> <p>当你在本地运行一个React Native的项目时，会同步打开一个终端。会在本地的8081端口启动Js Server，当程序启动的时候，会通过这个服务读取Js代码，并完成页面的渲染。在程序运行的过程中，要保持这个终端处于一直运行的状态。不涉及原生代码改动的时候，无需重新编译。重新Reload页面即可。</p><ul><li>React Native版本</li></ul><p>开始一个新的项目之前，首先确定要使用的RN版本（官方每三个月更新一次），基本上都会使用0.43以上的版本。因为许多组件在之前的老版本并不存在，比如FlatList。新建一个指定版本的RN项目只需</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init MyApp --version 0.39.2</div></pre></td></tr></table></figure><blockquote><p>注意版本号必须精确到两个小数点。</p></blockquote><ul><li>开发工具</li></ul><p>开发工具推荐使用WebStorm或者是VSCode，下载一个Chrome浏览器对于调试有很大帮助。</p><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>除了正常的开发工作，你可能还需要一些辅助的功能来帮助更好的开发</p><ul><li>ESLint</li></ul><p>ESLint是一个JS插件，用来检测代码规范性。它自己包含了一些规范，当然你也可以自己去配置一些符合自己编码习惯的规则。虽然它是一个代码检测，但也不是所有的规则都需要遵循。在.eslintrc中编辑你的规则。<a href="https://cn.eslint.org/" target="_blank" rel="external">ESLint中文官方网站</a></p><p>当配置好你的规则之后，打开IDE的代码检测功能。当你违反了制定的代码规范，会以红标提示。你也可以手动执行命令进行代码检测。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint <span class="params">--ext</span> <span class="string">.js</span> src test</div></pre></td></tr></table></figure><p>执行完之后，会精确到代码行数的报错。</p><blockquote><p>如果需要强制执行，请使用pre-commit插件。它会在每次commit之前执行某些操作，如果遇到问题，就会停止commit操作。</p></blockquote><p>如果你不希望有些代码进行代码检测，把它们的路径加入到.eslintignore文件中:)</p><ul><li>mock</li></ul><p>界面完成之后，可能你的后台服务并没有完成。有些界面会根据数据的不同进行调整。这时候可以通过node服务，模拟一个后台服务器并mock出模拟数据返回到前台页面，完成简单的接口测试。</p><p>你可以使用express来搭建一个简单的node服务器</p><p>通过mock来完成简单的数据，具体方式请参见<a href="http://mockjs.com/" target="_blank" rel="external">mock官方网站</a></p><ul><li>git</li></ul><p>无论是单人开发还是多人协作，git无疑是最好的版本控制工具。日常开发中涉及的git命令并不多，学习成本也不高，请务必使用。实在是没有使用过的请参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰GIT教程</a>!</p><p>这里需要强调的是分支管理，如果是多人开发必须制定一些规则使每个人可以更加方便的开发。</p><ol><li>新建master分支，用于大版本的合并，并设立保护分支</li><li>新建develop分支，用于日常的开发工作，并设立保护分支</li><li>新建submit分支，用于测试版本</li><li>为每一个人新建一个分支，每个人只能在自己的分支上进行开发工作，下班前提交到自己的远程分支上</li><li>一个阶段的代码完成后，需要合并到develop分支，需提交合并请求由项目管理员进行合并操作</li><li>合并之后每个成员合并develop分支</li></ol><p>以上可以根据项目的需求自行修改</p><h3 id="需要考虑的事情"><a href="#需要考虑的事情" class="headerlink" title="需要考虑的事情"></a>需要考虑的事情</h3><p>一个新的项目首先要考虑的就是结构：目录结构、代码结构、系统架构等等，这些会一直影响着项目的健壮性、拓展性。但当代码遇到问题的时候，重构也是必要的。</p><ul><li>目录结构</li></ul><p>这里说的是文件的物理结构。</p><p>1.功能相同的放入同一个文件夹</p><p>功能相同就是说，把所有的页面放入一个文件夹，把所有的逻辑处理放入一个文件夹类似于这种分类方式。优点是同类型的文件都放在一起。缺点是关于同一个页面的代码会分散在几个或者好几个文件夹中，寻找起来比较麻烦。</p><p>2.统一模块的代码放入同一个文件夹</p><p>统一模块的代码包含了这个模块的界面、逻辑处理、网络请求等所有涉及的代码，一个文件夹代表着一个功能模块。优点是相关代码放在一起，寻找或者引用的时候比较快，代码迁移比较方便。缺点是功能模块难以有明确的区分点，一些页面有复用情况。</p><ul><li>代码结构</li></ul><p>你可以在React Naitve的代码中编写JS，也可以写JSX，还可以写样式表或者是内联在JSX中的样式，网络请求也可以写。上面所有的内容都可以写在同一个JS中，这里就需要制定规则。哪些可以写在一起，哪些需要新建另外一个文件去辅助。</p><p>当然还有一些可有可无的东西，例如注释、属性列表等。它们可以帮助代码更好的被理解，增加代码可读性。也可以制定合理的代码规范，配合插件可以很好的使用。</p><ul><li>系统架构</li></ul><p>有关系统架构需要考虑的因素就更多了，如何去处理数据逻辑，网络请求如何去实现，页面与页面之间的联系如何进行等等。这些问题会涉及很多的第三方组件，你需要用以下几个方面去考察这个第三方组件：</p><ol><li>github上stars的数量，可以直观反映出这个组件的质量如何</li><li>上一次提交的时间。如果超过一年没有更新过，那么很可能并不适合新版的RN</li><li>github上issuse数量，当遇到问题的时候大部分都是通过issuse解决</li></ol><p>当然这仅仅是最基本的方面，还有许多别的考察方面，比如它的实现方式，README有没有写的比较详细等等。当你逐个确定要使用的组件之后，一一引入。有些仅仅在开发阶段使用的组件，可以将它们引入开发依赖包中，以免打包进入项目，使得项目包变大。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/27/react-native-develop-guide/react-native-develop-north.jpg&quot; alt=&quot;react-native-develop-north.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;开发前准备&quot;&gt;&lt;a href=&quot;#开发前准备&quot; class=&quot;headerlink&quot; title=&quot;开发前准备&quot;&gt;&lt;/a&gt;开发前准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;搭建开发环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据自身的硬件环境，分别安装不同的环境，具体请看官网的教程。&lt;a href=&quot;https://reactnative.cn/docs/0.44/getting-started.html#content&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#搭建开发环境&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于node&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发RN项目之前，需要熟悉几个npm命令。例如&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装该项目中所有依赖包，一般写在package.json中&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; XXX &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为你的项目中添加某个依赖包&lt;/p&gt;
&lt;p&gt;等等。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>react学习摘要</title>
    <link href="https://mah93.github.io/2018/04/11/react-deep-learn/"/>
    <id>https://mah93.github.io/2018/04/11/react-deep-learn/</id>
    <published>2018-04-11T09:16:26.000Z</published>
    <updated>2018-04-12T11:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/11/react-deep-learn/react-deep-learn.png" alt="react-deep-learn.png" title=""><h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><p>​    在react中，render执行的结果并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。虚拟DOM具有batching(批处理)和高效的Diff算法。由虚拟DOM来确保只对界面上真正的部分进行实际的DOM操作。</p><p>​    比较innerHTML 和Virtual DOM 的重绘过程如下：</p><ul><li>innerHTML: render html string + 重新创建所有 DOM 元素</li></ul><ul><li>Virtual DOM: render Virtual DOM + diff算法+ 必要的 DOM 更新</li></ul><h4 id="批量DOM处理"><a href="#批量DOM处理" class="headerlink" title="批量DOM处理"></a>批量DOM处理</h4><p>​    依靠 setState 的异步性，React在一段时间间隔内，将所有DOM更新收集起来，然后批量处理。也就是说调用setState的时候并不会立即更新状态，而是一段时间时候统一将变动的属性集体进行更新。从而达到减少渲染次数，提高性能的目的。</p><a id="more"></a> <h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>​    在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。</p><p>​    即给定任意两棵树，找到最少的转换步骤。但是<a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="external">标准的的Diff算法</a>复杂度需要O(n^3)。Facebook工程师结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n)：</p><ol><li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li><li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li></ol><h3 id="不同节点类型的比较"><a href="#不同节点类型的比较" class="headerlink" title="不同节点类型的比较"></a>不同节点类型的比较</h3><p>为了在树之间进行比较，我们首先要能够比较两个节点，在React中即比较两个虚拟DOM节点，当两个节点不同时，应该如何处理。这分为两种情况：</p><ol><li>节点类型不同。</li><li>节点类型相同，但是属性不同。</li></ol><ul><li><h5 id="节点类型不同"><a href="#节点类型不同" class="headerlink" title="节点类型不同"></a>节点类型不同</h5></li></ul><p>即在树的同一个位置，前后两次输出了不同类型的节点。React会直接删除掉之前的节点，然后创建并插入新的节点。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;span /&gt;</div><div class="line">=&gt; [removeNode &lt;div /&gt;], [insertNode &lt;span /&gt;]</div></pre></td></tr></table></figure><blockquote><p>需要注意的是，删除节点意味着彻底销毁该节点，而不是再后续的比较中再去看是否有另外一个节点等同于该删除的节点。如果该删除的节点之下有子节点，那么这些子节点也会被完全删除，它们也不会用于后面的比较。</p></blockquote><p>当React在同一个位置遇到不同的组件时，也是简单的销毁第一个组件，而把新创建的组件加上去。这正是应用了第一个假设，不同的组件一般会产生不一样的DOM结构，与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去。</p><h5 id="逐层进行节点比较"><a href="#逐层进行节点比较" class="headerlink" title="逐层进行节点比较"></a>逐层进行节点比较</h5><p>在React中，树的算法其实非常简单，那就是两棵树只会对同一层次的节点进行比较。</p><img src="/2018/04/11/react-deep-learn/react-study.png" alt="react-study.png" title=""><p>React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。</p><p>有如下的节点树变换：</p><img src="/2018/04/11/react-deep-learn/dom-transform.png" alt="dom-transform.png" title=""><p>A节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>parent.remove(A); </div><div class="line"><span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>append(A);</div></pre></td></tr></table></figure><ul><li><h5 id="节点类型相同"><a href="#节点类型相同" class="headerlink" title="节点类型相同"></a>节点类型相同</h5></li></ul><p>React会对属性进行重设从而实现节点的转换。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div id=<span class="string">"before"</span> /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;div id=<span class="string">"after"</span> /&gt;</div><div class="line">=&gt; [replaceAttribute id <span class="string">"after"</span>]</div></pre></td></tr></table></figure><p>虚拟DOM的style属性稍有不同，其值并不是一个简单字符串而必须为一个对象，因此转换过程如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rende<span class="symbol">rA:</span> &lt;div style=&#123;&#123;col<span class="symbol">or:</span> 'red'&#125;&#125; /&gt;</div><div class="line">rende<span class="symbol">rB:</span> &lt;div style=&#123;&#123;fontWeig<span class="symbol">ht:</span> 'bold'&#125;&#125; /&gt;</div><div class="line">=&gt; [removeStyle color], [addStyle font-weight 'bold']</div></pre></td></tr></table></figure><h5 id="列表节点的比较"><a href="#列表节点的比较" class="headerlink" title="列表节点的比较"></a>列表节点的比较</h5><p>​    上面介绍了对于不在同一层的节点的比较，即使它们完全一样，也会销毁并重新创建。那么当它们在同一层时，又是如何处理的呢？这就涉及到列表节点的Diff算法。相信很多使用React的同学大多遇到过这样的警告：</p><img src="/2018/04/11/react-deep-learn/react-warning.png" alt="react-warning.png" title=""><p>这是React在遇到列表时却又找不到key时提示的警告。虽然无视这条警告大部分界面也会正确工作，但这通常意味着潜在的性能问题。因为React觉得自己可能无法高效的去更新这个列表。</p><p>​    列表节点的操作通常包括添加、删除和排序。例如下图，我们需要往B和C直接插入节点F，在jQuery中我们可能会直接使用$(B).after(F)来实现。而在React中，我们只会告诉React新的界面应该是A-B-F-C-D-E，由Diff算法完成更新界面。</p><img src="/2018/04/11/react-deep-learn/react-diif-1.png" alt="react-diif-1.png" title=""><p>这时如果每个节点都没有唯一的标识，React无法识别每一个节点，那么更新过程会很低效，即，将C更新成F，D更新成C，E更新成D，最后再插入一个E节点。效果如下图所示：</p><img src="/2018/04/11/react-deep-learn/react-diff-2.png" alt="react-diff-2.png" title=""><p>可以看到，React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点E，涉及到的DOM操作非常多。而如果给每个节点唯一的标识（key），那么React能够找到正确的位置去插入新的节点，入下图所示：</p><img src="/2018/04/11/react-deep-learn/react-diff-3.png" alt="react-diff-3.png" title=""><h3 id="diff算法对代码的影响"><a href="#diff算法对代码的影响" class="headerlink" title="diff算法对代码的影响"></a>diff算法对代码的影响</h3><ul><li>由于diff算法对于DOM树的添加删除的特点，保持稳定的DOM结构会有助于性能的提升。</li><li>对于列表节点提供唯一的key属性可以帮助React定位到正确的节点进行比较，从而大幅减少DOM操作次数，提高了性能。</li></ul><h2 id="setState究竟干了些什么"><a href="#setState究竟干了些什么" class="headerlink" title="setState究竟干了些什么"></a>setState究竟干了些什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">constructor() &#123;</div><div class="line">    super();</div><div class="line">    this.state = &#123;</div><div class="line">      val: 0</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">    console.log(this.state.val);    // 第 1 次 log</div><div class="line"></div><div class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">    console.log(this.state.val);    // 第 2 次 log</div><div class="line"></div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">      console.log(this.state.val);  // 第 3 次 log</div><div class="line"></div><div class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</div><div class="line">      console.log(this.state.val);  // 第 4 次 log</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">&gt; 问上述代码中 4 次 console.log 打印出来的 val 分别是多少？</div><div class="line">&gt; 答案：4 次 log 的值分别是：0、0、2、3。</div></pre></td></tr></table></figure><p>上述面试题说明了，setState方法并不是同步的，也不是异步的。这牵扯到了react的更新机制。</p><p>以下是翻自官方setState原代码的注解，官网的说明也是类似:</p><blockquote><p>不保证<code>this.state</code>会立即更新，所以在调用这个方法后存取<code>this.state</code>可能会回传旧的值。</p><p>不保证呼叫<code>setState</code>就会同步地执行，而它们也可能最终被被批量调用(多次呼叫的情况下)。你可以提供额外的回调(callback)，回调(callback)将会在<code>setState</code>实际被完成时被执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/04/11/react-deep-learn/react-deep-learn.png&quot; alt=&quot;react-deep-learn.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;虚拟dom&quot;&gt;&lt;a href=&quot;#虚拟dom&quot; class=&quot;headerlink&quot; title=&quot;虚拟dom&quot;&gt;&lt;/a&gt;虚拟dom&lt;/h2&gt;&lt;p&gt;​    在react中，render执行的结果并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。虚拟DOM具有batching(批处理)和高效的Diff算法。由虚拟DOM来确保只对界面上真正的部分进行实际的DOM操作。&lt;/p&gt;
&lt;p&gt;​    比较innerHTML 和Virtual DOM 的重绘过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innerHTML: render html string + 重新创建所有 DOM 元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Virtual DOM: render Virtual DOM + diff算法+ 必要的 DOM 更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;批量DOM处理&quot;&gt;&lt;a href=&quot;#批量DOM处理&quot; class=&quot;headerlink&quot; title=&quot;批量DOM处理&quot;&gt;&lt;/a&gt;批量DOM处理&lt;/h4&gt;&lt;p&gt;​    依靠 setState 的异步性，React在一段时间间隔内，将所有DOM更新收集起来，然后批量处理。也就是说调用setState的时候并不会立即更新状态，而是一段时间时候统一将变动的属性集体进行更新。从而达到减少渲染次数，提高性能的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://mah93.github.io/2018/02/26/science-net/"/>
    <id>https://mah93.github.io/2018/02/26/science-net/</id>
    <published>2018-02-26T03:36:09.000Z</published>
    <updated>2018-02-26T03:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/26/science-net/science-network.png" alt="science-network.png" title=""><blockquote><p>由于特殊的情况，出差所在的地方同性交友网站上不去，CSDN打不开，百度云盘用不了（不要问我问什么。记录一下自己是如何走在被查水表的路上。</p></blockquote><p>科学上网的方式有很多种，可以自己购买一台位于国外的VPS服务器搭建SS客户端，自己手动搭梯子。如果是懒得自己折腾可以购买VPN账号，但是很多的VPN服务商不稳定，有可能用着用着就被封了。所以一个月一个月买比较靠谱。这里说明一下购买账号后的操作。</p><h4 id="下载Shadowsocks客户端"><a href="#下载Shadowsocks客户端" class="headerlink" title="下载Shadowsocks客户端"></a>下载Shadowsocks客户端</h4><p>自行百度下载的方式，下载好之后。双击打开，把买入的账号填进去，点击确定。</p><p>启用系统代理即可。</p><p>打开浏览器，就可以开始你的科学上网之旅了。</p><p>如果你的账号不限制设备，并且想用手机同时用。可以在手机市场搜索Shadowsocks，同样的配置。iOS用户可以用SsrConnectPro。</p><h4 id="特殊环境引起的问题"><a href="#特殊环境引起的问题" class="headerlink" title="特殊环境引起的问题"></a>特殊环境引起的问题</h4><p>上述配置完成之后，依然不能访问到github，将ss的代理模式更改为全局代理。</p><p>即使是全局模式，命令行中，依然访问不到github。</p><p>查看Shadowsocks的本地代理端口，一般是1087端口。</p><p>打开命令行</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi .gitconfig</div><div class="line">`在git的配置文件中添加http和https的代理`</div><div class="line">[http]</div><div class="line">proxy = http:<span class="comment">//localhost:1087</span></div><div class="line">[https]</div><div class="line">proxy = https:<span class="comment">//localhost:1087</span></div><div class="line">`如果需要使用coding等国内的代码托管服务，请注释以上四行配置`</div></pre></td></tr></table></figure><p>配置并保存后，就可以和github上的好基友玩耍了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/02/26/science-net/science-network.png&quot; alt=&quot;science-network.png&quot; title=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;由于特殊的情况，出差所在的地方同性交友网站上不去，CSDN打不开，
      
    
    </summary>
    
    
      <category term="工具" scheme="https://mah93.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jenkins小结</title>
    <link href="https://mah93.github.io/2018/02/01/jenkins-summary/"/>
    <id>https://mah93.github.io/2018/02/01/jenkins-summary/</id>
    <published>2018-02-01T10:51:50.000Z</published>
    <updated>2018-02-01T10:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/01/jenkins-summary/jenkins_logo.jpg" alt="jenkins_logo.jpg" title=""><h3 id="what’s-jenkins"><a href="#what’s-jenkins" class="headerlink" title="what’s jenkins?"></a>what’s jenkins?</h3><blockquote><p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p><p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p></blockquote><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p><a id="more"></a> <h3 id="安装（centOS）"><a href="#安装（centOS）" class="headerlink" title="安装（centOS）"></a>安装（centOS）</h3><p>在centOS系统中，使用yum安装</p><ul><li>创建 <code>jenkins</code>的 <code>yum</code>的源文件</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/jenkins.repo</div></pre></td></tr></table></figure><p>在 <code>jenkins.repo</code>中加入以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">[jenkins]</span></div><div class="line"><span class="attr">name</span>=Jenkins</div><div class="line"><span class="attr">baseurl</span>=http://pkg.jenkins-ci.org/redhat</div><div class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></div></pre></td></tr></table></figure><ul><li><code>rpm</code>增加<code>jenkins</code>源的<code>key</code></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>sudo rpm --<span class="keyword">import</span> <span class="symbol">http:</span>/<span class="regexp">/pkg.jenkins-ci.org/redhat</span><span class="regexp">/jenkins-ci.org.key</span></div></pre></td></tr></table></figure><ul><li>安装 <code>jenkins</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum <span class="keyword">install</span> jenkins</div></pre></td></tr></table></figure><ul><li>配置Jenkins文件（可跳过）</li></ul><p>主要可以配置<code>jenkins</code>的运行端口和监听端口，以及启动用户，配置文件地址为<code>/etc/sysconfig/jenkins</code>，下面为主要修改内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /etc/sysconfig/jenkins</div><div class="line"><span class="comment"># 修改启动用户为root,默认为jenkins</span></div><div class="line">JENKINS_USER=<span class="string">"root"</span></div><div class="line"><span class="comment"># 修改运行端口为9999，默认为8080</span></div><div class="line">JENKINS_PORT=<span class="string">"9999"</span></div></pre></td></tr></table></figure><ul><li>启动<code>jenkins</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo<span class="built_in"> service </span>jenkins start</div></pre></td></tr></table></figure><p>访问相应端口号即可访问jenkins主页</p><h3 id="安装（其他系统）"><a href="#安装（其他系统）" class="headerlink" title="安装（其他系统）"></a>安装（其他系统）</h3><p>直接在<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>中下载相应的<em>war包</em>，下载完成后，打开终端，进入到war包所在目录，执行以下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">java </span>-<span class="keyword">jar </span><span class="keyword">jenkins.war </span>--httpPort=<span class="number">8888</span></div></pre></td></tr></table></figure><p>httpPort指的就是Jenkins所使用的http端口，这里指定8888，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入相应地址</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>第一次打开jenkins，需要输入密码</p><img src="/2018/02/01/jenkins-summary/jenkins.jpg" alt="jenkins.jpg" title=""><p>密码文件<code>/var/lib/jenkins/secrets/initialAdminPassword</code>, 然后填入点击<code>Continue</code></p><blockquote><p>如果忘记密码了，打开JENKINS_HOME/users目录下忘记密码的用户名文件夹，里面有一个config.xml。找到<passwordhash>节点，把里面的内容换成jbcrypt:$2a$10$DdaWzN64JgUtLdvxWIflcuQu2fgrrMSAMabF5TSrGK5nXitqK9ZMS</passwordhash></p><p>保存并重启jenkins，再次登陆jenkins，密码重置为111111</p></blockquote><p>打开jenkins首页如下：</p><img src="/2018/02/01/jenkins-summary/jenkins_home.jpg" alt="jenkins_home.jpg" title=""><h3 id="安装plugin"><a href="#安装plugin" class="headerlink" title="安装plugin"></a>安装plugin</h3><p>Jenkins支持很多的plugin，这些plugin极大地丰富了Jenkins的功能。安装plugin有两种方式：自动安装和手动安装。</p><ul><li><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>在首页中选中系统管理</p></li></ul><img src="/2018/02/01/jenkins-summary/jenkins_menu.png" alt="jenkins_menu.png" title=""><p>点击插件管理</p><img src="/2018/02/01/jenkins-summary/jenkins_plugin.png" alt="jenkins_plugin.png" title=""><p>在可选插件中，选择需要的plugin并直接安装。</p><blockquote><p>在可选插件列表中没有显示任何plugin</p><p>选择插件管理-高级-升级站点-更改URL为</p><p><code>[http://mirror.xmission.com/jenkins/updates/update-center.json]</code>-点击提交即可</p></blockquote><ul><li><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4></li></ul><p>如果说在列表中搜索不到，还可以前往<a href="https://plugins.jenkins.io/" target="_blank" rel="external">jenkins plugin</a>下载，进行手动安装</p><p>选择在『高级』标签下，上传插件栏中点击选择文件：</p><img src="/2018/02/01/jenkins-summary/jenkins_upload.png" alt="jenkins_upload.png" title=""><p>点击上传按钮，便会自动上传并安装。</p><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>安装好必要的plugin之后，就可以开始构建自己的项目了，在菜单中选择新建，输入项目名并选择构建一个自由风格的软件项目：</p><img src="/2018/02/01/jenkins-summary/jenkins_build.png" alt="jenkins_build.png" title=""><p>点击ok后，进入构建配置页面。可以根据项目需求，去配置触发器、搭建构建环境、构建脚本以及构建后部署或者其他操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/02/01/jenkins-summary/jenkins_logo.jpg&quot; alt=&quot;jenkins_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;what’s-jenkins&quot;&gt;&lt;a href=&quot;#what’s-jenkins&quot; class=&quot;headerlink&quot; title=&quot;what’s jenkins?&quot;&gt;&lt;/a&gt;what’s jenkins?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。&lt;/p&gt;
&lt;p&gt;持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="https://mah93.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Locust使用说明</title>
    <link href="https://mah93.github.io/2017/12/23/locust-introduce/"/>
    <id>https://mah93.github.io/2017/12/23/locust-introduce/</id>
    <published>2017-12-23T14:13:20.000Z</published>
    <updated>2018-02-01T09:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/23/locust-introduce/locust_logo@2x.png" alt="locust_logo@2x.png" title=""><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/locustio/locust" target="_blank" rel="external">Locust</a> 是一个开源负载测试工具。使用python代码定义用户行为，也可以仿真百万个用户。</p><p>Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。</p><p>Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式gevent。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>使用纯 Python 代码编写用户测试场景；不需要 UIs 或者 XML</li><li>分布式&amp;可伸缩 - 支持成千上万的用户</li><li>基于 Web 的 UI</li><li>可以测试任意系统；虽然 Locust 是面向 Web 的，但是也可以测试其他任意的系统</li></ul><a id="more"></a> <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>安装Python2 或Python3，通过命令行或者是官网安装</p><h3 id="安装Locust"><a href="#安装Locust" class="headerlink" title="安装Locust"></a>安装Locust</h3><p>通过pip命令安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip  install --<span class="built_in">index</span> http<span class="variable">s:</span>//pypi.mirrors.ustc.edu.<span class="keyword">cn</span>/simple/ locust</div></pre></td></tr></table></figure><p>安装完成后，命令行中验证</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locust <span class="comment">--help</span></div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建test-py"><a href="#创建test-py" class="headerlink" title="创建test.py"></a>创建test.py</h3><p>创建一个test.py，然后编辑</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from locust import HttpLocust, TaskSet, task</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span>(<span class="title">TaskSet</span>):</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        pass</div><div class="line">        </div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.post(<span class="string">"/login"</span>, &#123;</div><div class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</div><div class="line">            <span class="string">"password"</span>: <span class="string">""</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.get(<span class="string">"/"</span>)</div><div class="line"></div><div class="line">    @task(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.client.get(<span class="string">"/about/"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span>(<span class="title">HttpLocust</span>):</span></div><div class="line">    task_set = WebsiteTasks</div><div class="line">    min_wait = <span class="number">5000</span></div><div class="line">    max_wait = <span class="number">15000</span></div></pre></td></tr></table></figure><p>task_set：任务指定的方法</p><p>min_wait：最小等待时间（ms）</p><p>max_ wait：最大等待时间（ms）</p><p>on_start：会首先执行该方法</p><p>@task（1）：单个任务（权重）</p><p>每次执行任务，会在最小等待时间到最大等待时间中随机执行，按照task的权重执行某一任务</p><h3 id="自定义成功失败"><a href="#自定义成功失败" class="headerlink" title="自定义成功失败"></a>自定义成功失败</h3><p>locust会根据一次请求的状态码来确定该次请求是否成功，并表现在界面上。</p><p>当需要测试的接口，涉及到业务。就需要根据返回的数据来判断该次请求是否成功</p><p>需要将post请求改成以下方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with self<span class="selector-class">.client</span><span class="selector-class">.post</span>(<span class="string">"/login"</span>, &#123;<span class="string">"username"</span>: <span class="string">"test_user"</span>,<span class="string">"password"</span>: <span class="string">"123"</span>&#125;) as response:</div><div class="line">        response.success(<span class="string">'success'</span>)<span class="comment">//成功</span></div><div class="line">        response.failure(<span class="string">'error'</span>)<span class="comment">//失败</span></div></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>编辑完test.py之后，在命令行中输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locust -f <span class="string">./test.py</span> <span class="params">--host=</span>你的服务器地址</div></pre></td></tr></table></figure><p>没有报错之后，打开本地8089端口，即可看到locust的测试页面</p><img src="/2017/12/23/locust-introduce/locust.png" alt="locust-home" title="locust-home"><p>输入所需测试强度，即可开始测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/23/locust-introduce/locust_logo@2x.png&quot; alt=&quot;locust_logo@2x.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/locustio/locust&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Locust&lt;/a&gt; 是一个开源负载测试工具。使用python代码定义用户行为，也可以仿真百万个用户。&lt;/p&gt;
&lt;p&gt;Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。&lt;/p&gt;
&lt;p&gt;Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式gevent。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用纯 Python 代码编写用户测试场景；不需要 UIs 或者 XML&lt;/li&gt;
&lt;li&gt;分布式&amp;amp;可伸缩 - 支持成千上万的用户&lt;/li&gt;
&lt;li&gt;基于 Web 的 UI&lt;/li&gt;
&lt;li&gt;可以测试任意系统；虽然 Locust 是面向 Web 的，但是也可以测试其他任意的系统&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Locust" scheme="https://mah93.github.io/tags/Locust/"/>
    
  </entry>
  
  <entry>
    <title>mobx学习笔记</title>
    <link href="https://mah93.github.io/2017/12/13/mobx-introduce/"/>
    <id>https://mah93.github.io/2017/12/13/mobx-introduce/</id>
    <published>2017-12-13T05:05:17.000Z</published>
    <updated>2018-02-01T09:25:47.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/13/mobx-introduce/mobx_logo@2x.png" alt="mobx_logo@2x.png" title=""><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install mobx --save</code></p><p>配合React: <code>npm install mobx-react --save</code></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MobX 是一个通过对开发者透明的函数响应式编程（TFRP）方式，让状态管理（state management）变得简单、具有高扩展性的库，并且这个库经过了严格的测试。</p><p>MobX的思想非常简单：来源于应用的状态的任何事物，都能被自动获得。</p><p>包括UI、数据变更、与服务器通信等等。</p><img src="/2017/12/13/mobx-introduce/flow.png" alt="flow.png" title=""><a id="more"></a> <h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="可观察的状态（observable-state）"><a href="#可观察的状态（observable-state）" class="headerlink" title="可观察的状态（observable state）"></a>可观察的状态（observable state）</h3><p>MobX 给已有的数据结构增加了可观察的能力（如对象、数组、类实例等）。你只需要很简单地使用<a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank" rel="external">@observable</a> 装饰你的类属性（property）即可。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> &#123;</span></div><div class="line">    id = Math.random();</div><div class="line">    @observable title = <span class="string">""</span>;</div><div class="line">    @observable finished = <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="计算值（Computed-values）"><a href="#计算值（Computed-values）" class="headerlink" title="计算值（Computed values）"></a>计算值（Computed values）</h3><p>使用 MobX，你可以很容易的定义计算值，当相关数据变化时，计算值会自动发生变化。 计算值可以通过使用 <a href="http://mobxjs.github.io/mobx/refguide/computed-decorator.html" target="_blank" rel="external"><code>@computed</code></a> 装饰器声明，也可以通过 <code>(extend)Observable</code> 配合 getter/setter 函数进行声明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">    <span class="meta">@observable</span> todos = [];</div><div class="line">    <span class="meta">@computed</span> <span class="keyword">get</span> unfinishedTodoCount() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(todo =&gt; !todo.finished).length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>MobX 会确保当一个 todo 增加或者当 <code>finished</code> 改变时， <code>unfinishedTodoCount</code> 是自动更新的。 计算值类似于电子表格程序的公式。它们的更新永远是自动的，并且只在需要的时候更新。</p><h3 id="observer"><a href="#observer" class="headerlink" title="@observer"></a>@observer</h3><p><code>observer</code> 函数/装饰器可以用来将 React 组件转变成响应式组件。当被监听的变量更改的时候，引用到该变量的组件会相应重新渲染。</p><p>当组件之间有嵌套情况的时候，向子组件传递的是引用，而不是该引用的值。</p><h3 id="action-动作"><a href="#action-动作" class="headerlink" title="action (动作)"></a>action (动作)</h3><p>用法:</p><ul><li><code>action(fn)</code></li><li><code>action(name, fn)</code></li><li><code>@action classMethod() {}</code></li><li><code>@action(name) classMethod () {}</code></li><li><code>@action boundClassMethod = (args) =&gt; { body }</code></li><li><code>@action(name) boundClassMethod = (args) =&gt; { body }</code></li><li><code>@action.bound classMethod() {}</code></li><li><code>@action.bound(function() {})</code></li></ul><p>任何应用都有动作。动作是任何用来修改状态的东西。 action就是用来修饰改变观察值的函数。</p><p>mobx还有很多其他的函数以及方法，这里只介绍了其中最常用的四个，其他的功能可以在 <a href="http://cn.mobx.js.org/" target="_blank" rel="external">mobx官网</a> 中查看。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>下面是一个简单的mobx应用，一个父组件包含着两个子组件。当其中一个子组件发生改变时，不会触发另一个组件的重新渲染，从而达到了我们的预期需求：只有发生改变的地方需要重新渲染。实际开发的时候只需要将可能会发生改变的组件独立出来，每次只更新一个组件或几个组件。尽可能减少render函数的负担，提高react-native的重绘能力。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyState</span> &#123;</span></div><div class="line">  @observable num1 = <span class="number">0</span>;</div><div class="line">  @observable num2 = <span class="number">100</span>;</div><div class="line"></div><div class="line">  @action addNum1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.num1 ++;</div><div class="line">  &#125;;</div><div class="line">  @action addNum2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.num2 ++;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const newState = <span class="keyword">new</span> MyState();</div><div class="line"></div><div class="line">const AllNum = observer(<span class="function"><span class="params">(props)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'刷新all'</span>);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View&gt;</div><div class="line">      &lt;Text&gt;num2 = &#123;props.store.num2&#125;&lt;/Text&gt;</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Button onPress=&#123;props.store.addNum2&#125; title=<span class="string">"button2"</span> /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">  );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">const Main = observer(<span class="function"><span class="params">(props)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'刷新main'</span>);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;View&gt;</div><div class="line">      &lt;Text&gt;num1 = &#123;props.store.num1&#125;&lt;/Text&gt;</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Button onPress=&#123;props.store.addNum1&#125; title=<span class="string">"button1"</span> /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">  );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">@observer</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Asset</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> &#123;</span></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Main store=&#123;newState&#125; /&gt;</div><div class="line">        &lt;AllNum store=&#123;newState&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>引入mobx做为项目的数据管理，势必会带来代码量增加等问题。我们可以在项目目录结构上作出相应调整，以便于更好的开发。</p><h3 id="以功能为标准划分"><a href="#以功能为标准划分" class="headerlink" title="以功能为标准划分"></a>以功能为标准划分</h3><p>将文件夹按照功能区分，比如pages下存放所有的页面，logics下存放所有的mobx的逻辑等。</p><p>这样的结构可以一眼就划分出每个js的功能，每个文件夹下存放着相同功能的js。</p><p>带来的问题就是，页面与逻辑不在一个地方。查找起来十分麻烦，pages下的子目录与logics下的子目录结构是相似的或者是相同的，刚接触的时候容易搞混。当功能变动，或者是整体迁移的时候，涉及页面零散不易拆分。</p><h3 id="以模块为标准划分"><a href="#以模块为标准划分" class="headerlink" title="以模块为标准划分"></a>以模块为标准划分</h3><p>文件夹按照一个个页面功能划分，如首页、注册登录模块、我的模块等，每个文件夹下存放该模块的页面、逻辑等所有涉及到该模块的代码。</p><p>这样的划分的好处是，文件结构可以与设计的页面对应起来。划分出一个个独立的模块，实现该模块的所有或者说大部分的代码都在同一个文件夹，易于拆分。</p><p>但当模块与模块之间有交互或者跳转的时候，就会横跨几个文件夹，难以对照。又或者模块之间有共用组件的时候就变得十分难以划分。无论将共用组件放到哪里，都不合适。放在其中一个模块中，另一个模块去引用的时候十分困难。两边都放上代码，但是十分麻烦。要是再用一个与模块同级的文件夹，那各个模块又不能真正“独立”起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/13/mobx-introduce/mobx_logo@2x.png&quot; alt=&quot;mobx_logo@2x.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;npm install mobx --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配合React: &lt;code&gt;npm install mobx-react --save&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;MobX 是一个通过对开发者透明的函数响应式编程（TFRP）方式，让状态管理（state management）变得简单、具有高扩展性的库，并且这个库经过了严格的测试。&lt;/p&gt;
&lt;p&gt;MobX的思想非常简单：来源于应用的状态的任何事物，都能被自动获得。&lt;/p&gt;
&lt;p&gt;包括UI、数据变更、与服务器通信等等。&lt;/p&gt;
&lt;img src=&quot;/2017/12/13/mobx-introduce/flow.png&quot; alt=&quot;flow.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="https://mah93.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>this到底指的是谁</title>
    <link href="https://mah93.github.io/2017/12/01/who-is-this/"/>
    <id>https://mah93.github.io/2017/12/01/who-is-this/</id>
    <published>2017-12-01T10:47:04.000Z</published>
    <updated>2018-02-01T10:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/01/who-is-this/who_logo.jpg" alt="who_logo.jpg" title=""><p>JavaScript中的this依赖于函数的调用方式，因此把this称为调用上下文很合适。</p><p>先来一个最简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> li_lei = &#123;</div><div class="line">  name: <span class="string">"han mei mei"</span>,</div><div class="line">  ask: ask</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`这两个方法分别输出什么`</span></div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"han mei mei"</span></div></pre></td></tr></table></figure><p>稍微复杂一点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> li_lei = &#123;</div><div class="line">  name: <span class="string">"li lei"</span>,</div><div class="line">  ask: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> han_mei_mei = &#123;</div><div class="line">  name: <span class="string">"han_mei_mei"</span>,</div><div class="line">  ask: li_lei.ask</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`这两个方法分别输出什么`</span></div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"han mei mei"</span></div></pre></td></tr></table></figure><a id="more"></a> <p>根据上面的两个例子引出一个概念，请记住：</p><h5 id="function中的this一般情况下表示的是调用对象（调用对象-方法名-）"><a href="#function中的this一般情况下表示的是调用对象（调用对象-方法名-）" class="headerlink" title="function中的this一般情况下表示的是调用对象（调用对象.方法名()）"></a>function中的this一般情况下表示的是调用对象（调用对象.方法名()）</h5><p>那么接下来需要考虑一个问题，在js里经常把function作为回调函数传来传去，用什么手段可以让function中的this保持不变？</p><h3 id="让function中的this“保持不变”"><a href="#让function中的this“保持不变”" class="headerlink" title="让function中的this“保持不变”"></a>让function中的this“保持不变”</h3><p>使用bind方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> li_lei = &#123;</div><div class="line">  name: <span class="string">"li lei"</span>,</div><div class="line">  _ask: function()&#123;</div><div class="line">    console.log(this.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">li_lei<span class="selector-class">.ask</span> = li_lei._ask.bind(li_lei)</div><div class="line"></div><div class="line"><span class="selector-tag">var</span> han_mei_mei = &#123;</div><div class="line">  name: <span class="string">"han mei mei"</span></div><div class="line">&#125;</div><div class="line">han_mei_mei<span class="selector-class">.ask</span> = li_lei.ask</div><div class="line"></div><div class="line">`这两个方法分别输出什么`</div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"li lei"</span></div></pre></td></tr></table></figure><p>改成用类来举例（类的声明用es6语法）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"li lei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = <span class="keyword">this</span>._ask.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  _ask()&#123;</div><div class="line">    console.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> li_lei = new LiLei();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanMeiMei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(li_lei_instance)&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"han mei mei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = li_lei_instance.ask</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> han_mei_mei = new HanMeiMei(li_lei)</div><div class="line"></div><div class="line">`这两个方法分别输出什么`</div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"li lei</span></div></pre></td></tr></table></figure><p>不使用bind实现同样的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"li lei"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">this</span>.ask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(that.name);</div><div class="line">&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> li_lei = <span class="keyword">new</span> LiLei();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanMeiMei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(li_lei_instance)&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"han mei mei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = li_lei_instance.ask</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> han_mei_mei = <span class="keyword">new</span> HanMeiMei(li_lei)</div><div class="line"></div><div class="line"><span class="string">`这两个方法分别输出什么`</span></div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"li lei</span></div></pre></td></tr></table></figure><p>变复杂一点</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"li lei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = <span class="keyword">this</span>.bind_ask();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  bind_ask()&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> = <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">      console.log(that.name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">fun</span>;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> li_lei = new LiLei();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanMeiMei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(li_lei_instance)&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"han mei mei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = li_lei_instance.ask</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> han_mei_mei = new HanMeiMei(li_lei)</div><div class="line"></div><div class="line">`这两个方法分别输出什么`</div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"li lei</span></div></pre></td></tr></table></figure><p>使用ES6中的箭头函数来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"li lei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> li_lei = <span class="keyword">new</span> LiLei();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanMeiMei</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(li_lei_instance)&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"han mei mei"</span>;</div><div class="line">    <span class="keyword">this</span>.ask = li_lei_instance.ask</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> han_mei_mei = <span class="keyword">new</span> HanMeiMei(li_lei)</div><div class="line"></div><div class="line"><span class="string">`这两个方法分别输出什么`</span></div><div class="line">li_lei.ask()             =&gt; <span class="string">"li lei"</span></div><div class="line">han_mei_mei.ask()        =&gt; <span class="string">"li lei</span></div></pre></td></tr></table></figure><p>ES6中的箭头函数和普通的function在处理this上是有差别的，根据上面的例子你应该已经明白了：</p><h4 id="ES6的箭头函数中的this，永远保持不变，一只表示声明时的this"><a href="#ES6的箭头函数中的this，永远保持不变，一只表示声明时的this" class="headerlink" title="ES6的箭头函数中的this，永远保持不变，一只表示声明时的this"></a>ES6的箭头函数中的this，永远保持不变，一只表示声明时的this</h4>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/01/who-is-this/who_logo.jpg&quot; alt=&quot;who_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;p&gt;JavaScript中的this依赖于函数的调用方式，因此把this称为调用上下文很合适。&lt;/p&gt;
&lt;p&gt;先来一个最简单的例子&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ask&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; li_lei = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;han mei mei&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ask: ask&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`这两个方法分别输出什么`&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;li_lei.ask()             =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;li lei&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;han_mei_mei.ask()        =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;han mei mei&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;稍微复杂一点&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; li_lei = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;li lei&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ask: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; han_mei_mei = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;han_mei_mei&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ask: li_lei.ask&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`这两个方法分别输出什么`&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;li_lei.ask()             =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;li lei&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;han_mei_mei.ask()        =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;han mei mei&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>App安全性设计</title>
    <link href="https://mah93.github.io/2017/11/21/app-safety-design/"/>
    <id>https://mah93.github.io/2017/11/21/app-safety-design/</id>
    <published>2017-11-21T04:34:26.000Z</published>
    <updated>2018-02-01T09:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/21/app-safety-design/app_logo.jpg" alt="app_logo.jpg" title=""><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>​    HTTP协议是没有加密的明文传输协议，<strong>如果APP采用HTTP传输数据，则会泄露传输内容，可能被中间人劫持，修改传输的内容</strong>。劫持了HTTP通信，往APP的通信中加入了自己的推广内容，还有一些低俗的推广广告，这很影响用户体验。一些别有用心的人通过搭建公共WiFi，进行流量劫持、嗅探，可以获得通过HTTP传输的敏感信息。为了保护用户的信息安全、保护自己的商业利益，减少攻击面，需要保障通信信道的安全，采用开发方便的HTTPS无疑是最优方案。<br>​    <strong>HTTPS：</strong>在http(超文本传输协议)基础上提出的一种安全的http协议，因此可以称为安全的超文本传输协议。http协议直接放置在TCP协议之上，而https提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。</p><p>​    其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。<br><a id="more"></a> </p><h2 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h2><p>​    简单的来说，SSL/TSL通过四次握手，主要交换三个信息：</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>​    该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证。</p><h3 id="三个随机数"><a href="#三个随机数" class="headerlink" title="三个随机数"></a>三个随机数</h3><p>​    这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的<strong>“对话密钥”</strong>。</p><p>​    首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。只有，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</p><h3 id="加密通信协议"><a href="#加密通信协议" class="headerlink" title="加密通信协议"></a>加密通信协议</h3><p>​    就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</p><p>​    有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？</p><p>​    这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>​    token是一种身份验证的机制，初始时用户提交账号数据给服务端，服务端采用一定的策略生成一个字符串（token），token字符串中包含了少量的用户信息，并且有一定的期限。服务端会把token字符串传给客户端，客户端保存token字符串，并在接下来的请求中带上这个字符串。</p><p>​    服务端在生成token时，加入少量的用户信息，比如用户的id。服务端接收到token之后，可以解析出这些数据，从而将token和用户关联了起来。</p><p>​    token具有一定的时效性，如果token过期了，客户端应该对token续期或者重新生成token。这取决于token的过期机制。在token续期或者重新生成token的时候，需要额外加入数据来验证身份。因为token已经过期了，即token已经不能用来验证用户的身份了。这个时候可以请求用户重新输入账号和密码。</p><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>​    代码混淆技术基本原理是使反编译工具反编译出来的代码人难以阅读，从而达到防止被逆向破解的目的。</p><h2 id="Android混淆"><a href="#Android混淆" class="headerlink" title="Android混淆"></a>Android混淆</h2><h3 id="Java类名、方法名混淆"><a href="#Java类名、方法名混淆" class="headerlink" title="Java类名、方法名混淆"></a>Java类名、方法名混淆</h3><p>​    Dalvik字节码包含了大量的调试信息，如类名、方法名、字段名、参数名、变量名等，使用反编译工具可以还原这些信息。由于类名、方法名等通常都会遵循一定的命名规范，破解者很容易根据这些信息来猜测代码功能，阅读起来就跟查看源代码一样。从Android2.3开始，Google在SDK中加入了一款叫ProGuard的代码混淆工具，ProGuard会删除这些调试信息，并用无意义的字符序列来替换类名、方法名等，使得使用反编译出来的代码难以阅读，提升逆向难度。使用ProGuard混淆过过后，反编译出来的类名和方法名无法阅读。</p><h3 id="Java代码混淆"><a href="#Java代码混淆" class="headerlink" title="Java代码混淆"></a>Java代码混淆</h3><p>​    通过对功能代码流程进行乱序混淆，实际运行时乱序混淆后的代码流程却和原始代码流程是一样的，但反编译出来的代码流程静态阅读时与原始流程有很大差异，使破解者很难通过静态分析理解代码功能，从而保护代码不被逆向分析。比如，原始的代码流程是1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7，经过乱序混淆后静态反汇编查看到的代码流程可能变成2-&gt;7-&gt;5-&gt;1-&gt;6-&gt;4-&gt;3，实际运行时代码流程仍然是1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7。</p><h3 id="Dalvik字节码加密"><a href="#Dalvik字节码加密" class="headerlink" title="Dalvik字节码加密"></a>Dalvik字节码加密</h3><p>​    将dex文件中的部分或全部Dalvik字节码加密，每次需要执行时由专门的Native代码负责动态解密和回填，静态反编译出来的代码已经无法阅读甚至无法反编译，动态调试也难以逆向分析。</p><h2 id="iOS混淆"><a href="#iOS混淆" class="headerlink" title="iOS混淆"></a>iOS混淆</h2><h3 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h3><p>​    对程序中使用到字符串的地方，首先获取到使用到的字符串，当然要注意哪些是能加密，哪些不能加密的，然后对字符串进行加密，并保存加密后的数据，再在使用字符串的地方插入解密算法，这样就很好的保护了明文字符串。</p><h3 id="类名方法名混淆"><a href="#类名方法名混淆" class="headerlink" title="类名方法名混淆"></a>类名方法名混淆</h3><p>​    对于程序中的类名方法名，自己产生一个随机的字符串来替换这些定义的类名和方法名，但是不是所有类名，方法名都能替换的，要过滤到系统有关的函数以及类，</p><h3 id="程序代码混淆"><a href="#程序代码混淆" class="headerlink" title="程序代码混淆"></a>程序代码混淆</h3><p>​    可以基于Xcode使用的编译器clang，然后在中间层也就是IR实现自己的一些混淆处理，比如加入一些无用的逻辑块啊，代码块啊，以及加入各种跳转但是又不影响程序原有的逻辑。</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>​    加壳是在二进制的程序中植入一段代码，在运行的时候优先取得程序的控制权，做一些额外的工作。大多数病毒就是基于此原理。是应用加固的一种手法对原始二进制原文进行加密/隐藏/混淆。所谓加壳，是一种通过一系列数学运算，将可执行程序文件或动态链接库文件的编码进行改变（目前还有一些加壳软件可以压缩、加密驱动程序），以达到缩小文件体积或加密程序编码的目的。当被加壳的程序运行时，外壳程序先被执行，然后由这个外壳程序负责将用户原有的程序在内存中解压缩，并把控制权交还给脱壳后的真正程序。一切操作自动完成，用户不知道也无需知道壳程序是如何运行的。一般情况下，加壳程序和未加壳程序的运行结果是一样的。</p><h3 id="加壳作用"><a href="#加壳作用" class="headerlink" title="加壳作用"></a>加壳作用</h3><p>​    加壳的程序可以有效阻止对程序的反汇编分析，以达到它不可告人的目的。这种技术也常用来保护软件版权，防止被软件破解。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>保护自己核心代码算法,提高破解/盗版/二次打包的难度。</li><li>还可以缓解代码注入/动态调试/内存注入攻击。</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>​    身份认证也称为“身份验证”或“身份鉴别”，是指确认操作者身份的过程，从而确定该用户是否具有对某种资源的访问和使用权限，进而使应用能够可靠、有效地执行，防止攻击者假冒合法用户获得资源的访问权限，保证系统和数据的安全，以及授权访问者的合法利益。</p><h3 id="静态密码"><a href="#静态密码" class="headerlink" title="静态密码"></a>静态密码</h3><p>​    用户的密码是由用户自己设定的。在登录时输入正确的密码，就认为操作者就是合法用户。实际上，由于用户担心自己的密码忘记，经常使用简单的密码组合。不仅容易被猜中，而且不易保存。所以在设置密码的时候尽量复杂，数字加字母等组合。登录密码和重要操作密码应该设置成不一样的字符串，更加保证了安全性。</p><h3 id="短信密码"><a href="#短信密码" class="headerlink" title="短信密码"></a>短信密码</h3><p>​    短信密码以手机短信形式请求包含6位随机数的动态密码，身份认证系统以短信形式发送随机的6位密码到客户的手机上。客户在登录或者交易认证时候输入此动态密码，从而确保系统身份认证的安全性。具有以下优点：</p><ul><li>安全性</li></ul><p>​    由于手机与客户绑定比较紧密，短信密码生成与使用场景是物理隔绝的，因此密码在通路上被截取几率降至最低。</p><ul><li>普及性</li></ul><p>​    只要会接收短信即可使用，大大降低短信密码技术的使用门槛，学习成本几乎为0，所以在市场接受度上面不会存在阻力。</p><ul><li>易收费</li></ul><p>​    由于移动互联网用户天然养成了付费的习惯，这和PC时代互联网截然不同的理念，而且收费通道非常的发达，如果是网银、第三方支付、电子商务可将短信密码作为一项增值业务，每月通过SP收费不会有阻力，因此也可增加收益。</p><ul><li><p>易维护</p><p>   由于短信网关技术非常成熟，大大降低短信密码系统上马的复杂度和风险，短信密码业务后期客服成本低，稳定的系统在提升安全同时也营造良好的口碑效应，这也是银行也大量采纳这项技术很重要的原因。</p></li></ul><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>​    指纹，由于其具有终身不变性、唯一性和方便性，已几乎成为生物特征识别的代名词。随着硬件系统的不断更新换代，指纹识别技术已经普及。由于指纹的可靠性，众多应用将指纹识别作为主要的身份认证凭证，替代传统的输入密码，由于不存在数据的交换问题，极大的提高了安全性。指纹识别具有以下优点：</p><ul><li>指纹是人体独一无二的特征，并且它们的复杂度足以提供用于鉴别的足够特征；</li><li>如果要增加可靠性，只需登记更多的指纹、鉴别更多的手指，最多可以多达十个，而每一个指纹都是独一无二的；</li><li>扫描指纹的速度很快，使用非常方便；</li><li>读取指纹时，用户必需将手指与指纹采集头相互接触，与指纹采集头直接；</li><li>接触是读取人体生物特征最可靠的方法；</li></ul><h2 id="加密传输"><a href="#加密传输" class="headerlink" title="加密传输"></a>加密传输</h2><p>​    加密传输是指在客户端和服务端进行数据传输之前，对敏感数据进行加密，不进行明文传输。对于密码、个人信息等敏感信息进行加密算法加密。“对称”加密挑选AES，“非对称”加密选择RSA。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>​    AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES 使用几种不同的方法来执行排列和置换运算。<br>​    AES是一个迭代的、对称密钥分组的密码，它可以使用128、192 和 256 位密钥，并且用 128 位（16字    节）分组加密和解密数据。与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>​    RSA这种非对称加密算法，在App的使用当中，需要明白其主要作用有2个：</p><ul><li><strong>信息加密：</strong> 通信双方可以在公开的网络环境下，“安全”的商量对称加密算法所使用的密钥。</li><li><strong>电子签名：</strong> 为了防止中间人攻击，通信双方在商量密钥之前可以通过签名算法确认对方的身份。</li></ul><h2 id="安全组件"><a href="#安全组件" class="headerlink" title="安全组件"></a>安全组件</h2><h3 id="加密键盘"><a href="#加密键盘" class="headerlink" title="加密键盘"></a>加密键盘</h3><p>​    大部分中文应用弹出的默认键盘是简体中文输入法键盘，在输入用户名和密码的时候，如果使用简体中文输入法键盘，输入英文字符和数字字符的用户名和密码时，会自动启动系统输入法自动更正提示，然后用户的输入记录会被缓存下来。</p><p>​    所以客户端 app 输入密码时都不使用系统键盘，而使用自己定制的键盘，原因主要有 2 个：</p><ul><li>避免第三方读取系统键盘缓存</li><li>防止屏幕录制 （加密键盘按键不加按下效果）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/11/21/app-safety-design/app_logo.jpg&quot; alt=&quot;app_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;​    HTTP协议是没有加密的明文传输协议，&lt;strong&gt;如果APP采用HTTP传输数据，则会泄露传输内容，可能被中间人劫持，修改传输的内容&lt;/strong&gt;。劫持了HTTP通信，往APP的通信中加入了自己的推广内容，还有一些低俗的推广广告，这很影响用户体验。一些别有用心的人通过搭建公共WiFi，进行流量劫持、嗅探，可以获得通过HTTP传输的敏感信息。为了保护用户的信息安全、保护自己的商业利益，减少攻击面，需要保障通信信道的安全，采用开发方便的HTTPS无疑是最优方案。&lt;br&gt;​    &lt;strong&gt;HTTPS：&lt;/strong&gt;在http(超文本传输协议)基础上提出的一种安全的http协议，因此可以称为安全的超文本传输协议。http协议直接放置在TCP协议之上，而https提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。&lt;/p&gt;
&lt;p&gt;​    其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。&lt;br&gt;
    
    </summary>
    
    
      <category term="App" scheme="https://mah93.github.io/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>React Native简介</title>
    <link href="https://mah93.github.io/2017/11/15/react-native-introduce/"/>
    <id>https://mah93.github.io/2017/11/15/react-native-introduce/</id>
    <published>2017-11-15T02:26:05.000Z</published>
    <updated>2018-02-01T09:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/15/react-native-introduce/react-native_logo.jpg" alt="react-native_logo.jpg" title=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用React Native开发有一段时间了，想写一下有关的资料以便自己查阅，一下内容均来自于网络，如有侵犯联系我删除。<br>是Facebook发布的，可以让广大开发者使用JavaScript和React开发应用，提倡组件化开发，也就是说React Native提供了一个个封装好的组件让开发者来进行使用，甚至可以相关嵌套形成新的组件。<br>使用React Native开发者可以维护多种平台(Web,Android和IOS)的同一份业务逻辑核心代码来创建原生应用。<br>现阶段Web APP的的体验还是无法达到Native APP的体验，所以这边fackbook更加强调的是<strong>“learn once, write everywhere”</strong>，应用前端我们使用js和React来开发不同平台的UI，下层核心模块编写复用的业务逻辑代码，提供应用开发效率。</p><p>React Native的设计理念：<strong>既拥有Native的用户体验、又保留React的开发效率</strong>。</p><h2 id="React-Native背景"><a href="#React-Native背景" class="headerlink" title="React Native背景"></a>React Native背景</h2><ul><li>React 是由Facebook推出的一个JavaScript框架，主要用于前端开发。</li><li>React 采用组件化方式简化Web开发<ul><li>DOM:每个HTML界面可以看做一个DOM</li><li>原生的web开发方式，HTML一个文件，javaScript一个文件，文件分开，就会导致修改起来比较麻烦。</li><li>可以把一组相关的HTML标签和JavaScript单独封装到一个组件类中，便于复用，方便开发。</li></ul></li><li>React 可以高效的绘制界面<ul><li>原生的Web,刷新界面(DOM)，需要把整个界面刷新.</li><li>React只会刷新部分界面，不会整个界面刷新。</li><li>因为React独创了Virtual DOM机制。Virtual DOM是一个存在于内存中的JavaScript对象，它与DOM是一一对应的关系，当界面发送变化时，React会利用DOM Diff算法，把有变化的DOM进行刷新.</li></ul></li><li>React是采用JSX语法，一种JS语法糖，方便快速开发。</li></ul><a id="more"></a> <h2 id="常见的五种App开发模式"><a href="#常见的五种App开发模式" class="headerlink" title="常见的五种App开发模式"></a>常见的五种App开发模式</h2><h3 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h3><ul><li>Native App:指使用原生API开发App,比如iOS用OC语言开发</li><li>优点：性能高</li><li>缺点：开发维护成本高，养一个原生开发工程师需要很多钱，最重要iOS版本更新也成问题。</li></ul><h3 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h3><ul><li>Web App:指使用Html开发的移动端网页App,类似微信小程序，整个App都是网页。</li><li>优点：用户不需要安装，不会占用手机内存</li><li>缺点：用户体验不好，不能离线，必须联网</li></ul><h3 id="Hybrid-App（Cordova）"><a href="#Hybrid-App（Cordova）" class="headerlink" title="Hybrid App（Cordova）"></a>Hybrid App（Cordova）</h3><ul><li>Hybrid App:混合开发模式，原生Api+Html共同开发，比如iOS,用html写好界面，用UIWebView展示。</li><li>优点:界面复用性强，一个界面，iOS和安卓都可以使用</li><li>缺点:相对于原生，性能相对有所损害</li></ul><h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><ul><li>Weex:基于Vue(JS框架)的语法开发的App,底层会自动把JS代码解析成对应平台(iOS,安卓)的原生API，本质还是原生API开发，只不过表面是用Vue开发。</li><li>优点:可以做到一套代码，跨平台执行，底层会自动判断当前是哪个平台，转换为对应平台的原生API代码。</li><li>缺点：开源较晚，互联网上相关资料还比较少，社区规模较小</li></ul><h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><ul><li>React Native:基于React开发的App</li><li>优点：跳过App Store审核，远程更新代码，提高迭代频率和效率，既有Native的体验，又保留React的开发效率。</li><li>缺点:对于不熟悉前端开发的人员上手比较慢，不能真正意义上做到跨平台，使用后，对app体积增加。</li><li>相信大多数人了解完React Native，越来越困惑了，那不是跟Native冲突了吗，Native是用原生Api开发,但是React Native又是用React开发。</li></ul><h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><img src="/2017/11/15/react-native-introduce/react-native简单框架.png" alt="react-native简单框架.png" title=""><ol><li>React：不同平台上编写基于React的代码，“Learn once, write anywhere”。</li><li>Virtual DOM：相对Browser环境下的DOM（文档对象模型）而言，Virtual DOM是DOM在内存中的一种轻量级表达方式（原话是lightweight representation of the document），可以通过不同的渲染引擎生成不同平台下的UI，JS和Native之间通过Bridge通信。</li><li>iOS/Android。(Web得通过React Web)</li></ol><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><img src="/2017/11/15/react-native-introduce/react-native线程模型.png" alt="react-native线程模型.png" title=""><p>React Native应用中存在三个线程队列，它们工作的流程大概如下：UI Event Queue触发事件，通过Bridge调用JS代码在JS Event Queue中运行，JS运行后将视图更新分发给Native Module Event Queue中的线程,Native Module Event Queue负责计算，然后将最后的结果交给UI Event Queue中的线程去更新。 其中UI Event Queue为主线程。</p><h3 id="JavaScript对象和原生代码交互"><a href="#JavaScript对象和原生代码交互" class="headerlink" title="JavaScript对象和原生代码交互"></a>JavaScript对象和原生代码交互</h3><p>下图以JavaScript与Objective-C交互为例，大致描述交互过程。</p><img src="/2017/11/15/react-native-introduce/react-native底层交互.png" alt="react-native底层交互.png" title=""><p>1.JS端调用某个OC模块暴露出来的方法。</p><p>2.把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。</p><p>在初始化时模块配置表上的每一个模块都生成了对应的remoteModule对象，对象里也生成了跟模块配置表里一一对应的方法，这些方法里可以拿到自身的模块名，方法名，并对callback进行一些处理，再移交给MessageQueue。具体实现在BatchedBridgeFactory.js的<a href="https://github.com/facebook/react-native/blob/72d3d724a3a0c6bc46981efd0dad8f7f61121a47/Libraries/BatchedBridge/BatchingImplementation/BatchedBridgeFactory.js#L37" target="_blank" rel="external">_createBridgedModule</a>里，整个实现区区24行代码，感受下JS的魔力吧。</p><p>3.在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。</p><p>4.把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。至于具体是怎么传的，后面再说。</p><p>5.OC接收到消息，通过模块配置表拿到对应的模块和方法。</p><p>实际上模块配置表已经经过处理了，跟JS一样，在初始化时OC也对模块配置表上的每一个模块生成了对应的实例并缓存起来，模块上的每一个方法也都生成了对应的<a href="https://github.com/facebook/react-native/blob/72d3d724a3a0c6bc46981efd0dad8f7f61121a47/React/Base/RCTBridge.m#L111" target="_blank" rel="external">RCTModuleMethod</a>对象，这里通过ModuleID和MethodID取到对应的Module实例和RCTModuleMethod实例进行调用。具体实现在_handleRequestNumber:moduleID:methodID:params:。</p><p>6.RCTModuleMethod对JS传过来的每一个参数进行处理。</p><p>RCTModuleMethod可以拿到OC要调用的目标方法的每个参数类型，处理JS类型到目标类型的转换，所有JS传过来的数字都是NSNumber，这里会转成对应的int/long/double等类型，更重要的是会为block类型参数的生成一个block。</p><p>例如-(void)select:(int)index response:(RCTResponseSenderBlock)callback 这个方法，拿到两个参数的类型为int,block，JS传过来的两个参数类型是NSNumber,NSString(CallbackID)，这时会把NSNumber转为int，NSString(CallbackID)转为一个block，block的内容是把回调的值和CallbackID传回给JS。</p><p>这些参数组装完毕后，通过NSInvocation动态调用相应的OC模块方法。</p><p>7.OC模块方法调用完，执行block回调。</p><p>8.调用到第6步说明的RCTModuleMethod生成的block。</p><p>9.block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。</p><p>10.MessageQueue通过CallbackID找到相应的JS callback方法。</p><p>11.调用callback方法，并把OC带过来的参数一起传过去，完成回调。</p><p>整个流程就是这样，简单概括下，差不多就是：JS函数调用转ModuleID/MethodID -&gt; callback转CallbackID -&gt; OC根据ID拿到方法 -&gt; 处理参数 -&gt; 调用OC方法 -&gt; 回调CallbackID -&gt; JS通过CallbackID拿到callback执行</p><h2 id="JavaScript和本地代码间的通信"><a href="#JavaScript和本地代码间的通信" class="headerlink" title="JavaScript和本地代码间的通信"></a>JavaScript和本地代码间的通信</h2><img src="/2017/11/15/react-native-introduce/react-native本地通讯.png" alt="react-native本地通讯.png" title=""><p>其中通信的特点是：</p><ul><li>异步的</li><li>序列化的</li><li>批量的，对于大批量的通信事件可以将其分成几部分，减少时间延迟</li></ul><h2 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h2><p>在Javascript代码和原生平台之间的所有操作都是异步执行的，并且原生模块还可以根据需要创建新的线程。这意味着你可以在主线程解码图片，然后在后台将它保存到磁盘，或者在不阻塞UI的情况下计算文字大小和界面布局等等。所以React Native开发的app天然具备流畅和反应灵敏的优势。Javascript和原生代码之间的通讯是完全可序列化的，这使得我们可以借助Chrome开发者工具去调试应用，而不论应用运行在模拟器还是真机上。</p><img src="/2017/11/15/react-native-introduce/react-native调试.png" alt="react-native调试.png" title=""><h2 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h2><p>使用React Native，无需编写一行原生代码即可创造一款不错的app。尽管如此，使用自定义的原生视图和模块来扩展React Native也非常容易 —— 这意味着你现有的所有工作都可以被复用，你喜欢的各种原生库都可以被导入。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/11/15/react-native-introduce/react-native_logo.jpg&quot; alt=&quot;react-native_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用React Native开发有一段时间了，想写一下有关的资料以便自己查阅，一下内容均来自于网络，如有侵犯联系我删除。&lt;br&gt;是Facebook发布的，可以让广大开发者使用JavaScript和React开发应用，提倡组件化开发，也就是说React Native提供了一个个封装好的组件让开发者来进行使用，甚至可以相关嵌套形成新的组件。&lt;br&gt;使用React Native开发者可以维护多种平台(Web,Android和IOS)的同一份业务逻辑核心代码来创建原生应用。&lt;br&gt;现阶段Web APP的的体验还是无法达到Native APP的体验，所以这边fackbook更加强调的是&lt;strong&gt;“learn once, write everywhere”&lt;/strong&gt;，应用前端我们使用js和React来开发不同平台的UI，下层核心模块编写复用的业务逻辑代码，提供应用开发效率。&lt;/p&gt;
&lt;p&gt;React Native的设计理念：&lt;strong&gt;既拥有Native的用户体验、又保留React的开发效率&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;React-Native背景&quot;&gt;&lt;a href=&quot;#React-Native背景&quot; class=&quot;headerlink&quot; title=&quot;React Native背景&quot;&gt;&lt;/a&gt;React Native背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;React 是由Facebook推出的一个JavaScript框架，主要用于前端开发。&lt;/li&gt;
&lt;li&gt;React 采用组件化方式简化Web开发&lt;ul&gt;
&lt;li&gt;DOM:每个HTML界面可以看做一个DOM&lt;/li&gt;
&lt;li&gt;原生的web开发方式，HTML一个文件，javaScript一个文件，文件分开，就会导致修改起来比较麻烦。&lt;/li&gt;
&lt;li&gt;可以把一组相关的HTML标签和JavaScript单独封装到一个组件类中，便于复用，方便开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;React 可以高效的绘制界面&lt;ul&gt;
&lt;li&gt;原生的Web,刷新界面(DOM)，需要把整个界面刷新.&lt;/li&gt;
&lt;li&gt;React只会刷新部分界面，不会整个界面刷新。&lt;/li&gt;
&lt;li&gt;因为React独创了Virtual DOM机制。Virtual DOM是一个存在于内存中的JavaScript对象，它与DOM是一一对应的关系，当界面发送变化时，React会利用DOM Diff算法，把有变化的DOM进行刷新.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;React是采用JSX语法，一种JS语法糖，方便快速开发。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="https://mah93.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>学习Nginx小结</title>
    <link href="https://mah93.github.io/2017/11/03/nginx-introduce/"/>
    <id>https://mah93.github.io/2017/11/03/nginx-introduce/</id>
    <published>2017-11-03T05:29:52.000Z</published>
    <updated>2018-02-01T09:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/03/nginx-introduce/nginx_logo.png" alt="nginx_logo.png" title=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    <strong>Nginx</strong>是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 <strong>Nginx</strong> 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。 Igor 将源代码以类 BSD 许可证的形式发布。尽管还是测试版，但是，<strong>Nginx</strong> 已经因为它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名了。</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>​    <strong>Nginx</strong>提供邮件代理服务，主要包含以下功能：</p><ul><li>支持使用外部HTTP认证服务器重定向用户到IMAP／POP3后端，并支持IMAP认证方式和POP3认证方式。</li><li>支持使用HTTP认证服务器认证用户后重定向连接到内部SMTP后端，并支持SMTP认证方式。</li><li>支持邮件代理服务下的安全套接层安全协议SSL。</li><li>支持纯文本通信协议的扩展协议STARTTLS。</li></ul><h2 id="HTTP代理和反向代理"><a href="#HTTP代理和反向代理" class="headerlink" title="HTTP代理和反向代理"></a>HTTP代理和反向代理</h2><p>​    代理服务和反向代理服务是<strong>Nginx</strong>服务器作为Web服务器的主要功能之一，尤其是反向代理服务，是应用十分广泛的功能。</p><p>​    在提供反向代理服务方面，<strong>Nginx</strong>服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配置相当灵活。在进行<strong>Nginx</strong>服务器配置的时候，配置后端转发请求完全不用关心网络环境如何，可以指定任意IP地址和端口号，或者其他类型的链接、请求等。</p><a id="more"></a> <h3 id="Nginx作为反向代理的特点"><a href="#Nginx作为反向代理的特点" class="headerlink" title="Nginx作为反向代理的特点"></a><strong>Nginx作为反向代理的特点</strong></h3><ul><li>接收用户请求是异步的，即先将用户请求全部接收下来，再一次性发送后后端web服务器，极大的减轻后端web服务器的压力；</li><li><strong>Nginx</strong>代理和后端web服务器间无需长连接；</li><li>发送响应报文时，是边接收来自后端web服务器的数据，边发送给客户端的；</li><li>调度灵活。<strong>Nginx</strong>工作在网络协议栈的第七层，能够对HTTP应用请求进行解析和分流，支持比较复杂的正则规则，具有更优化的负载均衡效果。</li><li>网络依赖型低。<strong>Nginx</strong>对网络的依赖程度非常低，理论上讲，只要能够ping通就可以实施负载均衡，而且可以有效区分内网和外网流量。</li><li>支持服务器检测。<strong>Nginx</strong>能够根据应用服务器处理页面返回的状态码、超时信息等检测服务器是否出现故障，并及时返回错误的请求重新提交到其它节点上。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>​    客户端向<strong>Nginx</strong>发送请求，接着<strong>Nginx</strong>根据某种负载机制转发请求至目标服务器(这些服务器都运行着相同的应用)，并把获得的内容返回给客户端，期中，代理请求可能根据配置被发往不同的服务器。</p><img src="/2017/11/03/nginx-introduce/nginx负载均衡.png" alt="nginx" title="nginx"><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>由于服务器是ubuntu系统，这里仅展示在ubuntu系统下安装过程，其他操作系统可自行查找</p><p>登录服务器之后执行，下载nginx安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo wget http://nginx.org/download/nginx-1.2.2.tar.gz</div></pre></td></tr></table></figure><p>然后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo  tar -xzvf nginx-1.2.2.tar.gz</span></div></pre></td></tr></table></figure><p>进入解压之后的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> nginx-1.2.2</span></div><div class="line"><span class="meta">$</span><span class="bash"> ./configure</span></div></pre></td></tr></table></figure><p>如果一切顺利的话，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make</span></div><div class="line"><span class="meta">$</span><span class="bash"> make install</span></div></pre></td></tr></table></figure><p>完成安装，可以在/usr/local文件下找到nginx文件夹</p><p>然后访问服务器即可看到</p><p><strong>welcome nginx</strong></p><p>字样</p><h3 id="Nginx安装常见问题-ubuntu"><a href="#Nginx安装常见问题-ubuntu" class="headerlink" title="Nginx安装常见问题(ubuntu)"></a>Nginx安装常见问题(ubuntu)</h3><ul><li><h4 id="缺少pcre"><a href="#缺少pcre" class="headerlink" title="缺少pcre"></a>缺少pcre</h4><p>执行./configure之后，出现</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure: error: the HTTP rewrite <span class="keyword">module</span> requires the PCRE <span class="keyword">library</span>. You can either disable the <span class="keyword">module</span> <span class="keyword">by</span> <span class="keyword">using</span> --without-http_rewrite_module option, <span class="keyword">or</span> install the PCRE <span class="keyword">library</span> <span class="keyword">into</span> the system, <span class="keyword">or</span> build the PCRE <span class="keyword">library</span> statically <span class="keyword">from</span> the source <span class="keyword">with</span> nginx <span class="keyword">by</span> <span class="keyword">using</span> --<span class="keyword">with</span>-pcre=&lt;path&gt; option.</div></pre></td></tr></table></figure><p>即提示缺少pcre library    </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="builtin-name">get</span> undate</div><div class="line">$ sudo apt-<span class="builtin-name">get</span> install libpcre3 libpcre3-dev</div></pre></td></tr></table></figure></li><li><h4 id="缺少gcc-c-和libtool"><a href="#缺少gcc-c-和libtool" class="headerlink" title="缺少gcc-c++和libtool"></a>缺少gcc-c++和libtool</h4><p>执行./configure之后，出现</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">libtool: <span class="keyword">compile</span>: unrecognized option `-DHAVE_CONFIG_H' </div><div class="line">libtool: <span class="keyword">compile</span>: Try `libtool --help' <span class="keyword">for</span> more information. </div><div class="line"><span class="built_in">make</span>[<span class="number">1</span>]: *** [pcrecpp.lo] <span class="built_in">Error</span> <span class="number">1</span> </div><div class="line"><span class="built_in">make</span>[<span class="number">1</span>]: Leaving directory `/usr/<span class="keyword">local</span>/src<span class="comment">//pcre-8.31' </span></div><div class="line"><span class="built_in">make</span>: *** [all] <span class="built_in">Error</span> <span class="number">2</span>root<span class="comment">@wolfdog-virtual-machine:~/work/pcre-8.12$ libtool -help -DHAVE_CONFIG_H </span></div><div class="line"><span class="comment">The program 'libtool' is currently not installed.  You can install it by typing: </span></div><div class="line"><span class="comment">sudo apt-get install libtool</span></div></pre></td></tr></table></figure><p>即提示缺少libtool和gcc-c++</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="builtin-name">get</span> install libtool  </div><div class="line">$ sudo apt-<span class="builtin-name">get</span> install gcc-c++</div></pre></td></tr></table></figure></li><li><h4 id="缺少zlib库"><a href="#缺少zlib库" class="headerlink" title="缺少zlib库"></a>缺少zlib库</h4><p>执行./configure之后，出现</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure: error: <span class="keyword">the</span> HTTP gzip module requires <span class="keyword">the</span> zlib library. </div><div class="line">You can either disable <span class="keyword">the</span> module <span class="keyword">by</span> <span class="keyword">using</span> <span class="comment">--without-http_gzip_module </span></div><div class="line">option, <span class="keyword">or</span> install <span class="keyword">the</span> zlib library <span class="keyword">into</span> <span class="keyword">the</span> <span class="keyword">system</span>, <span class="keyword">or</span> build <span class="keyword">the</span> zlib library </div><div class="line">statically <span class="built_in">from</span> <span class="keyword">the</span> source <span class="keyword">with</span> nginx <span class="keyword">by</span> <span class="keyword">using</span> <span class="comment">--with-zlib=&lt;path&gt; option.</span></div></pre></td></tr></table></figure><p>其提示缺少zlib库</p><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="built_in">get</span> install openssl libssl-<span class="built_in">dev</span> libperl-<span class="built_in">dev</span></div></pre></td></tr></table></figure></li></ul><h3 id="Nginx安装常见问题-centos"><a href="#Nginx安装常见问题-centos" class="headerlink" title="Nginx安装常见问题(centos)"></a>Nginx安装常见问题(centos)</h3><p>在centos系统下如遇到以上问题，运行以下命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ yum <span class="keyword">install</span> gcc-c++</div><div class="line">$ yum <span class="keyword">install</span> -y pcre pcre-devel　　</div><div class="line">$ yum <span class="keyword">install</span> -y zlib zlib-devel</div><div class="line">$ yum <span class="keyword">install</span> -y openssl openssl-devel</div></pre></td></tr></table></figure><h2 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h2><h3 id="Nginx启动"><a href="#Nginx启动" class="headerlink" title="Nginx启动"></a>Nginx启动</h3><p>进入nginx安装目录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./sbin/nginx</div></pre></td></tr></table></figure><p>如果没有任何错误信息输出，则启动成功。也可以使用以下命令加载配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ./nginx/sbin/nginx -c ./nginx/conf/nginx.conf</span></div></pre></td></tr></table></figure><p>启动成功之后可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ps -ef|grep nginx</span></div></pre></td></tr></table></figure><p>来查看<strong>Nginx</strong>服务的进程状态。</p><h3 id="Nginx停止"><a href="#Nginx停止" class="headerlink" title="Nginx停止"></a>Nginx停止</h3><p>​    停止<strong>Nginx</strong>服务有两种方法：一种是快速停止，一种是平缓停止。快速停止是指立即停止当前<strong>Nginx</strong>服务正在处理的所有网络请求，马上丢弃连接，定制工作。平缓停止是指允许<strong>Nginx</strong>服务将当前正在处理的网络请求处理完成，并不再接受新的请求，之后关闭连接，停止工作。</p><p>​    停止<strong>Nginx</strong>服务的操作比较多，可以发送信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ./sbin/nginx -g TERM | INT | QUIT</span></div></pre></td></tr></table></figure><p>​    其中，TERM和INT信号用于快速停止，QUIT用于平缓停止。</p><p>​    或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> TERM | INT | QUIT `/nginx/logs/nginx.pid`</span></div></pre></td></tr></table></figure><p>​    当然也可以使用kill命令向<strong>Nginx</strong>进程发送-9或者SIGKILL信号强制关闭<strong>Nginx</strong>服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 | SIGKILL `/nginx/logs/nginx.pid`</span></div></pre></td></tr></table></figure><h3 id="Nginx重启"><a href="#Nginx重启" class="headerlink" title="Nginx重启"></a>Nginx重启</h3><p>​    以下命令实现<strong>Nginx</strong>平滑重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> HUP `/nginx/logs/nginx.pid`</span></div></pre></td></tr></table></figure><h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">`nginx.conf`</div><div class="line">user nobody    #指定用户群</div><div class="line">worker_processes#cpu核数／进程数</div><div class="line">#工作衍生数／核数<span class="number">*2</span></div><div class="line">error_log #错误日志存放地点</div><div class="line">pid#控制系统中重要文件</div><div class="line">events &#123;</div><div class="line">  worker_connections#最大连接数</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">  gzip#压缩传输</div><div class="line"> <span class="built_in"> server </span>&#123;#server块</div><div class="line">    <span class="built_in">..</span>.</div><div class="line">    location &#123;                       #location块</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>http块主要是配置代理、缓存和日志定义绝大多数功能和第三方模块配置。</li></ul><ul><li>server块配置虚拟主机。</li><li>location块对请求进行处理。</li></ul><h3 id="Nginx配置虚拟主机"><a href="#Nginx配置虚拟主机" class="headerlink" title="Nginx配置虚拟主机"></a>Nginx配置虚拟主机</h3><p>虚拟主机指的是server块对外提供的虚拟主机</p><ol><li><p>查看服务器的IP地址</p></li><li><p>绑定IP地址与虚拟主机</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ifconfig XXX:<span class="number">0</span> <span class="number">192.168</span><span class="selector-class">.X</span><span class="selector-class">.X</span> netmask XXX<span class="selector-class">.XXX</span><span class="selector-class">.XXX</span><span class="selector-class">.XXX</span> up</div><div class="line">$ ifconfig XXX:<span class="number">1</span> <span class="number">192.168</span><span class="selector-class">.X</span><span class="selector-class">.X</span>+<span class="number">1</span> netmask XXX<span class="selector-class">.XXX</span><span class="selector-class">.XXX</span><span class="selector-class">.XXX</span> up</div><div class="line">...</div></pre></td></tr></table></figure></li><li><p>虚拟主机的配置</p><p>虚拟主机的配置可以在nginx.conf下配置，但是不推荐。可以新建一个配置文件，配置好之后在nginx.conf下引用该文件即可。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ touch xxx.conf</div><div class="line">` 配置写在http中的server下 `</div><div class="line">server &#123;</div><div class="line">  listen: 192.168.X.X;#刚刚配置的虚拟主机IP，不指定端口的话默认80端口</div><div class="line">  server_name; #名称</div><div class="line">  access_log; #日志文件</div><div class="line">  location / &#123;</div><div class="line">    index html.index;#访问的首页</div><div class="line">    root html;#访问路径</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>对于网页请求的缓存配置在http下的server块中配置</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">local ~.*\.(jpg)&#123;</div><div class="line">  expires <span class="number">2</span>d;#设置图片<span class="number">2</span>天过期</div><div class="line">&#125;</div><div class="line">local ~.*\.(css|js)&#123;</div><div class="line">  expires <span class="number">1</span>h;#设置css文件和js文件<span class="number">1</span>小时过期</div><div class="line">&#125;</div><div class="line"></div><div class="line">`压缩配置`</div><div class="line">#gzip on;#开启gzip压缩</div><div class="line">#gzip_min_length <span class="number">1</span>k;#小于<span class="number">1</span>k不进行压缩</div><div class="line">#gzip_buffers <span class="number">4</span> <span class="number">16</span>k;#申请内存大小（<span class="number">4</span>个<span class="number">16</span>k）</div><div class="line">#gzip_http_version <span class="number">1.1</span>;#识别版本</div><div class="line">#gzip_vary on;#判断客户端浏览器是否支持gzip压缩</div></pre></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><ul><li>Nginx的日志文件在http块中配置</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#log_format#日志文件格式配置</div><div class="line">`在http配置`</div><div class="line">#remote_addr#客户端IP地址</div><div class="line">#remote_user#客户端用户名</div><div class="line">#request#请求地址</div><div class="line">#status#请求状态</div><div class="line">#body_bytes_sent#向用户发送字节数</div><div class="line">#http_refer#原网页（从哪里访问）</div><div class="line">#http_user_agent#客户浏览器信息</div><div class="line">#http_x_forword_for#客户端IP地址</div><div class="line">`日志文件存储路径`</div><div class="line">#access_logxx/xx/xx#存放路径</div><div class="line">#access_off#关闭日志文件记录</div></pre></td></tr></table></figure><ul><li>日志文件切割（手动切割）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mv access.log 20160708.log<span class="comment">#移动</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> -USR | 进程号  <span class="comment">#切割日志</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> ps -ef | grep nginx<span class="comment">#nginx进程号</span></span></div></pre></td></tr></table></figure><p>总体的流程是：先备份老的日志文件，之后再切割</p><ul><li>自动切割日志文件</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ crontab + 批处理   定时每天操作</div><div class="line"><span class="string">`新建批处理文件`</span></div><div class="line">$ touch cutlog.sh</div><div class="line">$ vi cutlog.sh</div><div class="line"></div><div class="line">D=$(<span class="built_in">date</span>+%Y%M%d)</div><div class="line">mv /user/<span class="built_in">local</span>/nginx/logs/access.<span class="keyword">log</span> &#123;D&#125;.<span class="keyword">log</span></div><div class="line">kill <span class="params">-USR</span> | (cat /user/<span class="built_in">local</span>/nginx/nginx.pid)</div><div class="line"></div><div class="line"><span class="string">`定时处理批处理`</span></div><div class="line">#crontab <span class="params">-e</span> <span class="number">23</span> <span class="number">59</span> *** /bin/bash /user/<span class="built_in">local</span>/nginx/logs/cutlog.sh</div></pre></td></tr></table></figure><h2 id="Nginx卸载"><a href="#Nginx卸载" class="headerlink" title="Nginx卸载"></a>Nginx卸载</h2><p>由于服务器是ubuntu系统，这里仅展示在ubuntu系统下安装过程，其他操作系统可自行查找。</p><p>仍然使用apt-get命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ apt-<span class="builtin-name">get</span> purge nginx</div><div class="line">$ apt-<span class="builtin-name">get</span> autoremove</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/11/03/nginx-introduce/nginx_logo.png&quot; alt=&quot;nginx_logo.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;Nginx&lt;/strong&gt;是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 &lt;strong&gt;Nginx&lt;/strong&gt; 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。 Igor 将源代码以类 BSD 许可证的形式发布。尽管还是测试版，但是，&lt;strong&gt;Nginx&lt;/strong&gt; 已经因为它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名了。&lt;/p&gt;
&lt;h2 id=&quot;代理服务器&quot;&gt;&lt;a href=&quot;#代理服务器&quot; class=&quot;headerlink&quot; title=&quot;代理服务器&quot;&gt;&lt;/a&gt;代理服务器&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;Nginx&lt;/strong&gt;提供邮件代理服务，主要包含以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持使用外部HTTP认证服务器重定向用户到IMAP／POP3后端，并支持IMAP认证方式和POP3认证方式。&lt;/li&gt;
&lt;li&gt;支持使用HTTP认证服务器认证用户后重定向连接到内部SMTP后端，并支持SMTP认证方式。&lt;/li&gt;
&lt;li&gt;支持邮件代理服务下的安全套接层安全协议SSL。&lt;/li&gt;
&lt;li&gt;支持纯文本通信协议的扩展协议STARTTLS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HTTP代理和反向代理&quot;&gt;&lt;a href=&quot;#HTTP代理和反向代理&quot; class=&quot;headerlink&quot; title=&quot;HTTP代理和反向代理&quot;&gt;&lt;/a&gt;HTTP代理和反向代理&lt;/h2&gt;&lt;p&gt;​    代理服务和反向代理服务是&lt;strong&gt;Nginx&lt;/strong&gt;服务器作为Web服务器的主要功能之一，尤其是反向代理服务，是应用十分广泛的功能。&lt;/p&gt;
&lt;p&gt;​    在提供反向代理服务方面，&lt;strong&gt;Nginx&lt;/strong&gt;服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配置相当灵活。在进行&lt;strong&gt;Nginx&lt;/strong&gt;服务器配置的时候，配置后端转发请求完全不用关心网络环境如何，可以指定任意IP地址和端口号，或者其他类型的链接、请求等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://mah93.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Dva最不佳实践</title>
    <link href="https://mah93.github.io/2017/10/30/dva-learning/"/>
    <id>https://mah93.github.io/2017/10/30/dva-learning/</id>
    <published>2017-10-30T13:50:36.000Z</published>
    <updated>2018-02-01T09:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/10/30/dva-learning/dva_logo3.png" alt="dva_logo3.png" title=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于之前写了几个dva的项目，近期没怎么用有些遗忘了，写个小结记录一下。</p><p>dva是基于react、react-router、redux封装的一个轻框架。详细的介绍在 <a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva官网</a>，这里仅仅摘录部分。项目托管在GitHub上，<a href="https://github.com/mah93/dva-learning" target="_blank" rel="external">点击这里</a>。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>易学易用</strong>：仅有 6 个 api，对 redux 用户尤其友好</li><li><strong>elm 概念</strong>：通过 <code>reducers</code>, <code>effects</code> 和 <code>subscriptions</code> 组织 model</li><li><strong>支持 mobile 和 react-native</strong>：跨平台 (<a href="https://github.com/sorrycc/dva-example-react-native" target="_blank" rel="external">react-native 例子</a>)</li><li><strong>支持 HMR</strong>：目前基于 <a href="https://github.com/dvajs/babel-plugin-dva-hmr" target="_blank" rel="external">babel-plugin-dva-hmr</a> 支持 components、routes 和 models 的 HMR</li><li><strong>动态加载 Model 和路由</strong>：按需加载加快访问速度 (<a href="https://github.com/dvajs/dva/blob/master/packages/dva-example-user-dashboard/src/router.js" target="_blank" rel="external">例子</a>)</li><li><strong>插件机制</strong>：比如 <a href="https://github.com/dvajs/dva-loading" target="_blank" rel="external">dva-loading</a> 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading</li><li><strong>完善的语法分析库 dva-ast</strong>：<a href="https://github.com/dvajs/dva-cli" target="_blank" rel="external">dva-cli</a> 基于此实现了智能创建 model, router 等</li><li><strong>支持 TypeScript</strong>：通过 d.ts (<a href="https://github.com/sorrycc/dva-boilerplate-typescript" target="_blank" rel="external">例子</a>)</li></ul><a id="more"></a> <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>确保 node 版本是 6.5 +</li><li>用 <a href="https://github.com/cnpm/cnpm" target="_blank" rel="external">cnpm</a> 或 <a href="https://github.com/yarnpkg/yarn" target="_blank" rel="external">yarn</a> 能节约你安装依赖的时间</li></ul><h2 id="Step1-安装-dva-cli-并创建应用"><a href="#Step1-安装-dva-cli-并创建应用" class="headerlink" title="Step1. 安装 dva-cli 并创建应用"></a>Step1. 安装 <a href="https://github.com/dvajs/dva-cli" target="_blank" rel="external">dva-cli</a> 并创建应用</h2><p>先安装 dva-cli，并确保版本是 0.7.x。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm i dva-<span class="symbol">cli@</span><span class="number">0.7</span> -g</div><div class="line">$ dva -v</div><div class="line"><span class="number">0.7</span><span class="number">.0</span></div></pre></td></tr></table></figure><p>然后创建应用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dva <span class="keyword">new</span> <span class="type">dva</span>-learning</div></pre></td></tr></table></figure><p>创建成功后进入该文件夹：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cd</span> dva-learning </div><div class="line">`项目的目录结构`</div><div class="line">dva_learning</div><div class="line">|<span class="params">-----mock</span><span class="comment"># =&gt; 前端模拟数据</span></div><div class="line">|<span class="params">-----node_modules</span><span class="comment"># =&gt; 项目依赖采用npm管理，所有包均在此目录。</span></div><div class="line">|<span class="params">-----public</span><span class="comment"># =&gt; 存放index.html</span></div><div class="line">|<span class="params">-----src</span></div><div class="line">   |<span class="params">------assets</span><span class="comment"># =&gt; 项目静态资源文件夹（图片等）</span></div><div class="line">   |<span class="params">------components</span><span class="comment"># =&gt; 无状态组件文件夹</span></div><div class="line">   |<span class="params">------models</span><span class="comment"># =&gt; 状态model文件夹</span></div><div class="line">   |<span class="params">------routes</span><span class="comment"># =&gt; 路由配置文件夹，页面存放在该文件夹下</span></div><div class="line">   |<span class="params">------services</span><span class="comment"># =&gt; 服务层文件夹</span></div><div class="line">   |<span class="params">------utils</span><span class="comment"># =&gt; 工具函数文件夹</span></div><div class="line">   |<span class="params">------index</span>.css<span class="comment"># =&gt; 全局通用样式</span></div><div class="line">   |<span class="params">------index</span>.js<span class="comment"># =&gt; 单页引用入口js，dva项目初始化</span></div><div class="line">   |<span class="params">------router</span>.js<span class="comment"># =&gt; 全局路由状态管理文件</span></div><div class="line">|<span class="params">-----package</span>.json<span class="comment"># =&gt; npm包管理文件</span></div><div class="line">|<span class="params">-----</span><span class="string">.eslintrc</span><span class="comment"># =&gt; 代码规范配置文件</span></div><div class="line">|<span class="params">-----</span><span class="string">.roadhogrc</span><span class="comment"># =&gt; 打包配置文件</span></div><div class="line">|<span class="params">-----</span><span class="string">.roadhogrc.mock.js</span><span class="comment"># =&gt; 模拟数据配置文件</span></div><div class="line">|<span class="params">-----README</span>.md</div><div class="line">`项目的目录结构`</div><div class="line">`运行项目`</div><div class="line">$ npm start</div></pre></td></tr></table></figure><p>如果运行成功的话，浏览器会自动弹出并访问8000端口，看到如下画面：</p><img src="/2017/10/30/dva-learning/run_success@2x.png" alt="run-success" title="run-success"><h2 id="Step2-配置-antd-和-babel-plugin-import"><a href="#Step2-配置-antd-和-babel-plugin-import" class="headerlink" title="Step2. 配置 antd 和 babel-plugin-import"></a>Step2. 配置 <a href="https://github.com/ant-design/ant-design" target="_blank" rel="external">antd</a> 和 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="external">babel-plugin-import</a></h2><p>antd是由蚂蚁金服开发的一套UI组件，具有学习成本低、上手速度快、实现效果好的特点。十分适合初学者并且与dva无缝接入。如需了解更多请查看 <a href="https://ant.design/index-cn" target="_blank" rel="external">ANT DESIGN</a>。</p><p>babel-plugin-import 用于按需引入 antd 的 JavaScript 和 CSS，这样打包出来的文件不至于太大。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm i antd <span class="comment">--save</span></div><div class="line">$ npm i babel-plugin-<span class="keyword">import</span> <span class="comment">--save-dev</span></div></pre></td></tr></table></figure><p>修改 <code>.roadhogrc</code>，在 <code>&quot;extraBabelPlugins&quot;</code> 里加上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;]</div></pre></td></tr></table></figure><h2 id="Step3-添加新页面"><a href="#Step3-添加新页面" class="headerlink" title="Step3. 添加新页面"></a>Step3. 添加新页面</h2><p>我们的目标是写一个登录的界面，成功之后显示dva默认的首页。所以在src/routes文件夹下，新建Login.js和Login.css文件。js文件用来写组件布局，css文件用来写样式，默认为js文件和css文件一一对应。</p><p>在Login.js中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">`<span class="keyword">Login</span>.js`</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; <span class="keyword">connect</span> &#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</div><div class="line"><span class="keyword">import</span> &#123; <span class="keyword">Input</span>, Icon, Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</div><div class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Login.css'</span>;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="keyword">Login</span>() &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div className=&#123;styles.inputDiv&#125;&gt;</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;<span class="keyword">Input</span></div><div class="line">          placeholder="用户名"</div><div class="line">          prefix=&#123;&lt;Icon <span class="keyword">type</span>="user" /&gt;&#125;</div><div class="line">          size="large"</div><div class="line">          className=&#123;styles.inputUser&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;<span class="keyword">Input</span></div><div class="line">          placeholder="密码"</div><div class="line">          prefix=&#123;&lt;Icon <span class="keyword">type</span>="lock" /&gt;&#125;</div><div class="line">          size="large"</div><div class="line">          className=&#123;styles.inputPass&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;Button <span class="keyword">type</span>="primary" className=&#123;styles.button&#125;&gt;</div><div class="line">          登录</div><div class="line">      &lt;/Button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">Login</span>.propTypes = &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export <span class="keyword">default</span> <span class="keyword">connect</span>()(<span class="keyword">Login</span>);</div></pre></td></tr></table></figure><p>为这个页面添加样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">`<span class="selector-tag">Login</span><span class="selector-class">.css</span>`</div><div class="line"><span class="selector-class">.inputDiv</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">220px</span>;</div><div class="line">  <span class="attribute">margin</span>: -<span class="number">110px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.inputUser</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.inputPass</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后修改router.js页面，将新写的登录页面，放到默认显示页面</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">`router.js`</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Router, Route &#125; <span class="keyword">from</span> <span class="string">'dva/router'</span>;</div><div class="line"><span class="keyword">import</span> IndexPage <span class="keyword">from</span> <span class="string">'./routes/IndexPage'</span>;</div><div class="line"><span class="keyword">import</span> <span class="keyword">Login</span> <span class="keyword">from</span> <span class="string">'./routes/Login'</span>;</div><div class="line"></div><div class="line"><span class="keyword">function</span> RouterConfig(&#123; history &#125;) &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;Router history=&#123;history&#125;&gt;</div><div class="line">      &lt;Route <span class="type">path</span>="/" component=&#123;<span class="keyword">Login</span>&#125; /&gt;</div><div class="line">      &lt;Route <span class="type">path</span>="/home" component=&#123;IndexPage&#125; /&gt;</div><div class="line">    &lt;/Router&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">export <span class="keyword">default</span> RouterConfig;</div></pre></td></tr></table></figure><p>然后运行，会看到你完成的页面</p><img src="/2017/10/30/dva-learning/dva登录@2x.png" alt="dva-login" title="dva-login"><h2 id="Step4-添加事件"><a href="#Step4-添加事件" class="headerlink" title="Step4. 添加事件"></a>Step4. 添加事件</h2><p>之前完成的页面还没有添加点击事件，接下来添加几行代码，让它可以编辑，可以输入和点击</p><p>页面中使用的Input, Icon, Button均是Antd中基本的组件，在 <a href="https://ant.design/index-cn" target="_blank" rel="external">ANT DESIGN</a>有对它们详细的介绍。</p><p>为Button添加一个单击事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">`点击button时触发`</span></div><div class="line"><span class="keyword">const</span> submit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  alert(<span class="string">'here'</span>)</div><div class="line">&#125;;</div><div class="line"><span class="string">`在Button中添加这个方法`</span></div><div class="line">&lt;Button <span class="keyword">type</span>=<span class="string">"primary"</span> className=&#123;styles.button&#125; onClick=&#123;submit&#125;&gt;</div><div class="line">登录</div><div class="line">&lt;<span class="regexp">/Button&gt;</span></div></pre></td></tr></table></figure><p>再次运行项目，点击登录按钮会显示</p><img src="/2017/10/30/dva-learning/dva单击事件@2x.png" alt="dva-click" title="dva-click"><h2 id="Step-5-处理逻辑"><a href="#Step-5-处理逻辑" class="headerlink" title="Step.5 处理逻辑"></a>Step.5 处理逻辑</h2><p>如果需要这个登录界面更加真实的话，需要处理一些登录中的逻辑，比如点击登录按钮的时候，判断输入框中是否输入了数据等。</p><p>dva中有专门的文件夹存放这些处理页面内逻辑的代码。查看src/models/example.js文件，这是一个标准的模版，每个处理逻辑的文件都包含下面几部分</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> &#123;</div><div class="line"></div><div class="line">  namespace: 'example',<span class="comment"># =&gt; 唯一标识，应用中唯一</span></div><div class="line"></div><div class="line">  <span class="keyword">state</span>: &#123;&#125;,<span class="comment"># =&gt; 需要存储的值，每次修改会刷新界面</span></div><div class="line"></div><div class="line">  subscriptions: &#123;<span class="comment"># =&gt; 订阅</span></div><div class="line">    setup(&#123; dispatch, history &#125;) &#123;  </div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  effects: &#123;<span class="comment"># =&gt; 副作用，一般用来发起请求</span></div><div class="line">    *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;  </div><div class="line">      yield put(&#123; type: 'save' &#125;);</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  reducers: &#123;<span class="comment"># =&gt; 只有在这里才能修改state的值</span></div><div class="line">    save(<span class="keyword">state</span>, action) &#123;</div><div class="line">      return &#123; ...<span class="keyword">state</span>, ...action.payload &#125;;</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>更多关于dva的api，请查看<a href="https://github.com/dvajs/dva/blob/master/docs/API.md" target="_blank" rel="external">dva APIs</a></p><p>在src/models中新建login.js文件</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">`login.js`</div><div class="line">export <span class="keyword">default</span> &#123;</div><div class="line"></div><div class="line">  namespace: 'login',</div><div class="line"></div><div class="line">  <span class="keyword">state</span>: &#123;</div><div class="line">    loading: false,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  subscriptions: &#123;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  effects: &#123;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  reducers: &#123;</div><div class="line">    save(<span class="keyword">state</span>, action) &#123;</div><div class="line">      return &#123; ...<span class="keyword">state</span>, ...action.payload &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后在Login.js中调用save方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="string">`Login.js`</span></div><div class="line"><span class="keyword">const</span> userName = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">  dispatch(&#123;</div><div class="line">    <span class="keyword">type</span>: <span class="string">'login/save'</span>,</div><div class="line">    payload: &#123;</div><div class="line">      user: e.target.value,</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个方法的意思是：当输入用户名的时候，调用save方法，并将输入的值，保存在state.user中。</p><h2 id="Step-6-发送请求"><a href="#Step-6-发送请求" class="headerlink" title="Step.6 发送请求"></a>Step.6 发送请求</h2><p>输入完用户名以及密码之后，单击登录按钮，将输入的值发送至后台校验，校验通过之后跳转到下一个页面。</p><p>现在已经有了输入的用户名和密码，分别是login.user和login.password，现在需要将这两个数据发送到后台。由于现在并没有后台服务支持，dva支持mock数据，所以先在前台模拟一个后台服务。</p><p>在项目根目录下新建.roadhogrc.mock.js并添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">`.roadhogrc.mock.js`</span></div><div class="line"><span class="keyword">const</span> mock = &#123;&#125;</div><div class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readdirSync(<span class="built_in">require</span>(<span class="string">'path'</span>).join(__dirname + <span class="string">'/mock'</span>)).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.assign(mock, <span class="built_in">require</span>(<span class="string">'./mock/'</span> + file))</div><div class="line">&#125;)</div><div class="line"><span class="built_in">module</span>.exports = mock</div></pre></td></tr></table></figure><p>之后在mock文件夹中新建login.js并添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">`login.js`</span></div><div class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="string">'POST /login'</span> (req, res) &#123;</div><div class="line">    <span class="built_in">console</span>.log(req.body);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'接受到请求'</span>);</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>res.json(&#123;<span class="attr">code</span>:<span class="string">'200'</span>,<span class="attr">message</span>:<span class="string">'从mock/example.js请求成功'</span>&#125;),<span class="number">2000</span>)</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个的意思是说，监听本地的8000端口，当访问<a href="http://localhost:8000/login的时候，会延迟2秒并返回数据。" target="_blank" rel="external">http://localhost:8000/login的时候，会延迟2秒并返回数据。</a></p><p>模拟的后台服务已经完成，现在要在button中添加点击事件，去请求这个接口。</p><p>首先改造一下fetch请求，在utils/request.js中：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(</span>url, <span class="function"><span class="keyword">method</span>, <span class="title">params</span>) &#123;</span></div><div class="line">  <span class="keyword">if</span> (<span class="function"><span class="keyword">method</span> =</span>== <span class="comment">'POST') &#123;</span></div><div class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key in params) &#123;</div><div class="line">      <span class="keyword">if</span> (params[key] != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">const</span> value = params[key];</div><div class="line">        formData.append(key, value);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fetch(url, &#123;</div><div class="line">      <span class="function"><span class="keyword">method</span>:</span> <span class="function"><span class="keyword">method</span>,</span></div><div class="line">      body: formData,</div><div class="line">    &#125;).<span class="keyword">then</span>(checkStatus)</div><div class="line">      .<span class="keyword">then</span>(parseJSON)</div><div class="line">      .<span class="keyword">then</span>(data =&gt; (&#123; data &#125;))</div><div class="line">      .<span class="keyword">catch</span>(err =&gt; (&#123; err &#125;));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="function"><span class="keyword">method</span> =</span>== <span class="comment">'GET') &#123;</span></div><div class="line">    <span class="keyword">return</span> fetch(url)</div><div class="line">      .<span class="keyword">then</span>(checkStatus)</div><div class="line">      .<span class="keyword">then</span>(parseJSON)</div><div class="line">      .<span class="keyword">then</span>(data =&gt; (&#123; data &#125;))</div><div class="line">      .<span class="keyword">catch</span>(err =&gt; (&#123; err &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在services中新建login.js，这里可以理解为转发，从点击事件中传递到request里请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'../utils/request'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'services处理'</span>);</div><div class="line">  <span class="keyword">return</span> request(<span class="string">'/login'</span>, <span class="string">'POST'</span>, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后在models/login.js，发起这个请求：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">effects: &#123;</div><div class="line">  *<span class="keyword">fetch</span>(&#123; payload &#125;, &#123; <span class="keyword">call</span>, put &#125;) &#123;  // eslint-<span class="keyword">disable</span>-<span class="type">line</span></div><div class="line">    <span class="keyword">if</span>(!payload.userName || !payload.<span class="keyword">passWord</span>) &#123;</div><div class="line">      message.error(<span class="string">'请输入账号密码'</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    const &#123; data &#125; = yield <span class="keyword">call</span>(service.<span class="keyword">login</span>, payload);</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>最后在界面的button的点击事件中，调用models里的事件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const submit = () =&gt; &#123;</div><div class="line">  dispatch(&#123;</div><div class="line">    <span class="keyword">type</span>: <span class="string">'login/fetch'</span>,</div><div class="line">    payload: &#123;</div><div class="line">      userName: <span class="keyword">login</span>.<span class="keyword">user</span>,</div><div class="line">      <span class="keyword">passWord</span>: <span class="keyword">login</span>.<span class="keyword">password</span>,</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>所有的都完成之后，重启项目，点击button之后可以在命令行中看到：</p><img src="/2017/10/30/dva-learning/dva的mock@2x.png" alt="dva-mock" title="dva-mock"><p>undefined的原因是，roadhog的版本问题，获取不到从前台传递过来的参数。</p><h2 id="Step-7-完善细节"><a href="#Step-7-完善细节" class="headerlink" title="Step.7 完善细节"></a>Step.7 完善细节</h2><p>整体的流程已经完成，现在要为它添加一些细节，让它看起来更加的真实</p><p>添加一个加载等待的圈圈，在点击button的同时显示，后台反馈结果后消失并跳转到下一个界面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">spinning</span>=<span class="string">&#123;login.loading&#125;</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">Spin</span>&gt;</span></div></pre></td></tr></table></figure><p>用Spin标签将其他的标签包起来，当它显示的时候，会出现在被包裹的标签之上。</p><p>通过控制login.loading来控制Spin的显示与消失。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> reducers: &#123;</div><div class="line">...</div><div class="line">   loadingShow(<span class="keyword">state</span>) &#123;</div><div class="line">     return &#123; ...<span class="keyword">state</span>, loading: true&#125;;</div><div class="line">   &#125;,</div><div class="line">   loadingHide(<span class="keyword">state</span>) &#123;</div><div class="line">     return &#123; ...<span class="keyword">state</span>, loading: false&#125;;</div><div class="line">   &#125;</div><div class="line"> &#125;,</div></pre></td></tr></table></figure><p> 最后在请求的时候完成这个流程</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">effects: &#123;</div><div class="line">  <span class="meta">*fetch(</span>&#123; payload &#125;, &#123; <span class="meta">call</span>, <span class="meta">put</span> &#125;) &#123; </div><div class="line">    <span class="meta">if</span>(!payload.userName || !payload.passWord) &#123;</div><div class="line">      <span class="meta">message</span>.<span class="meta">error</span>(<span class="string">'请输入账号密码'</span>);</div><div class="line">      <span class="meta">return</span>;</div><div class="line">    &#125;</div><div class="line">    yield<span class="meta"> put(</span>&#123; type: <span class="string">'loadingShow'</span> &#125;);</div><div class="line">    const &#123; data &#125; = yield <span class="meta">call</span>(service.login, payload);</div><div class="line">    <span class="meta">if</span>(data.code === <span class="string">'200'</span>) &#123;</div><div class="line">      yield<span class="meta"> put(</span>&#123; type: <span class="string">'loadingHide'</span> &#125;);</div><div class="line">      browserHistory.push(<span class="string">'/home'</span>);</div><div class="line">    &#125;<span class="meta">else</span> &#123;</div><div class="line">      yield<span class="meta"> put(</span>&#123; type: <span class="string">'loadingHide'</span> &#125;);</div><div class="line">      <span class="meta">message</span>.<span class="meta">error</span>(<span class="string">'登录失败'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>如果需要在显示登录页面之前执行某些操作，可以在subscriptions中订阅：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">subscriptions: &#123;</div><div class="line">  setup(&#123; dispatch, history &#125;) &#123;</div><div class="line">    history.<span class="keyword">listen</span>((<span class="keyword">location</span>) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">location</span>.pathname === <span class="string">'/'</span>) &#123;</div><div class="line">        message.<span class="keyword">info</span>(<span class="string">'进入了登录页'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个登录页面，展示了从页面到请求的整个过程，虽然看起来有点绕，涉及了很多的页面。但是当文件多了，就会体现出dva这样分层的好处：各个文件夹各司其职，功能单一。</p><p>最后实现的效果：</p><img src="/2017/10/30/dva-learning/dva-learning.gif" alt="finish" title="finish">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/10/30/dva-learning/dva_logo3.png&quot; alt=&quot;dva_logo3.png&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于之前写了几个dva的项目，近期没怎么用有些遗忘了，写个小结记录一下。&lt;/p&gt;
&lt;p&gt;dva是基于react、react-router、redux封装的一个轻框架。详细的介绍在 &lt;a href=&quot;https://github.com/dvajs/dva&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dva官网&lt;/a&gt;，这里仅仅摘录部分。项目托管在GitHub上，&lt;a href=&quot;https://github.com/mah93/dva-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;易学易用&lt;/strong&gt;：仅有 6 个 api，对 redux 用户尤其友好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;elm 概念&lt;/strong&gt;：通过 &lt;code&gt;reducers&lt;/code&gt;, &lt;code&gt;effects&lt;/code&gt; 和 &lt;code&gt;subscriptions&lt;/code&gt; 组织 model&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 mobile 和 react-native&lt;/strong&gt;：跨平台 (&lt;a href=&quot;https://github.com/sorrycc/dva-example-react-native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native 例子&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 HMR&lt;/strong&gt;：目前基于 &lt;a href=&quot;https://github.com/dvajs/babel-plugin-dva-hmr&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;babel-plugin-dva-hmr&lt;/a&gt; 支持 components、routes 和 models 的 HMR&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态加载 Model 和路由&lt;/strong&gt;：按需加载加快访问速度 (&lt;a href=&quot;https://github.com/dvajs/dva/blob/master/packages/dva-example-user-dashboard/src/router.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件机制&lt;/strong&gt;：比如 &lt;a href=&quot;https://github.com/dvajs/dva-loading&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dva-loading&lt;/a&gt; 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完善的语法分析库 dva-ast&lt;/strong&gt;：&lt;a href=&quot;https://github.com/dvajs/dva-cli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dva-cli&lt;/a&gt; 基于此实现了智能创建 model, router 等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 TypeScript&lt;/strong&gt;：通过 d.ts (&lt;a href=&quot;https://github.com/sorrycc/dva-boilerplate-typescript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
      <category term="Dva" scheme="https://mah93.github.io/tags/Dva/"/>
    
  </entry>
  
  <entry>
    <title>App开发模式简介</title>
    <link href="https://mah93.github.io/2017/10/19/app-develop-mode/"/>
    <id>https://mah93.github.io/2017/10/19/app-develop-mode/</id>
    <published>2017-10-19T13:16:49.000Z</published>
    <updated>2018-02-01T10:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/10/19/app-develop-mode/app-develop_logo.jpg" alt="app-develop_logo.jpg" title=""><p>对于手机app来说，近几年有以下几种开发模式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Native App</th><th style="text-align:center">Web App</th><th style="text-align:center">Cordova</th><th style="text-align:center">Weex</th><th style="text-align:center">React Native</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:center">性能高</td><td style="text-align:center">无需安装</td><td style="text-align:center">界面复用性强</td><td style="text-align:center">跨平台执行</td><td style="text-align:center">跨平台执行</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">开发维护成本高</td><td style="text-align:center">用户体验不好</td><td style="text-align:center">性能差</td><td style="text-align:center">开源较晚</td><td style="text-align:center">学习曲线高</td></tr><tr><td style="text-align:center">技术</td><td style="text-align:center">oc、swift、java</td><td style="text-align:center">html、js</td><td style="text-align:center">html、js</td><td style="text-align:center">vue.js</td><td style="text-align:center">react.js</td></tr></tbody></table><h2 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h2><p>原生开发是系统自带的app开发方式，也是大部分人最熟悉app开发的技术，如android、ios、wp。是开发者采用最广泛的开发方式，优点十分显著。相比其他开发方式而言，原生开发可以访问设备中的所有功能，运行速度更快，性能更高，而且可以启用优秀的离线处理和存储能力等等，提供最佳的用户体验，最优质的用户界面，最华丽的交互。原生开发人员众多，开发环境成熟，有许多的开源库提供开发人员调用，可是方便实现各种设计效果。<br><a id="more"></a><br>​原生开发的缺点在逐渐的开发、运营过程中显现出来。开发成本高，不同平台需要定制不同的app，也就是android定制apk，ios定制app，开发人员需要多平台多语言，人力成本、时间成本较多，通用性差；上线时间不稳定，需要审核，特别是苹果审核机制，审核时间长短不一，对内容还有控制，国内Android APP市场（百度手机助手，应用宝，360市场等等）也有类似的问题；版本控制能力差，版本发布到达率无法控制，多个版本更新发布，修复bug，无法保证及时送达到用户手中；获得新版本需要重新下载安装，虽然目前有增量升级方式逐渐改变，但是随之而来的其他问题如增量升级多版本控制也是个很头疼的问题。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供最佳的用户体验，最优质的用户界面，最华丽的交互效果</li><li>针对不同平台提供不同体验</li><li>可访问手机的所有功能</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>开发成本较高</li><li>范围限制多</li><li>未知的部署时间（应用商店审核时间）</li><li>内容限制</li></ul><h2 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h2><p>​    Web无需安装，对设备碎片化的适应能力优于App，它只需要通过HTML、CSS和JavaScript就可以在任意移动浏览器中执行。随着iPhone带来的WebKit浏览体验升级，使得专为iPhone等有WebKit浏览内核的移动设备开发的Web应用，也有了如App一般流畅的用户体验。</p><p>​    Web App即在浏览器直接可以访问的应用</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>开发成本低</li><li>一套代码适配多种移动设备</li><li>跨平台和终端</li><li>迭代更容易</li><li>无需安装成本</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>浏览体验短期内还无法超越原生应用</li><li>不支持离线模式（断网无法访问）</li><li>消息推送不及时</li><li>调用系统能力弱</li></ul><h2 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h2><p>​    Apache Cordova是一套设备API，允许移动应用的开发者使用JavaScript来访问本地设备的功能，比如摄像头、加速计。它可以与UI框架（如jQuery Mobile或Dojo Mobile或Sencha Touch）等相结合使用，这些UI框架可以使用HTML、CSS和JavaScript开发智能手机应用。</p><p>​    在使用<strong>Cordova</strong> API时，应用程序的构建可以无需本地代码（如Java或对象C等），使用的是Web技术。由于这些JavaScript API在多个设备平台上是一致的，而且是基于Web标准创建的，因此应用程序的移植很方便，基本不做什么改变。使用<strong>Cordova</strong>的应用使用平台SDK打包成应用程序，可以从每种设备的应用程序商店下载安装。</p><p>​    <strong>Cordova</strong>提供了一套统一的JavaScript库供调用，它支持iOS、Android、Blackberry、Windows Phone、Palm WebOS、Bada和Symbian。</p><ul><li>开发自由度</li></ul><p>​     首先 <strong>Cordova</strong> 构建的是一个运行于手机内置浏览器中的单页 Web 应用，因此理论上我们能够使用 jQuery，Angular 等等任何 Web 技术。</p><ul><li>界面表现</li></ul><p>​     <strong>Cordova</strong> 应用因为本质上是一个 Web 应用，因此某些地方会显得有些怪怪的。比如，列表滚动不像原生那么流畅，点击效果也缺少反馈。当然如果我们想让 <strong>Cordova</strong> 应用尽可能像原生应用的话，这些问题都是可以解决的，但也意味着我们需要付出额外的努力。</p><ul><li>性能方面</li></ul><p>​      <strong>Cordova</strong> 应用的性能很大程度上局限于运行它手机的 WebView 性能。比如，在 iOS 上，同一个 Web 应用，运行在默认 WebView 引擎上要明显慢于运行于 Safari 中。而 Android 也是在 4.0 之后 WebView 才换成了 Chrome 内核，因此，在老旧的 Android 机型上 <strong>Cordova</strong> 的表现会非常糟糕。进一步，由于 JavaScript 是单线程的，如果我们的<strong>Cordova</strong>应用同时做了很多事情，那可能就会遇到麻烦。</p><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><p>​    <strong>Weex</strong>能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。</p><p>​    对于移动开发者来说，<strong>Weex</strong>主要解决了频繁发版和多端研发两大痛点，同时解决了前端语言性能差和显示效果受限的问题。开发者可通过Weex官网申请内测。</p><p>​    开发者只需要在自己的APP中嵌入Weex的SDK，就可以通过撰写HTML/CSS/JavaScript来开发Native级别的<strong>Weex</strong>界面。<strong>Weex</strong>界面的生成码其实就是一段很小的JS，可以像发布网页一样轻松部署在服务端，然后在APP中请求执行。</p><p>目前<strong>Weex</strong>有三种集成方式：</p><ol><li>全页模式<br>​    目前支持单页使用或整个app使用<strong>Weex</strong>开发（还不完善，需要开发router和生命周期管理）这是主推的模式，可以类比RN。</li><li>Native Component模式<br>​        把<strong>Weex</strong>当作一个iOS/Android组件来使用，类比ImageView。这类需求遍布手淘主链路，如首页、主搜结果、交易组件化等，和业务同学沟 通下来这类Native页面主体已经很稳定，但是局部动态化需求旺盛导致频繁发版，解决这类问题也是<strong>Weex</strong>的重点。</li><li>H5 Component模式<br>​        在H5种使用<strong>Weex</strong>，类比WVC。一些较复杂或特殊的H5页面短期内无法完全转为<strong>Weex</strong>全页模式（或RN），比如猫超、互动类页面、一些复杂频道页 等。针对这个痛点我发起过WVC项目，并在实际业务中验证了这样的想法：在现有的H5页面上做微调，引入Native解决长列表内存暴增、滚动不流畅、动 画/手势体验差等问题。WVC将会融入到<strong>Weex</strong>中，成为<strong>Weex</strong>的H5 Components模式。</li></ol><p>这3种模式几乎涵盖了淘系业务上的动态化需求（针对Native）或体验提升需求（针对H5）。更有趣的是这3种模式的技术基础是一致的，这非常重要，意 味着：业务方可以使用Native或H5 Component模式 解决实际的业务痛点，同时平滑过渡到<strong>Weex</strong>全页模式。期待<strong>Weex</strong>成长壮大到AppFramework的那天。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。</li><li>Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。</li><li>Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Weex 相较于 RN 起步比较晚，社区没有 RN 活跃。</li><li>从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。</li><li>Weex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。</li></ul><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><p>​    React Native 是Facebook发布的，可以让广大开发者使用JavaScript和React开发应用，提倡组件化开发，也就是说React Native提供了一个个封装好的组件让开发者来进行使用，甚至可以相关嵌套形成新的组件。</p><p>​    使用React Native开发者可以维护多种平台(Web,Android和IOS)的同一份业务逻辑核心代码来创建原生应用。</p><p>​    现阶段Web APP的的体验还是无法达到Native APP的体验，所以这边fackbook更加强调的是<strong>“learn once, write everywhere”</strong>，应用前端我们使用js和React来开发不同平台的UI，下层核心模块编写复用的业务逻辑代码，提供应用开发效率。</p><p>​    React Native的设计理念：既拥有Native的用户体验、又保留React的开发效率。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>可以大大节省开发成本,百分之90多界面可以通过RN开发,一份代码可以适配Android和IOS。</li><li>RN有独特的UI实现框架,借助组件化开发是团队规模更容易进行调整,可以快速迭代项目。</li><li>RN可以通过一些手段自动匹配不同屏幕大小的手机,再也不需要自己去计算视图的大小和位置。</li><li>RN具备高效的UI调试。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>RN开发的程序内存消耗略大, 开发模式下开销大几十兆,发布后差异不大, 目前手机基本上都有2G以上的内存, 几十兆可以忽略不计了。</li><li>运行速度略慢， 不可否认，原生代码比RN运行速度略快, 显示一个界面多一两毫秒吧,正常的人根本感觉不到,如果你用不经过优化的原生代码反而不如RN。</li><li>安装包比原生代码安装包大,这点更可以忽略了, 现在手机什么都缺就不缺空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/10/19/app-develop-mode/app-develop_logo.jpg&quot; alt=&quot;app-develop_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;p&gt;对于手机app来说，近几年有以下几种开发模式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Native App&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Web App&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Cordova&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Weex&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;React Native&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;优点&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;性能高&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无需安装&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;界面复用性强&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;跨平台执行&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;跨平台执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缺点&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开发维护成本高&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用户体验不好&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;性能差&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开源较晚&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;学习曲线高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;技术&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;oc、swift、java&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;html、js&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;html、js&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;vue.js&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;react.js&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Native-App&quot;&gt;&lt;a href=&quot;#Native-App&quot; class=&quot;headerlink&quot; title=&quot;Native App&quot;&gt;&lt;/a&gt;Native App&lt;/h2&gt;&lt;p&gt;原生开发是系统自带的app开发方式，也是大部分人最熟悉app开发的技术，如android、ios、wp。是开发者采用最广泛的开发方式，优点十分显著。相比其他开发方式而言，原生开发可以访问设备中的所有功能，运行速度更快，性能更高，而且可以启用优秀的离线处理和存储能力等等，提供最佳的用户体验，最优质的用户界面，最华丽的交互。原生开发人员众多，开发环境成熟，有许多的开源库提供开发人员调用，可是方便实现各种设计效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="App" scheme="https://mah93.github.io/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>Dva兼容性</title>
    <link href="https://mah93.github.io/2017/10/10/dva-compatible/"/>
    <id>https://mah93.github.io/2017/10/10/dva-compatible/</id>
    <published>2017-10-10T11:02:32.000Z</published>
    <updated>2018-02-01T09:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/10/10/dva-compatible/dva_logo2.jpg" alt="dva_logo2.jpg" title=""><h2 id="Dva项目兼容性"><a href="#Dva项目兼容性" class="headerlink" title="Dva项目兼容性"></a>Dva项目兼容性</h2><p>之前上线的Dva项目，在Chrome和Safari中表现良好，但是在有些浏览器打不开，比如IE、某些版本的FireFox。这是由于在项目中，网络请求模块用到了fetch请求，由于fetch的局限性，导致部分浏览器不兼容。现记录下适配到IE的过程，以供自己学习。</p><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>之前发现IE浏览器打不开，通过查询得知是fetch的原因。由于一开始没有关注过fetch请求，以为是dva框架自带的请求框架，就没有深入的学习。查询一系列资料之后，将fetch的知识学习了一遍。<br>Fetch API 是基于 Promise 设计，在你理解了Promise之后，Fetch对于你来说并不困难，通过阅读文档很快就能学会。推荐推荐 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="external">MDN Fetch 教程</a> 和 万能的<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">WHATWG Fetch 规范</a>。由于旧的浏览器并不支持Promise，所以导致了Fetch的局限性。</p><a id="more"></a> <p>Fetch原生支持率：</p><img src="/2017/10/10/dva-compatible/fetch兼容性.png" alt="fetch兼容性" title="fetch兼容性"><p>由此可见，Fetch的兼容性并不好。不过网上给出了相应的解决办法，通过引入polyfill以支持IE8+</p><ol><li>由于 IE8 是 ES3，需要引入 ES5 的 polyfill: <a href="https://github.com/es-shims/es5-shim" target="_blank" rel="external">es5-shim, es5-sham</a></li><li>引入 Promise 的 polyfill: <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external">es6-promise</a></li><li>引入 fetch 探测库：<a href="https://github.com/camsong/fetch-detector" target="_blank" rel="external">fetch-detector</a></li><li>引入 fetch 的 polyfill: <a href="https://github.com/camsong/fetch-ie8" target="_blank" rel="external">fetch-ie8</a></li><li>可选：如果你还使用了 jsonp，引入 <a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="external">fetch-jsonp</a></li><li>可选：开启 Babel 的 runtime 模式，现在就使用 async/await</li></ol><p>在尝试了以上方法，把它们引入后，并没有生效（不</p><p>Fetch 请求默认是不带 cookie 的，需要设置 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">fetch</span>(<span class="selector-tag">url</span>, &#123;<span class="attribute">credentials</span>: <span class="string">'include'</span>&#125;)</div></pre></td></tr></table></figure><p>在实际操作的时候，加上了上述代码，依然不能带着cookie传递给后台（不</p><p>这里只介绍fetch的最简单应用，更具体的应用请看<a href="https://github.com/github/fetch" target="_blank" rel="external">github</a></p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">`post请求`</div><div class="line">fetch(url, &#123;</div><div class="line"><span class="function"><span class="keyword">method</span>:</span> <span class="function"><span class="keyword">method</span>,</span></div><div class="line">body: formData,</div><div class="line">  &#125;).<span class="keyword">then</span>(checkStatus)</div><div class="line">.<span class="keyword">then</span>(parseJSON)</div><div class="line">.<span class="keyword">then</span>((data) =&gt; &#123;</div><div class="line"> <span class="keyword">return</span> &#123; data &#125;;</div><div class="line">&#125;)</div><div class="line">.<span class="keyword">catch</span>(err =&gt; (&#123; err &#125;));</div></pre></td></tr></table></figure><p>发起fetch请求，需要将参数转化成FormData类型，请求成功后会依次执行.then()函数，在data中获取后台数据。</p><h3 id="XMLHTTPRequest"><a href="#XMLHTTPRequest" class="headerlink" title="XMLHTTPRequest"></a>XMLHTTPRequest</h3><p>各种引入polyfill仍然不能在IE中兼容，随后将目光转移到了原生js上。查看文档发现：所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。</p><p>由于没有用过jQuery和ajax，只是在查过文档稍稍了解了一下用法（误导</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123; <span class="comment">// IE</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP'</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (xhr) &#123;</div><div class="line">  xhr.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</div><div class="line">  xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">  xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText));</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  xhr.send(paramstring);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然并不知道原理，但上述代码在IE浏览器上运行正常，可以正确的获取到后台的值。但是由于它时候在onreadystatechange属性中，一直调用后面的方法，整个请求下来，调用五次后面的方法，在最后一次readyState等于4的时候，才获取到值。而且值在回调函数中，不能直接赋值获取，需要通过调用者传递一个回调函数，将值回调出去。</p><p>由于项目中采用Promise回调，并不想做太大改动，所以摒弃了这种写法</p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><img src="/2017/10/10/dva-compatible/68747470733a2f2f73617563656c6162732e636f6d2f6f70656e5f73617563652f6275696c645f6d61747269782f6178696f732e737667.svg" alt="Axios兼容性" title="Axios兼容性"><p>由上图可知，axios兼容性十分不错，寄希望它可以解决Dva项目的兼容性问题。用axios整体替换掉fetch。Axios API和Fetch API十分相近，简单的用法和fetch基本一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">`post请求`</span></div><div class="line">axios.post(<span class="string">'/user'</span>, &#123;</div><div class="line">    firstName: <span class="string">'Fred'</span>,</div><div class="line">    lastName: <span class="string">'Flintstone'</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>然后在入口函数中引入es6-promise</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">require</span>(<span class="string">'es6-promise'</span>)<span class="selector-class">.polyfill</span>();</div></pre></td></tr></table></figure><p>经本地测试，IE浏览器可以正常访问，基本解决了IE兼容性的问题。</p><p>大致查看了一下文档，axios的拓展性以及可定制性比较高，操作空间比fetch要强，考虑后续将fetch都替换成axios</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>在测试FireFox浏览器的时候，一直白屏。控制台报错</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">错误:样式表单index<span class="selector-class">.css</span> 未载入，因为它的MIME类型 <span class="string">"text/html"</span> 不是 <span class="string">"text/css"</span></div></pre></td></tr></table></figure><p>在index.html中，将</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</span></div><div class="line"><span class="meta">  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></div></pre></td></tr></table></figure><p>改成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt;</div><div class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span></div><div class="line">  <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure><p>这样，只有在IE下才会使用这个头部声明，而在FireFox下是不会使用的。</p><ul><li>访问项目，到某路由下刷新出现白屏并且出现如下错误</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">index</span><span class="selector-class">.js</span><span class="selector-pseudo">:1</span> <span class="selector-tag">Uncaught</span> <span class="selector-tag">SyntaxError</span>: <span class="selector-tag">Unexpected</span> <span class="selector-tag">token</span> &lt;</div></pre></td></tr></table></figure><p>在编译之前将index.js的相对路径改成绝对路径、</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> */</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>index.css同理</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/10/10/dva-compatible/dva_logo2.jpg&quot; alt=&quot;dva_logo2.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;Dva项目兼容性&quot;&gt;&lt;a href=&quot;#Dva项目兼容性&quot; class=&quot;headerlink&quot; title=&quot;Dva项目兼容性&quot;&gt;&lt;/a&gt;Dva项目兼容性&lt;/h2&gt;&lt;p&gt;之前上线的Dva项目，在Chrome和Safari中表现良好，但是在有些浏览器打不开，比如IE、某些版本的FireFox。这是由于在项目中，网络请求模块用到了fetch请求，由于fetch的局限性，导致部分浏览器不兼容。现记录下适配到IE的过程，以供自己学习。&lt;/p&gt;
&lt;h3 id=&quot;Fetch&quot;&gt;&lt;a href=&quot;#Fetch&quot; class=&quot;headerlink&quot; title=&quot;Fetch&quot;&gt;&lt;/a&gt;Fetch&lt;/h3&gt;&lt;p&gt;之前发现IE浏览器打不开，通过查询得知是fetch的原因。由于一开始没有关注过fetch请求，以为是dva框架自带的请求框架，就没有深入的学习。查询一系列资料之后，将fetch的知识学习了一遍。&lt;br&gt;Fetch API 是基于 Promise 设计，在你理解了Promise之后，Fetch对于你来说并不困难，通过阅读文档很快就能学会。推荐推荐 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN Fetch 教程&lt;/a&gt; 和 万能的&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WHATWG Fetch 规范&lt;/a&gt;。由于旧的浏览器并不支持Promise，所以导致了Fetch的局限性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
      <category term="Dva" scheme="https://mah93.github.io/tags/Dva/"/>
    
  </entry>
  
  <entry>
    <title>Dva项目部署至Nginx服务器</title>
    <link href="https://mah93.github.io/2017/10/01/dva-deploy/"/>
    <id>https://mah93.github.io/2017/10/01/dva-deploy/</id>
    <published>2017-10-01T14:31:10.000Z</published>
    <updated>2018-02-01T09:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/10/01/dva-deploy/dva_logo.jpg" alt="dva_logo.jpg" title=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>dva是在现有的应用架构进行了轻量级封装，相比于redux更易上手。如需了解更多请参考<a href="https://github.com/dvajs/dva" target="_blank" rel="external">这里</a><br>项目中运用的技术架构是react+dva+antd，完成之后需要将应用部署到服务器上，需要一台服务器，仅以Nginx为例，记录整个的部署流程。</p><h2 id="部署前准备"><a href="#部署前准备" class="headerlink" title="部署前准备"></a>部署前准备</h2><p>在完成你的dva项目之后，从coding或者你的git服务器上克隆项目到本地<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> 你的dva项目</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> project</span></div><div class="line"><span class="meta">$</span><span class="bash"> npm install</span></div></pre></td></tr></table></figure></p><p>成功下载完所有配置文件之后执行，再次确认你的项目可以正确访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm start</span></div></pre></td></tr></table></figure><p>即可自动打开浏览器的8000端口，成功运行该项目，如果没有自动弹出则访问<a href="http://localhost:8000/" target="_blank" rel="external">localhost:8000/</a></p><a id="more"></a> <h2 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h2><p>在项目中的.roadhogrc文件中删除以下配置</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"proxy"</span>: &#123;</div><div class="line">  <span class="string">"/api"</span>: &#123;</div><div class="line">  <span class="string">"target"</span>: 你的后台服务地址,</div><div class="line">  <span class="string">"changeOrigin"</span>: true,</div><div class="line">  <span class="string">"pathRewrite"</span>: &#123; <span class="string">"^/api"</span> : <span class="string">""</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后进入命令行，执行编译操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm run build</span></div></pre></td></tr></table></figure><p>执行完之后会在主目录下生成dist文件夹，里面包含index.html、index.js、index.css以及资源文件夹static。<br>打包完成后，把dist文件夹上传至服务器上即可访问，这里用的是nginx服务器。</p><h3 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h3><p><strong>Nginx</strong>（发音同 engine x）是一款轻量级的Web 服务器／反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。</p><p><strong>本项目采用 Nginx 作为 Web 服务器。</strong></p><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>由于服务器是ubuntu系统，这里仅展示在ubuntu系统下安装过程，其他操作系统可自行查找</p><p>登录服务器之后执行，下载nginx安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo wget http://nginx.org/download/nginx-1.2.2.tar.gz</span></div></pre></td></tr></table></figure><p>然后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo  tar -xzvf nginx-1.2.2.tar.gz</span></div></pre></td></tr></table></figure><p>进入解压之后的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> nginx-1.2.2</span></div><div class="line"><span class="meta">$</span><span class="bash"> ./configure</span></div></pre></td></tr></table></figure><p>如果一切顺利的话，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make</span></div><div class="line"><span class="meta">$</span><span class="bash"> make install</span></div></pre></td></tr></table></figure><p>完成安装，可以在/usr/local文件下找到nginx文件夹</p><p>然后访问服务器即可看到</p><p>welcome nginx</p><h2 id="nginx安装常见问题"><a href="#nginx安装常见问题" class="headerlink" title="nginx安装常见问题"></a>nginx安装常见问题</h2><ul><li><h3 id="缺少pcre"><a href="#缺少pcre" class="headerlink" title="缺少pcre"></a>缺少pcre</h3><p>执行./configure之后，出现</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure: error: the HTTP rewrite <span class="keyword">module</span> requires the PCRE <span class="keyword">library</span>. You can either disable the <span class="keyword">module</span> <span class="keyword">by</span> <span class="keyword">using</span> --without-http_rewrite_module option, <span class="keyword">or</span> install the PCRE <span class="keyword">library</span> <span class="keyword">into</span> the system, <span class="keyword">or</span> build the PCRE <span class="keyword">library</span> statically <span class="keyword">from</span> the source <span class="keyword">with</span> nginx <span class="keyword">by</span> <span class="keyword">using</span> --<span class="keyword">with</span>-pcre=&lt;path&gt; option.</div></pre></td></tr></table></figure><p>即提示缺少pcre library</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="builtin-name">get</span> undate</div><div class="line">$ sudo apt-<span class="builtin-name">get</span> install libpcre3 libpcre3-dev</div></pre></td></tr></table></figure></li><li><h3 id="缺少gcc-c-和libtool"><a href="#缺少gcc-c-和libtool" class="headerlink" title="缺少gcc-c++和libtool"></a>缺少gcc-c++和libtool</h3><p>执行./configure之后，出现</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">libtool: <span class="keyword">compile</span>: unrecognized option `-DHAVE_CONFIG_H'</div><div class="line">libtool: <span class="keyword">compile</span>: Try `libtool --help' <span class="keyword">for</span> more information.</div><div class="line"><span class="built_in">make</span>[<span class="number">1</span>]: *** [pcrecpp.lo] <span class="built_in">Error</span> <span class="number">1</span></div><div class="line"><span class="built_in">make</span>[<span class="number">1</span>]: Leaving directory `/usr/<span class="keyword">local</span>/src<span class="comment">//pcre-8.31'</span></div><div class="line"><span class="built_in">make</span>: *** [all] <span class="built_in">Error</span> <span class="number">2</span>root<span class="comment">@wolfdog-virtual-machine:~/work/pcre-8.12$ libtool -help -DHAVE_CONFIG_H</span></div><div class="line"><span class="comment">The program 'libtool' is currently not installed.  You can install it by typing:</span></div><div class="line"><span class="comment">sudo apt-get install libtool</span></div></pre></td></tr></table></figure><p>即提示缺少libtool和gcc-c++</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="builtin-name">get</span> install libtool</div><div class="line">$ sudo apt-<span class="builtin-name">get</span> install gcc-c++</div></pre></td></tr></table></figure></li><li><h3 id="缺少zlib库"><a href="#缺少zlib库" class="headerlink" title="缺少zlib库"></a>缺少zlib库</h3><p>执行./configure之后，出现</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure: error: <span class="keyword">the</span> HTTP gzip module requires <span class="keyword">the</span> zlib library.</div><div class="line">You can either disable <span class="keyword">the</span> module <span class="keyword">by</span> <span class="keyword">using</span> <span class="comment">--without-http_gzip_module</span></div><div class="line">option, <span class="keyword">or</span> install <span class="keyword">the</span> zlib library <span class="keyword">into</span> <span class="keyword">the</span> <span class="keyword">system</span>, <span class="keyword">or</span> build <span class="keyword">the</span> zlib library</div><div class="line">statically <span class="built_in">from</span> <span class="keyword">the</span> source <span class="keyword">with</span> nginx <span class="keyword">by</span> <span class="keyword">using</span> <span class="comment">--with-zlib=&lt;path&gt; option.</span></div></pre></td></tr></table></figure><p>其提示缺少zlib库</p><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="built_in">get</span> install openssl libssl-<span class="built_in">dev</span> libperl-<span class="built_in">dev</span></div></pre></td></tr></table></figure></li></ul><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx的配置文件在/usr/local/nginx/conf文件夹下，其主要的配置文件是nginx.conf文件，编辑该文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vi nginx.conf</span></div></pre></td></tr></table></figure><p>在配置文件的http下写入如下配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  localhost;</div><div class="line"></div><div class="line">    <span class="comment">#charset koi8-r;</span></div><div class="line"></div><div class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">       <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">       <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">       <span class="attribute">proxy_set_header</span> HOST <span class="variable">$http_host</span>;</div><div class="line">       <span class="attribute">proxy_set_header</span> X-Nginx_Proxy <span class="literal">true</span>;</div><div class="line">       <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</div><div class="line">       <span class="attribute">root</span>  dist;</div><div class="line">       <span class="attribute">index</span>  index.html index.htm;</div><div class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> /index.html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /api/ &#123;</div><div class="line">      <span class="attribute">proxy_set_header</span>  X-Real-IP  <span class="variable">$remote_addr</span>;</div><div class="line">      <span class="attribute">proxy_set_header</span>  X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">      <span class="attribute">proxy_read_timeout</span>       <span class="number">300</span>;</div><div class="line">      <span class="attribute">proxy_send_timeout</span>       <span class="number">600</span>;</div><div class="line">      <span class="attribute">proxy_ignore_client_abort</span> <span class="literal">on</span>;</div><div class="line">      <span class="attribute">proxy_connect_timeout</span>    <span class="number">300</span>;</div><div class="line">      <span class="attribute">proxy_next_upstream</span>     <span class="literal">error</span>;</div><div class="line">      <span class="attribute">proxy_pass</span> 这里填入后台服务地址;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>之后用scp命令将本地的dist文件夹上传至服务器的/usr/local/nginx文件夹下即可，上传成功之后启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> /usr/<span class="built_in">local</span>/nginx/sbin/nginx -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span></div></pre></td></tr></table></figure><p>成功之后访问服务器即可看到项目首页</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/10/01/dva-deploy/dva_logo.jpg&quot; alt=&quot;dva_logo.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;dva是在现有的应用架构进行了轻量级封装，相比于redux更易上手。如需了解更多请参考&lt;a href=&quot;https://github.com/dvajs/dva&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;br&gt;项目中运用的技术架构是react+dva+antd，完成之后需要将应用部署到服务器上，需要一台服务器，仅以Nginx为例，记录整个的部署流程。&lt;/p&gt;
&lt;h2 id=&quot;部署前准备&quot;&gt;&lt;a href=&quot;#部署前准备&quot; class=&quot;headerlink&quot; title=&quot;部署前准备&quot;&gt;&lt;/a&gt;部署前准备&lt;/h2&gt;&lt;p&gt;在完成你的dva项目之后，从coding或者你的git服务器上克隆项目到本地&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; 你的dva项目&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; project&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm install&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;成功下载完所有配置文件之后执行，再次确认你的项目可以正确访问&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm start&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即可自动打开浏览器的8000端口，成功运行该项目，如果没有自动弹出则访问&lt;a href=&quot;http://localhost:8000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;localhost:8000/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://mah93.github.io/tags/React/"/>
    
      <category term="Dva" scheme="https://mah93.github.io/tags/Dva/"/>
    
      <category term="Nginx" scheme="https://mah93.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mah93.github.io/2017/10/01/hello-world/"/>
    <id>https://mah93.github.io/2017/10/01/hello-world/</id>
    <published>2017-10-01T14:27:11.000Z</published>
    <updated>2018-02-01T08:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><a id="more"></a> <p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
